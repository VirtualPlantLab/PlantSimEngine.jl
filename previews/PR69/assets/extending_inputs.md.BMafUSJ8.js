import{_ as e,c as t,o as a,a7 as i}from"./chunks/framework.BZ-6itpL.js";const g=JSON.parse('{"title":"Input types","description":"","frontmatter":{},"headers":[],"relativePath":"extending/inputs.md","filePath":"extending/inputs.md","lastUpdated":null}'),s={name:"extending/inputs.md"},o=i('<h1 id="Input-types" tabindex="-1">Input types <a class="header-anchor" href="#Input-types" aria-label="Permalink to &quot;Input types {#Input-types}&quot;">​</a></h1><p><a href="/VirtualPlantLab.github.io/PlantSimEngine.jl/previews/PR69/API#PlantSimEngine.run!"><code>run!</code></a> usually takes two inputs: a <a href="/VirtualPlantLab.github.io/PlantSimEngine.jl/previews/PR69/model_switching#ModelList"><code>ModelList</code></a> and data for the meteorology. The data for the meteorology is usually provided for one time step using an <code>Atmosphere</code>, or for several time-steps using a <code>TimeStepTable{Atmosphere}</code>. The <a href="/VirtualPlantLab.github.io/PlantSimEngine.jl/previews/PR69/model_switching#ModelList"><code>ModelList</code></a> can also be provided as a singleton, or as a vector or dictionary of.</p><p><a href="/VirtualPlantLab.github.io/PlantSimEngine.jl/previews/PR69/API#PlantSimEngine.run!"><code>run!</code></a> knows how to handle these data formats via the <a href="/VirtualPlantLab.github.io/PlantSimEngine.jl/previews/PR69/API#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a> trait (see <a href="https://www.juliabloggers.com/the-emergent-features-of-julialang-part-ii-traits/" target="_blank" rel="noreferrer">this blog post</a> to learn more about traits). For example, we tell PlantSimEngine that a <code>TimeStepTable</code> should be handled like a table by implementing the following trait:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataFormat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:PlantMeteo.TimeStepTable}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TableAlike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>If you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataFormat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{&lt;:MyTableFormat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TableAlike</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>There are two other traits available: <code>SingletonAlike</code> for a data format representing one time-step only, and <code>TreeAlike</code> for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).</p><h2 id="Special-considerations-for-new-input-types" tabindex="-1">Special considerations for new input types <a class="header-anchor" href="#Special-considerations-for-new-input-types" aria-label="Permalink to &quot;Special considerations for new input types {#Special-considerations-for-new-input-types}&quot;">​</a></h2><p>If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on your use-cases.</p><p>For example if you use models that need to get data from a different time step (<em>e.g.</em> a model that needs to get the previous day&#39;s temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.</p><p>To do so, you need to implement the following methods for your structure that defines your rows:</p><ul><li><p><code>Base.parent</code>: return the parent table of the row, <em>e.g.</em> the full DataFrame</p></li><li><p><code>PlantMeteo.rownumber</code>: return the row number of the row in the parent table, <em>e.g.</em> the row number in the DataFrame</p></li><li><p>(Optionnally) <code>PlantMeteo.row_from_parent(row, i)</code>: return row <code>i</code> from the parent table, <em>e.g.</em> the row <code>i</code> from the DataFrame. This is only needed if you want high performance, the default implementation calls <code>Tables.rows(parent(row))[i]</code>.</p></li></ul><div class="tip custom-block"><p class="custom-block-title">Compat</p><p><code>PlantMeteo.rownumber</code> is temporary. It soon will be replaced by <code>DataAPI.rownumber</code> instead, which will be also used by <em>e.g.</em> DataFrames.jl. See <a href="https://github.com/JuliaData/DataAPI.jl/issues/60" target="_blank" rel="noreferrer">this Pull Request</a>.</p></div>',13),n=[o];function r(l,p,d,h,c,u){return a(),t("div",null,n)}const k=e(s,[["render",r]]);export{g as __pageData,k as default};
