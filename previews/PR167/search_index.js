var documenterSearchIndex = {"docs":
[{"location":"working_with_data/fitting/#Parameter-fitting","page":"Fitting","title":"Parameter fitting","text":"","category":"section"},{"location":"working_with_data/fitting/#The-fit-method","page":"Fitting","title":"The fit method","text":"Models are often calibrated using data, but the calibration process is not always the same depending on the model, and the data available to the user.\n\nPlantSimEngine defines a generic fit function that allows modelers provide a fitting algorithm for their model, and for users to use this method to calibrate the model using data.\n\nThe function does nothing in this package, it is only defined to provide a common interface for all the models. It is up to the modeler to implement the method for their model. \n\nThe method is implemented as a function with the following design pattern: the call to the function should take the model type as the first argument (T::Type{<:AbstractModel}), the data as the second argument (as a Table.jl compatible type, such as DataFrame), and any more information as keyword arguments, e.g. constants or parameters initializations with default values when necessary.","category":"section"},{"location":"working_with_data/fitting/#Example-with-Beer","page":"Fitting","title":"Example with Beer","text":"The example script (see src/examples/Beer.jl) that implements the Beer model provides an example of how to implement the fit method for a model:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function takes a Beer type as the first argument, the data as a Tables.jl compatible type, such as a DataFrame as the second argument, and the J_to_umol constant as a keyword argument, which is used to convert between μ mol m⁻² s⁻¹ and J m⁻² s⁻¹.\n\ndf should contain the columns PPFD (μ mol m⁻² s⁻¹), LAI (m² m⁻²) and Ri_PAR_f (W m⁻²). The function then computes k based on these values, and returns it as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere's an example of how to use the fit method:\n\nImporting the script first: \n\nusing PlantSimEngine, PlantMeteo, DataFrames, Statistics\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nDefining the meteo data:\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\n\nComputing the PPFD values from the Ri_PAR_f values using the Beer model (with k=0.6):\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\nNow we can define the \"data\" to fit the model using the simulated PPFD values:\n\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\n\nAnd finally we can fit the model using the fit method:\n\nfit(Beer, df)\n\nnote: Note\nThis is a dummy example to show that the fitting method works. A real application would fit the parameter values on the data directly.","category":"section"},{"location":"API/API_private/#API-internal-functions","page":"Internal API","title":"API - internal functions","text":"","category":"section"},{"location":"API/API_private/#Un-exported","page":"Internal API","title":"Un-exported","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat). Most of them are developer code, but some may be useful for tinkerers, or to have greater control over some simulation parameters (future versions of this documentation might break those categories into separate pages for clarity).","category":"section"},{"location":"API/API_private/#Index","page":"Internal API","title":"Index","text":"Pages = [\"API_private.md\"]","category":"section"},{"location":"API/API_private/#API-documentation","page":"Internal API","title":"API documentation","text":"","category":"section"},{"location":"API/API_private/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:Status}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Current_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Current_TimestepModel","text":"basic_current_timestep process abstract model. \n\nAll models implemented to simulate the basic_current_timestep process must be a subtype of this type, e.g.  struct MyBasic_Current_TimestepModel <: AbstractBasic_Current_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Current_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Next_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Next_TimestepModel","text":"basic_next_timestep process abstract model. \n\nAll models implemented to simulate the basic_next_timestep process must be a subtype of this type, e.g.  struct MyBasic_Next_TimestepModel <: AbstractBasic_Next_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Next_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractNodeMapping","page":"Internal API","title":"PlantSimEngine.AbstractNodeMapping","text":"AbstractNodeMapping\n\nAbstract type for the type of node mapping, e.g. single node mapping or multiple node mapping.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"Internal API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\nTreeAlike: The data is a tree-like object, e.g. a Node.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for GraphSimulation,  SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.DependencyGraph","page":"Internal API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DependencyTrait","page":"Internal API","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\nReturns information about the eventual dependence of a model T to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.\n\nThe following dependence traits are supported:\n\nTimeStepDependencyTrait: Trait that defines whether a model can be parallelizable over time-steps for its computation.\nObjectDependencyTrait: Trait that defines whether a model can be parallelizable over objects for its computation.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.GraphSimulation","page":"Internal API","title":"PlantSimEngine.GraphSimulation","text":"GraphSimulation(graph, mapping)\nGraphSimulation(graph, statuses, dependency_graph, models, outputs)\n\nA type that holds all information for a simulation over a graph.\n\nArguments\n\ngraph: an graph, such as an MTG\nmapping: a dictionary of model mapping\nstatuses: a structure that defines the status of each node in the graph\nstatus_templates: a dictionary of status templates\nreverse_multiscale_mapping: a dictionary of mapping for other scales\nvar_need_init: a dictionary indicating if a variable needs to be initialized\ndependency_graph: the dependency graph of the models applied to the graph\nmodels: a dictionary of models\noutputs: a dictionary of outputs\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MappedVar","page":"Internal API","title":"PlantSimEngine.MappedVar","text":"MappedVar(source_organ, variable, source_variable, source_default)\n\nA variable mapped to another scale.\n\nArguments\n\nsource_organ: the organ(s) that are targeted by the mapping\nvariable: the name of the variable that is mapped\nsource_variable: the name of the variable from the source organ (the one that computes the variable)\nsource_default: the default value of the variable\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\nPlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MultiNodeMapping","page":"Internal API","title":"PlantSimEngine.MultiNodeMapping","text":"MultiNodeMapping(scale)\n\nType for the multiple node mapping, e.g. [:carbon_assimilation => [\"Leaf\"],]. Note that \"Leaf\" is given as a vector, which means :carbon_assimilation will be a vector of values taken from each \"Leaf\" in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.ObjectDependencyTrait","page":"Internal API","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.\n\nThe following dependency traits are supported:\n\nIsObjectDependent: The model depends on other objects for its computation, it cannot be run in parallel.\nIsObjectIndependent: The model does not depend on other objects for its computation, it can be run in parallel.\n\nAll models are object dependent by default (i.e. IsObjectDependent). This is probably not right for the majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsObjectIndependent)\n\nIt is easy to override this trait for models that are object independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # false\n\nDefine a model that is object dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVariable","page":"Internal API","title":"PlantSimEngine.RefVariable","text":"RefVariable(reference_variable)\n\nA structure to manually flag a variable in a model to use the value of another variable at the same scale. This is used for variable renaming, when a variable is computed by a model but is used by another model with a different name.\n\nNote: we don't really rename the variable in the status (we need it for the other models), but we create a new one that is a reference to the first one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVector","page":"Internal API","title":"PlantSimEngine.RefVector","text":"RefVector(field::Symbol, sts...)\nRefVector(field::Symbol, sts::Vector{<:Status})\nRefVector(v::Vector{Base.RefValue{T}})\n\nA vector of references to a field of a vector of structs. This is used to efficiently pass the values between scales.\n\nArguments\n\nfield: the field of the struct to reference\nsts...: the structs to reference\nsts::Vector{<:Status}: a vector of structs to reference\n\nExamples\n\njulia> using PlantSimEngine\n\nLet's take two Status structs:\n\njulia> status1 = Status(a = 1.0, b = 2.0, c = 3.0);\n\njulia> status2 = Status(a = 2.0, b = 3.0, c = 4.0);\n\nWe can make a RefVector of the field a of the structs st1 and st2:\n\njulia> rv = PlantSimEngine.RefVector(:a, status1, status2)\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWhich is equivalent to:\n\njulia> rv = PlantSimEngine.RefVector(:a, [status1, status2])\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWe can access the values of the RefVector:\n\njulia> rv[1]\n1.0\n\nUpdating the value in the RefVector will update the value in the original struct:\n\njulia> rv[1] = 10.0\n10.0\n\njulia> status1.a\n10.0\n\nWe can also make a RefVector from a vector of references:\n\njulia> vec = [Ref(1.0), Ref(2.0), Ref(3.0)]\n3-element Vector{Base.RefValue{Float64}}:\n Base.RefValue{Float64}(1.0)\n Base.RefValue{Float64}(2.0)\n Base.RefValue{Float64}(3.0)\n\njulia> rv = PlantSimEngine.RefVector(vec)\n3-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> rv[1]\n1.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SelfNodeMapping","page":"Internal API","title":"PlantSimEngine.SelfNodeMapping","text":"SelfNodeMapping()\n\nType for the self node mapping, i.e. a node that maps onto itself. This is used to flag variables that will be referenced as a scalar value by other models. It can happen in two conditions:     - the variable is computed by another scale, so we need this variable to exist as an input to this scale (it is not      computed at this scale otherwise)     - the variable is used as input to another scale but as a single value (scalar), so we need to reference it as a scalar.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SingleNodeMapping","page":"Internal API","title":"PlantSimEngine.SingleNodeMapping","text":"SingleNodeMapping(scale)\n\nType for the single node mapping, e.g. [:soil_water_content => \"Soil\",]. Note that \"Soil\" is given as a scalar, which means that :soil_water_content will be a scalar value taken from the unique \"Soil\" node in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"Internal API","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.\n\nThe following dependency traits are supported:\n\nIsTimeStepDependent: The model depends on other time-steps for its computation, it cannot be run in parallel.\nIsTimeStepIndependent: The model does not depend on other time-steps for its computation, it can be run in parallel.\n\nAll models are time-step dependent by default (i.e. IsTimeStepDependent). This is probably not right for the  majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsTimeStepIndependent)\n\nIt is easy to override this trait for models that are time-step independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # false\n\nDefine a model that is time-step dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.UninitializedVar","page":"Internal API","title":"PlantSimEngine.UninitializedVar","text":"UninitializedVar(variable, value)\n\nA variable that is not initialized yet, it is given a name and a default value.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:ModelList","page":"Internal API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"Internal API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tₗ at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!","text":"add_mapped_variables_with_outputs_as_inputs!(mapped_vars)\n\nAdd the variables that are computed at a scale and written to another scale into the mapping.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\nusing PlantSimEngine.Examples\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}","page":"Internal API","title":"PlantSimEngine.convert_reference_values!","text":"convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nConvert the variables that are MappedVar{SelfNodeMapping} or MappedVar{SingleNodeMapping} to RefValues that reference a  common value for the variable; and convert MappedVar{MultiNodeMapping} to RefVectors that reference the values for the variable in the source organs.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_vars","page":"Internal API","title":"PlantSimEngine.convert_vars","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)\n\nConverts the types of the variables in a mapping (mapped_vars) using the type_promotion dictionary.\n\nThe mapping should be a dictionary with organ name as keys and a dictionary of variables as values, with variable names as symbols and variable value as value.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.default_variables_from_mapping","page":"Internal API","title":"PlantSimEngine.default_variables_from_mapping","text":"default_variables_from_mapping(mapped_vars, verbose=true)\n\nGet the default values for the mapped variables by recursively searching from the mapping to find the original mapped value.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"Internal API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_panel","page":"Internal API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"Internal API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => namedtuple of variables => value.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\njulia> flatten_vars([:process1 => (var1 = -Inf, var2 = -Inf), :process2 => (var3 = -Inf, var4 = -Inf)])\n(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_mapped_variables-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_mapped_variables","text":"get_mapped_variables(m)\n\nGet the mapping of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of pairs of symbols and strings or vectors of strings\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}","page":"Internal API","title":"PlantSimEngine.get_model_nodes","text":"get_model_nodes(dep_graph::DependencyGraph, model)\n\nGet the nodes in the dependency graph implementing a type of model.\n\nArguments\n\ndep_graph::DependencyGraph: the dependency graph.\nmodel: the model type to look for.\n\nReturns\n\nAn array of nodes implementing the model type.\n\nExamples\n\nPlantSimEngine.get_model_nodes(dependency_graph, Beer)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_models-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_models","text":"get_models(m)\n\nGet the models of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of models\n\nExamples\n\njulia> using PlantSimEngine;\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nIf we just give a MultiScaleModel, we get its model as a one-element vector:\n\njulia> models = MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], );\n\njulia> PlantSimEngine.get_models(models)\n1-element Vector{ToyCAllocationModel}:\n ToyCAllocationModel()\n\nIf we give a tuple of models, we get each model in a vector:\n\njulia> models2 = (  MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );\n\nNotice that we provide \"Soil\", not [\"Soil\"] in the mapping because a single value is expected for the mapping here.\n\njulia> PlantSimEngine.get_models(models2)\n2-element Vector{AbstractModel}:\n ToyAssimModel{Float64}(0.2)\n ToyCDemandModel{Float64}(10.0, 200.0)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_multiscale_default_value","page":"Internal API","title":"PlantSimEngine.get_multiscale_default_value","text":"get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])\n\nGet the default value of a variable from a mapping.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nval::Any: the variable to get the default value of.\nmapping_stacktrace::Vector{Any}: the stacktrace of the search for the value in ascendind the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.get_nsteps-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_nsteps","text":"get_nsteps(t)\n\nGet the number of steps in the object.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_status-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_status","text":"get_status(m)\n\nGet the status of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a Status or nothing.\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.hard_dependencies-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.hard_dependencies","text":"hard_dependencies(models; verbose::Bool=true)\nhard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)\n\nCompute the hard dependencies between models.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_node_status!","page":"Internal API","title":"PlantSimEngine.init_node_status!","text":"init_node_status!(\n    node, \n    statuses, \n    mapped_vars, \n    reverse_multiscale_mapping,\n    vars_need_init=Dict{String,Any}(),\n    type_promotion=nothing;\n    check=true,\n    attribute_name=:plantsimengine_status)\n)\n\nInitialise the status of a plant graph node, taking into account the multiscale mapping, and add it to the statuses dictionary.\n\nArguments\n\nnode: the node to initialise\nstatuses: the dictionary of statuses by node type\nmapped_vars: the template of status for each node type\nreverse_multiscale_mapping: the variables that are mapped to other scales\nvar_need_init: the variables that are not initialised or computed by other models\nnodes_with_models: the nodes that have a model defined for their symbol\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors (see details)\nattribute_name: the name of the attribute to store the status in the node, by default: :plantsimengine_status\n\nDetails\n\nMost arguments can be computed from the graph and the mapping:\n\nstatuses is given by the first initialisation: statuses = Dict(i => Status[] for i in nodes_with_models)\nmapped_vars is computed using mapped_variables(), see code in init_statuses\nvars_need_init is computed using `varsneedinit = Dict(org => filter(x -> isa(last(x), UninitializedVar), vars) |> keys for (org, vars) in mapped_vars) |>\n\nfilter(x -> length(last(x)) > 0)`\n\nThe check argument is a boolean indicating if variables initialisation should be checked. In the case that some variables need initialisation (partially initialized mapping), we check if the value can be found  in the node attributes (using the variable name). If true, the function returns an error if the attribute is missing, otherwise it uses the default value from the model.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_simulation-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_simulation","text":"init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)\n\nInitialise the simulation. Returns:\n\nthe mtg\na status for each node by organ type, considering multi-scale variables\nthe dependency graph of the models\nthe models parsed as a Dict of organ type => NamedTuple of process => model mapping\nthe pre-allocated outputs\n\nArguments\n\nmtg: the MTG\nmapping::Dict{String,Any}: a dictionary of model mapping\nnsteps: the number of steps of the simulation\noutputs: the dynamic outputs needed for the simulation\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\nverbose: print information about errors in the mapping\n\nDetails\n\nThe function first computes a template of status for each organ type that has a model in the mapping. This template is used to initialise the status of each node of the MTG, taking into account the user-defined  initialisation, and the (multiscale) mapping. The mapping is used to make references to the variables that are defined at another scale, so that the values are automatically updated when the variable is changed at the other scale. Two types of multiscale variables are available: RefVector and MappedVar. The first one is used when the variable is mapped to a vector of nodes, and the second one when it is mapped to a single node. This  is given by the user through the mapping, using a string for a single node (e.g. => \"Leaf\"), and a vector of strings for a vector of nodes (e.g. => [\"Leaf\"] for one type of node or => [\"Leaf\", \"Internode\"] for several). \n\nThe function also computes the dependency graph of the models, i.e. the order in which the models should be called, considering the dependencies between them. The dependency graph is used to call the models in the right order when the simulation is run.\n\nNote that if a variable is not computed by models or initialised from the mapping, it is searched in the MTG attributes.  The value is not a reference to the one in the attribute of the MTG, but a copy of it. This is because we can't reference  a value in a Dict. If you need a reference, you can use a Ref for your variable in the MTG directly, and it will be  automatically passed as is.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_statuses","page":"Internal API","title":"PlantSimEngine.init_statuses","text":"init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)\n\nGet the status of each node in the MTG by node type, pre-initialised considering multi-scale variables.\n\nArguments\n\nmtg: the plant graph\nmapping: a dictionary of model mapping\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\ntype_promotion: the type promotion to use for the variables\nverbose: print information when compiling the mapping\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\n\nReturn\n\nA NamedTuple of status by node type, a dictionary of status templates by node type, a dictionary of variables mapped to other scales, a dictionary of variables that need to be initialised or computed by other models, and a vector of nodes that have a model defined for their symbol:\n\n(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.initialise_all_as_hard_dependency_node","text":"initialise_all_as_hard_dependency_node(models)\n\nTake a set of models and initialise them all as a hard dependency node, and  return a dictionary of :process => HardDependencyNode.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}","page":"Internal API","title":"PlantSimEngine.is_graph_cyclic","text":"is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)\n\nCheck if the dependency graph is cyclic.\n\nArguments\n\ndependency_graph::DependencyGraph: the dependency graph to check.\nfull_stack::Bool=false: if true, return the full stack of nodes that makes the cycle, otherwise return only the cycle.\nwarn::Bool=true: if true, print a stylised warning message when a cycle is detected.\n\nReturn a boolean indicating if the graph is cyclic, and the stack of nodes as a vector.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.mapped_variables","page":"Internal API","title":"PlantSimEngine.mapped_variables","text":"mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)\n\nGet the variables for each organ type from a dependency graph, with MappedVars for the multiscale mapping.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.mapped_variables_no_outputs_from_other_scale","page":"Internal API","title":"PlantSimEngine.mapped_variables_no_outputs_from_other_scale","text":"mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))\n\nGet the variables for each organ type from a dependency graph, without the variables that are outputs from another scale.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nDetails\n\nThis function returns a dictionary with the (multiscale-) inputs and outputs variables for each organ type. \n\nNote that this function does not include the variables that are outputs from another scale and not computed by this scale, see mapped_variables_with_outputs_as_inputs for that.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.model_-Tuple{AbstractModel}","page":"Internal API","title":"PlantSimEngine.model_","text":"model_(m::AbstractModel)\n\nGet the model of an AbstractModel (it is the model itself if it is not a MultiScaleModel).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel for different objects, or false otherwise. \n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over objects, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model T or the whole dependency graph is parallelizable, i.e. if the model can be computed in parallel for different time-steps or objects. The default implementation returns false for all models.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is parallelizable:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable:\n\nparallelizable(MyModel()) # true\n\nOr if we want to be more explicit:\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.ref_var-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.ref_var","text":"ref_var(v)\n\nCreate a reference to a variable. If the variable is already a Base.RefValue, it is returned as is, else it is returned as a Ref to the copy of the value, or a Ref to the RefVector (in case v is a RefVector).\n\nExamples\n\njulia> using PlantSimEngine;\n\njulia> PlantSimEngine.ref_var(1.0)\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var([1.0])\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(Base.RefValue(1.0))\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var(Base.RefValue([1.0]))\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))\nBase.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Internal API","title":"PlantSimEngine.reverse_mapping","text":"reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)\nreverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nGet the reverse mapping of a dictionary of model mapping, i.e. the variables that are mapped to other scales, or in other words, what variables are given to other scales from a given scale. This is used for e.g. knowing which scales are needed to add values to others.\n\nArguments\n\nmapping::Dict{String,Any}: A dictionary of model mapping.\nall::Bool: Whether to get all the variables that are mapped to other scales, including the ones that are mapped as single values.\n\nReturns\n\nA dictionary of organs (keys) with a dictionary of organs => vector of pair of variables. You can read the output as: \"for each organ (source organ), to which other organ (target organ) it is giving values for its own variables. Then for each of these source organs, which variable it is giving to the target organ (first symbol in the pair), and to which variable it is mapping the value into the target organ (second symbol in the pair)\".\n\nExamples\n\njulia> using PlantSimEngine\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\njulia> mapping = Dict( \"Plant\" => MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \"Internode\" => ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nNotice we provide \"Soil\", not [\"Soil\"] in the mapping of the ToyAssimModel for the Leaf. This is because we expect a single value for the soil_water_content to be mapped here (there is only one soil). This allows  to get the value as a singleton instead of a vector of values.\n\njulia> PlantSimEngine.reverse_mapping(mapping)\nDict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:\n  \"Soil\"      => Dict(\"Leaf\"=>Dict(:soil_water_content=>:soil_water_content))\n  \"Internode\" => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n  \"Leaf\"      => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"Internal API","title":"PlantSimEngine.save_results!","text":"save_results!(object::GraphSimulation, i)\n\nSave the results of the simulation for time-step i into the  object. For a GraphSimulation object, this will save the results from the status(object) in the outputs(object).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_multiscale_output","text":"search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies at other scales.\norgan::String: the organ for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => [:subprocess => (:var1, :var2)].\nsoft_dep_graphs::Dict{String, ...}: a dict of organ => (softdepgraph, inputs, outputs).\nrev_mapping::Dict{Symbol, Symbol}: a dict of mapped variable => source variable (this is the reverse mapping).\n'harddependenciesfromotherscale' : a vector of HardDependencyNode to provide access to the hard dependencies without traversing the whole graph\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies variables found in outputs of other scales for each process, e.g.:\n\nDict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:\n    \"Internode\" => Dict(:carbon_demand=>[:carbon_demand])\n    \"Leaf\"      => Dict(:carbon_assimilation=>[:carbon_assimilation], :carbon_demand=>[:carbon_demand])\n\nThis means that the variable :carbon_demand is computed by the process :carbon_demand at the scale \"Internode\", and the variable :carbon_assimilation  is computed by the process :carbon_assimilation at the scale \"Leaf\". Those variables are used as inputs for the process that we just passed.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.set_variables_at_timestep!-Tuple{Status, Status, Any, Any}","page":"Internal API","title":"PlantSimEngine.set_variables_at_timestep!","text":"set_variables_at_timestep!(status_timestep::Status, user_status::Status, variables_to_update, timestep)\n\nUpdate status_timestep to the current values at the timestep for all variables_to_update in the status provided by the user (user_status). The variables to update are given in variables_to_update, which is a vector of symbols.\n\nstatus_timestep is a status representing a single time-step. user_status is the status provided that gives values for variables that are not computed by any model. It may give constant values or vectors of values, in which case the timestep is used to select the value to use for the current time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.soft_dependencies","page":"Internal API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}","page":"Internal API","title":"PlantSimEngine.status_from_template","text":"status_from_template(d::Dict{Symbol,Any})\n\nCreate a status from a template dictionary of variables and values. If the values  are already RefValues or RefVectors, they are used as is, else they are converted to Refs.\n\nArguments\n\nd::Dict{Symbol,Any}: A dictionary of variables and values.\n\nReturns\n\nA Status.\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> a, b = PlantSimEngine.status_from_template(Dict(:a => 1.0, :b => 2.0));\n\njulia> a\n1.0\n\njulia> b\n2.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel over time-steps, or false otherwise.\n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over time-steps, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\nobject_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over objects:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!","text":"transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)\n\nFind variables that are inputs to other scales as a SingleNodeMapping and declare them as MappedVar from themselves in the source scale. This helps us declare it as a reference when we create the template status objects.\n\nThese node are found in the mapping as [:variable_name => \"Plant\"] (notice that \"Plant\" is a scalar value).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)\ntraverse_dependency_graph(graph; visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node, or just return the nodes if f is not provided.\n\nThe first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then  the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nfunction f(node)\n    node.value\nend\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_multiscale","page":"Internal API","title":"PlantSimEngine.variables_multiscale","text":"variables_multiscale(node, organ, mapping, st=NamedTuple())\n\nGet the variables of a HardDependencyNode, taking into account the multiscale mapping, i.e. defining variables as MappedVar if they are mapped to another scale. The default values are  taken from the model if not given by the user (st), and are marked as UninitializedVar if  they are inputs of the node.\n\nReturn a NamedTuple with the variables and their default values.\n\nArguments\n\nnode::HardDependencyNode: the node to get the variables from.\norgan::String: the organ type, e.g. \"Leaf\".\nvars_mapping::Dict{String,T}: the mapping of the models (see details below).\nst::NamedTuple: an optional named tuple with default values for the variables.\n\nDetails\n\nThe vars_mapping is a dictionary with the organ type as key and a dictionary as value. It is  computed from the user mapping like so:\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.variables_outputs_from_other_scale","text":"variables_outputs_from_other_scale(mapped_vars)\n\nFor each organ in the mapped_vars, find the variables that are outputs from another scale and not computed at this scale otherwise. This function is used with mapped_variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"Internal API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"Internal API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"introduction/why_plantsimengine/#Why-PlantSimEngine?","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine?","text":"PlantSimEngine was developed to address fundamental limitations in existing plant modeling tools. This framework emerged from the need for a system that could efficiently handle the complex dynamics of the soil-plant-atmosphere continuum while remaining accessible to researchers and practitioners from diverse disciplines.","category":"section"},{"location":"introduction/why_plantsimengine/#The-Current-Landscape-of-Plant-Modeling","page":"Why PlantSimEngine ?","title":"The Current Landscape of Plant Modeling","text":"Plant modeling has evolved significantly over the years, with different tools making different design tradeoffs to address specific research needs. These tools generally fall into three categories, each with their own strengths and limitations:","category":"section"},{"location":"introduction/why_plantsimengine/#Monolithic-Systems","page":"Why PlantSimEngine ?","title":"Monolithic Systems","text":"Systems like APSIM[1], GroIMP[2], AMAPStudio[3], Helios[4], and CPlantBox[5] offer comprehensive functionality but present certain tradeoffs:\n\nThese systems provide robust, well-tested frameworks with established scientific validity, but their large, complex codebases can be challenging to navigate and modify without extensive programming expertise.\n\nTheir comprehensive architecture offers a wealth of integrated features but may require adaptation when implementing novel approaches that don't align with their predefined frameworks.\n\nThey excel at specific types of simulations but may require additional engineering effort for seamless multi-scale simulations and model coupling across the soil-plant-atmosphere continuum.\n\nThese platforms typically require dedicated engineering resources for maintenance and extension, with research teams often needing specialized technical staff to implement new models.","category":"section"},{"location":"introduction/why_plantsimengine/#Distributed-Systems","page":"Why PlantSimEngine ?","title":"Distributed Systems","text":"Platforms like OpenAlea[6] and Crops in Silico[7] offer different advantages and tradeoffs:\n\nThese systems provide accessible interfaces (often in Python) that prioritize ease of use and flexibility, making them approachable for many researchers, though they may require performance optimization for large-scale simulations.\n\nTheir modular nature facilitates component reuse and integration, while sometimes requiring proficiency in multiple programming languages for extending computational backends.\n\nThey support diverse modeling paradigms but may involve a longer iteration cycle between design, implementation, and performance tuning compared to more specialized tools.\n\nWhile offering flexibility, implementing complex models often requires significant developer time, especially when optimizing performance using lower-level languages.","category":"section"},{"location":"introduction/why_plantsimengine/#Architecture-Focused-Tools","page":"Why PlantSimEngine ?","title":"Architecture-Focused Tools","text":"Tools like AMAPSim[8] make specific design choices that benefit certain applications:\n\nThese systems excel in their focused domains (such as structural modeling of plants) while requiring integration with other tools for comprehensive studies of plant physiology and environmental responses.\n\nTheir implementation in languages like C++ or Java delivers excellent performance but represents a tradeoff in terms of accessibility for researchers without expertise in these languages.\n\nThey provide sophisticated functionality in their target domains but may require additional work for rapid hypothesis testing and model prototyping across diverse aspects of plant science.","category":"section"},{"location":"introduction/why_plantsimengine/#The-PlantSimEngine-Solution","page":"Why PlantSimEngine ?","title":"The PlantSimEngine Solution","text":"PlantSimEngine brings together innovative ideas to address these various tradeoffs, offering a unique combination of features:","category":"section"},{"location":"introduction/why_plantsimengine/#Automatic-Model-Coupling","page":"Why PlantSimEngine ?","title":"Automatic Model Coupling","text":"Seamless Integration: PlantSimEngine leverages Julia's multiple-dispatch capabilities to automatically compute the dependency graph between models. This allows researchers to effortlessly couple models without writing complex connection code or manually managing dependencies.\n\nIntuitive Multi-Scale Support: The framework naturally handles models operating at different scales—from organelle to ecosystem—connecting them with minimal effort and maintaining consistency across scales.","category":"section"},{"location":"introduction/why_plantsimengine/#Flexibility-with-Precision-Control","page":"Why PlantSimEngine ?","title":"Flexibility with Precision Control","text":"Effortless Model Switching: Researchers can switch between different component models using a simple syntax without rewriting the underlying model code. This enables rapid comparison between different hypotheses and model versions, accelerating the scientific discovery process.\n\nFine-Grained Model Control: PlantSimEngine allows users to fix parameters, force variables to match observed values, or select simpler models for specific processes. This flexibility helps reduce overall system complexity while maintaining precision where it matters most.\n\nAdaptive Scalability: The same framework efficiently supports both simple prototypes for single-plant studies and complex ecosystem simulations, scaling computational resources appropriately to the problem at hand.","category":"section"},{"location":"introduction/why_plantsimengine/#Outstanding-Performance","page":"Why PlantSimEngine ?","title":"Outstanding Performance","text":"High-Speed Computation: Benchmarks demonstrate operations completing in hundreds of nanoseconds, making PlantSimEngine suitable for computationally intensive applications. For example, the PlantBiophysics.jl implementation is over 38,000 times faster than equivalent implementations in R.\n\nComputational Efficiency: Julia's just-ahead-of-time compilation and native support for parallelism ensure that optimizations made during prototyping directly transfer to larger-scale applications, eliminating the need for reimplementation in a different language for performance gains.","category":"section"},{"location":"introduction/why_plantsimengine/#Developer-Efficiency","page":"Why PlantSimEngine ?","title":"Developer Efficiency","text":"Reduced Implementation Time: PlantSimEngine leverages Julia's dynamic language features while maintaining the performance of statically-compiled languages. This significantly reduces the time researchers spend implementing and optimizing models.\n\nModular Building Blocks: The component-based architecture allows models to be built as unit components that can be stacked like building blocks to create complex systems. This modularity dramatically increases code reuse and reduces redundant implementation efforts.\n\nNo Engineering Overhead: Unlike monolithic systems that require dedicated engineering teams or distributed platforms that need backend optimization, PlantSimEngine enables domain scientists to independently develop high-performance models without specialized programming expertise.\n\nRapid Prototyping to Production: The same code used for quick prototyping can transition directly to production-scale simulations without rewriting, eliminating the traditional gap between exploratory research and application.","category":"section"},{"location":"introduction/why_plantsimengine/#Key-Innovations","page":"Why PlantSimEngine ?","title":"Key Innovations","text":"PlantSimEngine's approach to plant modeling represents a paradigm shift in how scientists can build and use models:\n\nUniform API: Standardized interfaces make it easy to define new processes and component models, reducing the cognitive load on researchers.\nAutomatic Dependency Resolution: The system automatically determines the relationships between different models and processes, eliminating the need for manual coupling.\nSeamless Parallelization: Out-of-the-box support for parallel and distributed computation allows researchers to focus on the science rather than implementation details.\nFlexible Model Integration: The ability to easily combine models from different sources and at different scales facilitates more comprehensive and realistic simulations.\nUser-Centric Design: Emphasizing usability ensures that researchers with varied programming backgrounds can effectively engage with the system.\n\nBy offering solutions to the various tradeoffs present in existing modeling approaches, PlantSimEngine enables researchers to focus more on scientific questions and less on technical implementation details, accelerating the pace of discovery in plant science, agronomy, and related fields.\n\n[1]: Holzworth, D. P. et al. APSIM – Evolution towards a new generation of agricultural systems simulation. Environmental Modelling & Software 62, 327-350 (2014).\n\n[2]: Hemmerling, R., Kniemeyer, O., Lanwert, D., Kurth, W. & Buck-Sorlin, G. The rule-based language XL and the modelling environment GroIMP illustrated with simulated tree competition. Funct. Plant Biol. 35, 739 (2008).\n\n[3]: Griffon, S., and de Coligny, F. AMAPstudio: An editing and simulation software suite for plants architecture modelling. Ecological Modelling 290 (2014): 3‑10. https://doi.org/10.1016/j.ecolmodel.2013.10.037.\n\n[4]: Bailey, R. Spatial Modeling Environment for Enhancing Conifer Crown Management. Front. For. Glob. Change 3, 106 (2020).\n\n[5]: Schnepf, A., Leitner, D., Landl, M., Lobet, G., Mai, T. H., Morandage, S., Sheng, C., Zörner, M., Vanderborght, J., & Vereecken, H. CPlantBox: A whole-plant modelling framework for the simulation of water- and carbon-related processes. in silico Plants, 63 (2018).\n\n[6]: Pradal, C. et al. OpenAlea: A visual programming and component-based software platform for plant modeling. Funct. Plant Biol. 35, 751-760 (2008).\n\n[7]: Marshall-Colon, A. et al. Crops In Silico: Generating Virtual Crops Using an Integrative and Multi-Scale Modeling Platform. Frontiers in Plant Science 8 (2017). https://doi.org/10.3389/fpls.2017.00786.\n\n[8]: Barczi, J.-F., Rey, H., Caraglio, Y., Reffye, P. de, Barthélémy, D., Dong, Q. X., & Fourcaud, T. AmapSim: A Structural Whole-plant Simulator Based on Botanical Knowledge and Designed to Host External Functional Models. Annals of botany, 101(8), 1125-1138 (2008).","category":"section"},{"location":"multiscale/multiscale_example_3/#Fixing-bugs-in-the-plant-simulation","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"There are two major issues hinted at in last chapter's implementation, which we'll discuss and resolve here.\n\nYou can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.\n\nPages = [\"multiscale_example_3.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_3/#An-organ-creation-problem","page":"Fixing bugs in the plant simulation","title":"An organ creation problem","text":"There is one quirk you may have noticed when inspecting the data : when a root expands, the new root is immediately active, and some models may act on it immediately... including the root growth model. Meaning this new root may also sprout another root in the same timestep, and so on.\n\nYou can notice this by looking at the simulation's state during the first two timesteps:\n\nouts = run!(mtg, mapping, first(meteo_day, 2))\n\nroot_nodes_per_timestep = [0, 0]\nfor i in 1:length(outs[\"Root\"])\n    if outs[\"Root\"][i].timestep < 3\n        root_nodes_per_timestep[outs[\"Root\"][i].timestep] += 1    \n    end\nend\n\nroot_nodes_per_timestep\n\nOur root grew to full length within one timestep. Oops.\n\nThis is an implementation decision in PlantSimEngine. By default, newly created organs are active, and models can affect them as soon as they are created.\n\nIn our case, internode growth depends on a threshold thermal time value, which accumulates over several timesteps, so even though new internodes are immediately active, they can't themselves grow new organs within the same timestep. But as we've just showcased, we have a root problem.\n\nThis quirk is also handled in XPalm.jl, a package using PlantSimEngine: some organs make use of state machines, and are considered \"immature\" when they are created. Immature organs cannot grow new organs until some conditions are met for their state to change. There are also other conditions governing organ emergence, such as specific threshold values relating to Thermal Time (see here for an example).\n\nnote: Note\nThis implementation decision for new organs to be immediately active may be subject to change in future versions of PlantSimEngine. Also note that the way the dependency graph is structured determines the order in which models run. Meaning that which models are run before or after organ creation might change with new additions and updates to your mapping. Some models might run \"one timestep later\", see Simulation order instability when adding models for more details.\n\nnote: Note\nMTG node output data has a couple of subtleties, see Multi-scale output data structure for more details","category":"section"},{"location":"multiscale/multiscale_example_3/#Delaying-organ-maturity","page":"Fixing bugs in the plant simulation","title":"Delaying organ maturity","text":"How do we avoid this extreme instant growth ? We can, of course, add some thermal time constraint. We could arbitrarily tinker with water resources. \n\nWe can otherwise add a simple state machine variable to our root and internodes in the MTG, indicating a newly added organ is immature and cannot grow on the same timestep. Since our root doesn't branch, we can simply keep track of a single state variable. See the State machines section for some examples.\n\nIn fact, we could change the scale at which the check is made to extend the root, and have another model call this one directly. This enables running this model only for the end root when those occasional timesteps when root growth is possible, instead of at every timestep for every root node.","category":"section"},{"location":"multiscale/multiscale_example_3/#A-resource-distribution-bug","page":"Fixing bugs in the plant simulation","title":"A resource distribution bug","text":"Another problem you may have noticed, is that the water and carbon stock are computed by aggregating photosynthesis over leaves and absorption over roots... But they aren't always properly decremented when consumed !\n\nIf the end root grows, it outputs a carbon_root_creation_consumed value, but under certain conditions, we might also create other roots and internodes even when there shouldn't be enough carbon left for them. \n\nIndeed, if both the root and leaf water thresholds are met, and there is enough carbon for a single root or internode but not for both, and the root model runs before the internode model, both will use the carbon_stock variable prior to organ emission. The internode emission model won't account for the root carbon consumption.\n\nThis occurs because carbon_stock is only computed once, and won't update until the next timestep.","category":"section"},{"location":"multiscale/multiscale_example_3/#Fixing-resource-computation:-a-root-growth-decision-model","page":"Fixing bugs in the plant simulation","title":"Fixing resource computation: a root growth decision model","text":"To avoid that problem in our specific case, we can couple the root growth model and the internode emission model, and pass the carbon_root_creation_consumed variable to the internode emission model so that it can use an updated carbon stock. Or we could have an intermediate model recompute the new stock to pass along to the internode emission model. \n\nThere is a section in the [Tips and workarounds] page discussing this situation and other potential solutions: Having a variable simultaneously as input and output of a model.\n\nWe'll go for the first option and couple the root growth and internode emission model.","category":"section"},{"location":"multiscale/multiscale_example_3/#Internode-emission-adjustments","page":"Fixing bugs in the plant simulation","title":"Internode emission adjustments","text":"The only change required for our internode emission model is to take into account carbon_root_creation_consumed as a new input, map that variable from the \"Root\" scale in our mapping, and compute the adjusted carbon stock. Here's the relevant excerpt in the run! function.\n\n # take into account that the stock may already be depleted \n    carbon_stock_updated_after_roots = status.carbon_stock - status.carbon_root_creation_consumed\n\n    # if not enough carbon, no organ creation\n    if carbon_stock_updated_after_roots < m.carbon_internode_creation_cost\n        return nothing\n    end","category":"section"},{"location":"multiscale/multiscale_example_3/#A-multi-scale-hard-dependency-appears","page":"Fixing bugs in the plant simulation","title":"A multi-scale hard dependency appears","text":"Our root growth decision model inherits some of the responsibility from last chapter's root growth model, so inputs, parameters and condition checks will be similar. We'll let the root growth model keep the length check and only focus on resources.\n\nSince the decision model is now directly responsible for calling the actual root growth model, we need to declare that it requires a root growth model as a hard dependency and cannot be run standalone. \n\nThis hard dependency is in fact multiscale, since both models operate at different scales, \"Plant\" and \"Root\". You can read more about multi-scale hard dependencies in the Handling dependencies in a multiscale context page.\n\nCompared to the single-scale equivalent, the multi-scale declaration additionally requires mapping the scale:\n\nPlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)\n\nThe status argument run! function of the root growth decision model only contains variables from the \"Plant\" scale, or explicitely mapped to this scale, which isn't the case for the root growth's variables. To make use of the root growth model's variables, we need to recover the status at the \"Root\" scale. It is accessible from the extra argument in run!'s signature. \n\nIn multi-scale simulations, this extra argument implicitely contains an object storing the simulation state. It contains the statuses at various scales, and all the models indexed per scale and process name.\n\nAccess to the \"Root\" status within the root growth decision model run! function is done like so:\n\nstatus_Root= extra_args.statuses[\"Root\"][1]\n\nIt is then possible to call the root growth model from the parent's run! function:\n\nPlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)\n\nWhich will enable writing the rest of the run! function.","category":"section"},{"location":"multiscale/multiscale_example_3/#Root-growth-decision-model-implementation","page":"Fixing bugs in the plant simulation","title":"Root growth decision model implementation","text":"With that new coupling consideration properly handled, we can complete the full model implementation:\n\nPlantSimEngine.@process \"root_growth_decision\" verbose = false\n\nstruct ToyRootGrowthDecisionModel{T} <: AbstractRoot_Growth_DecisionModel\n    water_threshold::T\n    carbon_root_creation_cost::T\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthDecisionModel) = \n(water_stock=0.0,carbon_stock=0.0)\n\nPlantSimEngine.outputs_(::ToyRootGrowthDecisionModel) = NamedTuple()\n\nPlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)\n\n# \"status\" is at the \"Plant\" scale\nfunction PlantSimEngine.run!(m::ToyRootGrowthDecisionModel, models, status, meteo, constants=nothing, extra=nothing)\n\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        # Obtain \"status\" at \"Root\" scale\n        status_Root= extra_args.statuses[\"Root\"][1]\n        # Call the hard dependency model directly with its status\n        PlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)\n    end\nend\n\nThe root growth model will output the carbon_root_creation_consumed computation, but it'll still be exposed to downstream models despite the root growth model being a 'hidden' model in the dependency graph due to its hard dependency nature.\n\nWith this new coupling, we will only be creating at most a single new root per timestep, as the root growth decision will only be called once per timestep. ","category":"section"},{"location":"multiscale/multiscale_example_3/#Root-growth","page":"Fixing bugs in the plant simulation","title":"Root growth","text":"This iteration turns into a simplifed version of last chapter's.\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel <: AbstractRoot_GrowthModel\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = NamedTuple()\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)    \n    status.carbon_root_creation_consumed = 0.0\n\n    root_end = get_root_end_node(status.node)\n        \n    if length(root_end) != 1 \n        throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n    end\n    \n    root_len = get_roots_count(root_end[1])\n    if root_len < m.root_max_len\n        st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n        status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n    end\nend","category":"section"},{"location":"multiscale/multiscale_example_3/#Mapping-adjustments","page":"Fixing bugs in the plant simulation","title":"Mapping adjustments","text":"The new mapping only has straightforward changes. Some models cease to be multi-scale, others require new variables to be mapped for them. carbon_root_creation_consumed ceases to be a vector mapping and is a scalar variable.\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>\"Root\",\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n    MultiScaleModel(\n        model=ToyRootGrowthDecisionModel(10.0, 50.0),\n    ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            :water_stock=>\"Plant\",\n            :carbon_stock=>\"Plant\", \n            :carbon_root_creation_consumed=>\"Root\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" =>   (ToyRootGrowthModel(10),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)\n\nWe can now run our simulation as we did previously... or can we ?\n\nERROR: Cyclic dependency detected for process resource_stock_computation: resource_stock_computation for organ Plant depends on root_growth from organ Root, which depends on the first one. This is not allowed, you may need to develop a new process that does the whole computation by itself.\n\nAh, it looks like our additional usage of the root carbon cost creates a cyclic dependency. ","category":"section"},{"location":"multiscale/multiscale_example_3/#Breaking-the-dependency-cycle","page":"Fixing bugs in the plant simulation","title":"Breaking the dependency cycle","text":"Fortunately, the logic here is quite straightforward. We can't be computing our current timestep's resource stock with carbon_root_creation_consumed, and then updating it right after root creation again using a new value of carbon_root_creation_consumed.\n\nThe solution is hopefully quite intuitive : when we compute resource stocks, we should be computing it using the previous timestep's values. Then root creation happens (or doesn't), and the computed carbon_root_creation_consumed corresponds to the current timestep value. We could also do the same for water to be consistent.","category":"section"},{"location":"multiscale/multiscale_example_3/#Updated-mapping","page":"Fixing bugs in the plant simulation","title":"Updated mapping","text":"The relevant part of the mapping that needs to be updated is the following:\n\nmapping = Dict(\n...\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            PreviousTimeStep(:carbon_root_creation_consumed)=>\"Root\",\n            PreviousTimeStep(:carbon_organ_creation_consumed)=>[\"Internode\"],\n        ],\n        ),\n        ToyRootGrowthDecisionModel(10.0, 50.0),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n...\n)","category":"section"},{"location":"multiscale/multiscale_example_3/#Final-words","page":"Fixing bugs in the plant simulation","title":"Final words","text":"And you're now ready to run the simulation.\n\nThe full script can be found here, in the ToyMultiScalePlantModel subfolder of the examples folder.\n\nWe now have a plant with two different growth directions. Roots are added at the beginning, until water is considered abundant enough.\n\nOf course, there are still several design issues with this implementation. It is as utterly unrealistic as the previous one, and doesn't even consume water. Some condition checking is a little ad hoc and could be made more robust. More sanity checks could be added, and the model and variable names could definitely be made more clear.\n\nBut once again, this example is only made to illustrate what is possible with this framework, and doesn't strive for ecophysiological consistency. And the approach can be made increasingly more complex by refining models and simulation parameters, and feeding in new information about your plant, and ramp up to realistic, production-ready and predictive simulations.","category":"section"},{"location":"multiscale/multiscale_example_1/#Writing-a-multiscale-simulation","page":"A rudimentary plant simulation","title":"Writing a multiscale simulation","text":"This three-part subsection walks you through building a multi-scale simulation from scratch. It is meant as an illustration of the iterative process you might go through when building and slowly tuning a Functional-Structural Plant Model, where previous multi-scale examples focused more on the API syntax.\n\nYou can find the full script for the first part's toy simulation in the ToyMultiScalePlantModel subfolder of the examples folder.\n\nPages = [\"multiscale_example_1.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_1/#Disclaimer","page":"A rudimentary plant simulation","title":"Disclaimer","text":"The actual plant being created, as well as some of the custom models, have no real physical meaning and are very much ad hoc (which is why most of them aren't standalone in the examples folder). Similarly, some of the parameter values are pulled out of thin air, and have no ties to research papers or data.\n\nThe main purpose here is to showcase PlantSimEngine's multi-scale features and how to structure your models, not accuracy, realism or performance.","category":"section"},{"location":"multiscale/multiscale_example_1/#Initial-setup","page":"A rudimentary plant simulation","title":"Initial setup","text":"We'll need to make use of a few packages, as usual, after adding them to our Julia environment:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples # to import the ToyDegreeDaysCumulModel model\nusing PlantMeteo\nusing MultiScaleTreeGraph # multi-scale\nusing CSV, DataFrames # used to import the example weather data","category":"section"},{"location":"multiscale/multiscale_example_1/#A-basic-growing-plant","page":"A rudimentary plant simulation","title":"A basic growing plant","text":"At minimum, to simulate some kind of fake growth, we need :\n\nA Multi-scale Tree Graph representing the plant\nSome way of adding organs to the plant\nSome kind of temporality to spread this growth over multiple timesteps\n\nLet's have some concept of 'leaves' that capture the (carbon) resource necessary for organ growth, and let's have the organ emergence happen at the 'internode' level, to illustrate multiple organs with different behavior.\n\nWe'll make the assumption that the internodes make use of carbon from a common pool. We'll also make use of thermal time as a growth delay factor.\n\nTo sum up, we have: \n\na MTG with growing internodes and leaves\nIndividual leaves that capture carbon fed into a common pool\nInternodes which take from that pool to create new organs, with a thermal time constraint.\n\nOne way of modeling this approach translates into several scales and models: \n\na Scene scale, for thermal time. The ToyDegreeDaysCumulModel from the examples folder provides thermal time from temperature data \na Plant scale, where we'll define the carbon pool\nan Internode scale, which draws from the pool to create new organs\na Leaf scale, which captures carbon\n\nLet's also add a very artificial limiting factor: if the total leaf surface area is above a threshold no new organs are created.\n\nWe can expect the simulation mapping to look like a more complex version of the following: \n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => ToyStockComputationModel(),\n\"Internode\" => ToyCustomInternodeEmergence(),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)\n\nSome of the models will need to gather variables from scales other than their own, meaning they will need to be converted into MultiScaleModels.","category":"section"},{"location":"multiscale/multiscale_example_1/#Implementation","page":"A rudimentary plant simulation","title":"Implementation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/#Carbon-Capture","page":"A rudimentary plant simulation","title":"Carbon Capture","text":"Let's start with the simplest model. Our fake leaves will continuously capture some constant amount of carbon every timestep. No inputs or parameters are required.\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # No inputs\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend","category":"section"},{"location":"multiscale/multiscale_example_1/#Resource-storage","page":"A rudimentary plant simulation","title":"Resource storage","text":"The model storing resources for the whole plant needs a couple of inputs: the amount of carbon captured by the leaves, as well as the amount consumed by the creation of new organs. It outputs the current stock.\n\nPlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(carbon_captured=0.0,carbon_organ_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (carbon_stock=-Inf,)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed)\nend","category":"section"},{"location":"multiscale/multiscale_example_1/#Organ-creation","page":"A rudimentary plant simulation","title":"Organ creation","text":"This model is a modified version of the ToyInternodeEmergence model found in the examples folder. An internode produces two leaves and a new internode.\n\nLet's first define a helper function that iterates across a Multiscale Tree Graph and returns the number of leaves :\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend\n\nNow that we have that, let's define a few parameters to the model. It requires :\n\na thermal time emergence threshold\na carbon cost for organ creation\n\nWe'll also add a couple of other parameters, which could go elsewhere :\n\nthe surface area of a leaf (no variation, no growth stages)\nthe max leaf surface area beyond which organ creation stops\n\nPlantSimEngine.@process \"organ_emergence\" verbose = false\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\nend\n\nnote: Note\nWe make use of parametric types instead of the intuitive Float64 for flexibility. See Parametric types for a more in-depth explanation\n\nAnd give them some default values : \n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0, leaves_max_surface_area=100.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area)\n\nOur internode model requires thermal time, and the amount of available carbon, and outputs the amount of carbon consumed, as well as the last thermal time where emergence happened (this is useful when new organs can be produced multiple times, which won't be the case here).\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nFinally, the run! function checks that conditions are met for new organ creation :\n\nthermal time threshold exceeded\ntotal leaf surface area not above limit\ncarbon available\nno organs already created by that internode\n\nand then updates the MTG.\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"section"},{"location":"multiscale/multiscale_example_1/#Updated-mapping","page":"A rudimentary plant simulation","title":"Updated mapping","text":"We can now define the final mapping for this simulation. \n\nThe carbon capture and thermal time models don't need to be changed from the earlier version.  The organ creation model at the \"Internode\" scale needs the carbon stock from the \"Plant\" scale, as well as thermal time from the \"Scene\" scale. The resource storing model at the \"Plant\" scale needs the carbon captured by every leaf, and the carbon consumed by every internode that created new organs this timestep. This requires mapping vector variables :\n\n mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],\n\nas opposed to the single-valued carbon stock mapped variable : \n\n mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n\nAnd of course, some variables need to be initialized in the status:\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],\n        ),\n        Status(carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)\n\nnote: Note\nThis excerpt (and the complete script file) showcase the final properly initialized mapping, but when developing, you are encouraged to make liberal use of the helper function to_initialize and check the PlantSimEngine user errors.","category":"section"},{"location":"multiscale/multiscale_example_1/#Running-a-simulation","page":"A rudimentary plant simulation","title":"Running a simulation","text":"We only need an MTG, and some weather data, and then we'll be set. Let's create a simple MTG : \n\n mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\nImport some weather data : \n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide\n\nAnd we're good to go ! \n\nouts = run!(mtg, mapping, meteo_day)\n\nIf you query or display the MTG after simulation, you'll see it expanded and grew multiple internodes and leaves :\n\nmtg\n#get_n_leaves(mtg)\n\nAnd that's it ! Feel free to tinker with the parameters and see when things break down, to get a feel for the simulation.\n\nOf course, this is a very crude and unrealistic simulation, with many dubious assumptions and parameters. But significantly more complex modelling is possible using the same approach : XPalm runs using a few dozen models spread out over nine scales.\n\nThis is a three-part tutorial and continues in the Expanding on the multiscale simulation page.","category":"section"},{"location":"prerequisites/key_concepts/#Key-Concepts","page":"Key Concepts","title":"Key Concepts","text":"You'll find a brief description of some of the main concepts and terminology related to and used in PlantSimEngine.\n\nPages = [\"key_concepts.md\"]\nDepth = 4","category":"section"},{"location":"prerequisites/key_concepts/#Crop-models","page":"Key Concepts","title":"Crop models","text":"","category":"section"},{"location":"prerequisites/key_concepts/#FSPM","page":"Key Concepts","title":"FSPM","text":"","category":"section"},{"location":"prerequisites/key_concepts/#PlantSimEngine-terminology","page":"Key Concepts","title":"PlantSimEngine terminology","text":"This page provides a general description of the concepts and terminology used in PlantSimEngine. For a more implementation-guided description of the design and some of the terms presented here, see the Detailed walkthrough of a simple simulation\n\n!!! Note     Some terminology has different meanings in different contexts. This is particularly true of the terms organ, scale and symbol, which have a different meaning for Multi-scale Tree Graphs than the rest of PlantSimEngine (see Scale/symbol terminology ambiguity further down). Make sure to double-check those subsections, and relevant examples if you encounter issues relating to these terms.","category":"section"},{"location":"prerequisites/key_concepts/#Processes","page":"Key Concepts","title":"Processes","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.\n\nSee Implementing a new process for a brief explanation on how to declare a new process.","category":"section"},{"location":"prerequisites/key_concepts/#Models","page":"Key Concepts","title":"Models","text":"A model is a particular implementation for the simulation of a process.\n\nThere may be different models that can be used for the same process; for instance, there are multiple hypotheses and ways of modeling photosynthesis, with different granularity and accuracy. A simple photosynthesis model might apply a simple formula and apply it to the total leaf surface, a more complex one might calculate interception and light extinction.\n\nnote: Note\nThe companion package PlantBiophysics.jl provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example script in this package too at examples/Beer.jl.\n\nModels can also be used for ad hoc computations that aren't directly tied to a specific literature-defined physiological process. In PlantSimEngine, everything is a model. There are many instances where a custom model might be practical to aggregate some computations or handle other information. To illustrate, XPalm, the Oil Palm model, has a few models that handle the state of different organs, and a model to handle leaf pruning, which you can find here.\n\nTo prepare a simulation, you declare a ModelList with whatever models you wish to make use of and initialize necessary parameters: see the step by step section to learn how to use them in practice.\n\nFor multi-scale simulations, models need to be tied to a particular scale when used. See the Multiscale modeling section below, or the Multi-scale considerations page for a more detailed description of multi-scale peculiarities.","category":"section"},{"location":"prerequisites/key_concepts/#Variables,-inputs,-outputs,-and-model-coupling","page":"Key Concepts","title":"Variables, inputs, outputs, and model coupling","text":"A model used in a simulation requires some input data and parameters, and will compute some other data which may be used by other models. Depending on what models are combined in a simulation, some variables may be inputs of some models, outputs of other models, only be part of intermediary computations, or be a user input to the whole simulation.\n\nHere's a conceptual model coupling; each \"node\" is equivalent to a distinct PlantSimEngine model, \"compute()\" is equivalent to the model's \"run!\" function:\n\n(Image: Model coupling example) (Source: Autodesk)","category":"section"},{"location":"prerequisites/key_concepts/#Dependency-graphs","page":"Key Concepts","title":"Dependency graphs","text":"Coupling models together in this fashion creates what is known as a Directed Acyclic Graph or DAG, a type of dependency graph. The order in which models are run is determined by the ordering of these models in that graph.\n\n(Image: Example DAG) A simple Directed Acyclic Graph, note the required absence of cycles. Source: Astronomer (Note: \"Not Acyclic\" is simply \"Cyclic\").\n\nPlantSimEngine creates this Directed Acyclic Graph automatically by plugging the right variables in the right models. Users therefore only need to declare models, they do not need to write the code to connect them as PlantSimEngine does that work for them, as long as the model coupling has no cyclic dependency.","category":"section"},{"location":"prerequisites/key_concepts/#hard_dependency_def","page":"Key Concepts","title":"\"Hard\" and \"Soft\" dependencies","text":"Linking models by setting output variables from one model as input of another model handles many typical couplings (with more situations occurring with multi-scale models and variables), but what if two models are interdependent? What if they need to iterate on some computation and pass variables back and forth?\n\nYou can find a typical example in a companion package: PlantBioPhysics.jl. An energy balance model, the Monteith model, needs to iteratively run a photosynthesis model in its run! function. \n\nSee the illustration below of the way these models are interdependent:\n\n(Image: Example of a coupling with cycles)\n\nExample of a coupling with a cycle. Source: PlantBioPhysics.jl\n\nModel couplings that cause simulation to flow both ways break the 'acyclic' assumption of the dependency graph.\n\nPlantSimEngine handles this internally by not having those \"heavily-coupled\" models -called hard dependencies from now on- be part of the main dependency graph. Instead, modelers should call these models manually from within a model. This way, they are made to be children nodes of the parent/ancestor model, which handles them internally, so they aren't tied to other nodes of the dependency graph. The resulting higher-level graph therefore only links models without any two-way interdependencies, and remains a directed graph, enabling a cohesive simulation order. The simpler couplings in that top-level graph are called \"soft dependencies\".\n\n(Image: Hard dependency coupling visualization in PlantSimEngine) The previous coupling, handled by PlantSimEngine\n\nHow PlantSimEngine links these models under the hood. The red models (\"hard dependencies\") are not exposed in the final dependency graph, which only contains the blue \"soft dependencies\", and has no cycles.\n\nThis approach does have implications when developing interdependent models: hard dependencies need to be made explicit, and the ancestor needs to call the hard dependency model's run! function explicitely in its own run! function. Hard dependency models therefore must have only one parent model.\n\nThis reliance on another process makes these models slightly more complex to develop and validate, but keep the versatility of the implementation, as any model implementing the hard-dependency process can be passed by the user.\n\nNote that hard dependencies can also have their own hard dependencies, and some complex couplings can happen.","category":"section"},{"location":"prerequisites/key_concepts/#Weather-data","page":"Key Concepts","title":"Weather data","text":"To run a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.\n\nUsers are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. We will make constant use of it throughout the documentation, and recommend working with it.\n\nThe most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.\n\nThe mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹).\n\nIn the example below, we also pass in the -optional- incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nMore details are available from the package documentation. If you do not wish to make use of this package, you can alternately provide your own data, as long as it respects the Tables.jl interface (e.g. use a DataFrame).\n\nIf you wish to make use of more fine-grained weather data, it will likely require more advanced model creation and MTG manipulation, and more involved work on the modeling side.","category":"section"},{"location":"prerequisites/key_concepts/#Organ/Scale","page":"Key Concepts","title":"Organ/Scale","text":"Plants have different organs with distinct physiological properties and processes. When doing more fine-grained simulations of plant growth, many models will be tied to a particular organ of a plant. Models handling flowering state or root water absorption are such examples. Others, such as carbon allocation and demand, might be reused in slightly different ways for multiple organs of the plant.\n\nPlantSimEngine documentation tends to use the terms \"organ\" and \"scale\" mostly interchangeably. \"Scale\" is a bit more general and accurate, since some models might not operate at a specific organ level, but (for example) at the scene level, so a \"Scene\" scale might be present in the MTG, and in the user-provided data.\n\nWhen working with multi-scale data, the scale will often need to be specified to map variables, or to indicate at what scale level models work out. You will see some code resembling this :\n\n\"Root\" => (RootGrowthModel(), OrganAgeModel()),\n\"Leaf\" => (LightInterceptionModel(), OrganAgeModel()),\n\"Plant\" => (TotalBiomassModel(),),\n\nThis example excerpt links from specific models to a specific scale. Note that one model is reused at two different scales, and note that \"Plant\" isn't an actual organ, hence the preferred usage of the term \"scale\".","category":"section"},{"location":"prerequisites/key_concepts/#Multiscale-modeling","page":"Key Concepts","title":"Multiscale modeling","text":"Multi-scale modeling is the process of simulating a system at multiple levels of detail simultaneously. Some models might run at the organ scale while others run at the plot scale. Each model can access variables at its scale and other scales if needed, allowing for a more comprehensive system representation. It can also help identify emergent properties that are not apparent at a single level of detail.\n\nFor example, a model of photosynthesis at the leaf scale can be combined with a model of carbon allocation at the plant scale to simulate the growth and development of the plant. Another example is a combination of models to simulate the energy balance of a forest. To simulate it, you need a model for each organ type of the plant, another for the soil, and finally, one at the plot scale, integrating all others.\n\nWhen running multi-scale simulations which contain models operating at different organ levels for the plant, extra information needs to be provided by the user to run models. Since some models are reused at different organ levels, it is necessary to indicate which organ level a model operates at.\n\nThis is why multi-scale simulations make use of a 'mapping': the ModelList in the single-scale examples does not have a way to tie models to plant organs, and the more versatile models could be used in various places. The user must also indicate how models operate with other scales, e.g. if an input variable comes from another scale, it is required to indicate which scale it is mapped from.\n\nYou can read more about some practical differences as a user between single- and multi-scale simulations here: Multi-scale considerations.\n\nnote: Note\nWhen you encounter the terms \"Single-scale simulations\", or \"ModelList simulations\", they will refer to simulations that are \"not multi-scale\". A multi-scale simulation makes use of a mapping between different organ/scale levels. A single-scale simulation has no such mapping, and uses the simpler ModelList interface. You can implement a mapping that only makes use of a single scale level, of course, making it a \"single-scale multi-scale simulation\", but unless otherwise specified, single-scale, and the whole section dedicated to single-scale simulations, refer to simulations with ModelList objects, and no mapping.","category":"section"},{"location":"prerequisites/key_concepts/#Multi-scale-Tree-Graphs","page":"Key Concepts","title":"Multi-scale Tree Graphs","text":"(Image: Grassy plant and equivalent MTG)\n\nA Grassy plant and its equivalent MTG\n\nMulti-scale Tree Graphs (MTG) are a data structure used to represent plants. A more detailed introduction to the format and its attributes can be found in the MultiScaleTreeGraph.jl package documentation.\n\nMulti-scale simulations can operate on MTG objects; new nodes are added corresponding to new organs created during the plant's growth.\n\nYou can see a basic display of an MTG by simply typing its name in the REPL:\n\n(Image: example display of an MTG in PlantSimEngine)\n\nnote: Note\nAnother companion package, PlantGeom.jl, can also create MTG objects from .opf files (corresponding to the Open Plant Format, an alternate means of describing plants computationally).","category":"section"},{"location":"prerequisites/key_concepts/#Scale/symbol-terminology-ambiguity","page":"Key Concepts","title":"Scale/symbol terminology ambiguity","text":"Multi-scale tree graphs have different terminology (see Organ/Scale):\n\nthe MTG node symbol represents \"something\" like a \"Plant\", \"Root\", \"Scene\" or \"Leaf\". It corresponds to a PlantSimEngine scale and has nothing to do with the Julia programming language's definition of symbol (e.g. :var)\nthe MTG node scale, is an integer passed to the Node constructor, and describes the level of description of the tree graph object. They don't always have a one-to-one correspondence to the symbol (or PlantSimEngine's scale), but are similar.\n\n(Image: Three scale levels on an MTG, which differ from typical PlantSimEngine concept of scale)\n\nYou can find a brief description of the MTG concepts here.\n\nOther words are unfortunately reused in various contexts with different meanings: tree/leaf/root have a different meaning when talking about computer science data structure (e.g., graphs, dependency graphs and trees).\n\nnote: Note\nIn the majority of cases, you can assume the tree-related terminology refers to the biological terms, and that \"organ\" refer to plant organs, and \"single-scale\", \"multi-scale\" and \"scale\" to PlantSimEngine's concept of scales described in Organ/Scale. MTG objects are mostly manipulated on a per-node basis (the graph node, not the botanical node), unless a model makes use of functions relating to MTG traversal, in which case you may expect computer science terminology.","category":"section"},{"location":"prerequisites/key_concepts/#TLDR","page":"Key Concepts","title":"TLDR","text":"In summary:\n\nIn PlantSimEngine a scale is a level of description defined by a name (String). In MTG, a scale is an integer describing the level of description of the node, and a symbol is a name for that node. So symbol in the MTG == scale in PlantSimEngine;\nThe word \"node\" is always used to refer to the Multiscale Tree Graph node, not the botanical node.","category":"section"},{"location":"prerequisites/key_concepts/#State-machines","page":"Key Concepts","title":"State machines","text":"A state machine is a computational concept used to model mechanisms and devices, which may be of interest for your simulations.\n\n(Image: State machine image) A simple state machine. See the wikipedia page for more examples.\n\nState machines can be useful to model organ state: some organs in XPalm.jl, a package modelling the oil palm using PlantSimEngine, have a state variable behaving like a state machine, indicating whether an organ is mature, pruned, flowering, etc.\n\nYou can find an example model (amongst other such models) affecting the state variable of some organs depending on their age and thermal time in the XPalm oil palm FSPM here.","category":"section"},{"location":"step_by_step/implement_a_process/#Implementing-a-new-process","page":"Implementing a process","title":"Implementing a new process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/#Introduction","page":"Implementing a process","title":"Introduction","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.\n\nPlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. The next section showcases how to implement a new process with a simple example: implementing a growth model.","category":"section"},{"location":"step_by_step/implement_a_process/#Implement-a-process","page":"Implementing a process","title":"Implement a process","text":"A process is \"declared\", meaning we define a process, and then implement models for its simulation. Declaring a process generates some boilerplate code for its simulation: \n\nan abstract type for the process\na method for the process function, that is used internally\n\nThe abstract process type is then used as a supertype of all models implementations for the process, and is named Abstract<process_name>Process, e.g. AbstractLight_InterceptionModel.\n\nFortunately, PlantSimEngine provides a macro to generate all that at once: @process. This macro takes only one argument: the name of the process.\n\nFor example, the photosynthesis process in PlantBiophysics.jl is declared using just this tiny line of code:\n\n@process \"photosynthesis\"\n\nIf we want to simulate the growth of a plant, we could add a new process called growth:\n\n@process \"growth\"\n\nAnd that's it! Note that the function guides you in the steps you can make after creating a process.","category":"section"},{"location":"step_by_step/implement_a_process/#Implement-a-new-model-for-the-process","page":"Implementing a process","title":"Implement a new model for the process","text":"Once process implementation is done, you can write a corresponding model implementation. A tutorial page showcasing a light interception model implementation can be found here\n\nA full model implementation for this process is available in the example script ToyAssimGrowthModel.jl.","category":"section"},{"location":"step_by_step/implement_a_process/#under_the_hood","page":"Implementing a process","title":"Under the hood","text":"The @process macro is just a shorthand reducing boilerplate.\n\nYou can in its stead directly define a process by hand by defining an abstract type that is a subtype of AbstractModel:\n\nabstract type AbstractGrowthModel <: PlantSimEngine.AbstractModel end\n\nAnd by adding a method for the process_ function that returns the name of the process:\n\nPlantSimEngine.process_(::Type{AbstractGrowthModel}) = :growth\n\nSo in the earlier example, a new process was created called growth. This defined a new abstract structure called AbstractGrowthModel, which is used as a supertype of the models. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model.","category":"section"},{"location":"working_with_data/inputs/#Input-types","page":"Input types","title":"Input types","text":"run! usually takes two inputs: a ModelList and data for the meteorology. The data for the meteorology is usually provided for one time step using an Atmosphere, or for several time-steps using a TimeStepTable{Atmosphere}. The ModelList can also be provided as a singleton, or as a vector or dictionary of.\n\nrun! knows how to handle these data formats via the PlantSimEngine.DataFormat trait (see this blog post to learn more about traits). For example, we tell PlantSimEngine that a TimeStepTable should be handled like a table by implementing the following trait:\n\nDataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()\n\nIf you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:\n\nDataFormat(::Type{<:MyTableFormat}) = TableAlike()\n\nThere are two other traits available: SingletonAlike for a data format representing one time-step only, and TreeAlike for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).","category":"section"},{"location":"working_with_data/inputs/#Special-considerations-for-new-input-types","page":"Input types","title":"Special considerations for new input types","text":"If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on your use-cases. \n\nFor example if you use models that need to get data from a different time step (e.g. a model that needs to get the previous day's temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.\n\nTo do so, you need to implement the following methods for your structure that defines your rows:\n\nBase.parent: return the parent table of the row, e.g. the full DataFrame\nPlantMeteo.rownumber: return the row number of the row in the parent table, e.g. the row number in the DataFrame\n(Optionnally) PlantMeteo.row_from_parent(row, i): return row i from the parent table, e.g. the row i from the DataFrame. This is only needed if you want high performance, the default implementation calls Tables.rows(parent(row))[i].\n\ncompat: Compat\nPlantMeteo.rownumber is temporary. It soon will be replaced by DataAPI.rownumber instead, which will be also used by e.g. DataFrames.jl. See this Pull Request.","category":"section"},{"location":"working_with_data/inputs/#Working-with-weather-data","page":"Input types","title":"Working with weather data","text":"Here's a quick example showcasing how to export the example weather data to your own file :\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nPlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)\n\nIf you wish to filter weather data, reshape it, adjust it, write it, you'll find some more examples in PlantMeteo's API reference.  ","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/#Floating-point-considerations","page":"Floating-point considerations","title":"Floating-point considerations","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/#Investigating-a-discrepancy","page":"Floating-point considerations","title":"Investigating a discrepancy","text":"In the Converting a single-scale simulation to multi-scale page, a single-scale simulation was converted to an equivalent multiscale simulation, and outputs were compared. One detail that was glossed over, but important to bear in mind as a PlantSimEngine user is related to floating-point approximations.","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/#Single-scale-simulation","page":"Floating-point considerations","title":"Single-scale simulation","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)\n\n### Multi-scale equivalent \n\nPlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)\n\n### Output comparison\n\n\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\nis_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1\n\nWhy was the comparison only approximate ? Why ≈ instead of ==?\n\nLet's try it out. What if write instead:\n\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\nis_perfectly_equal = length(unique(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)) == 1\n\nWhy is this false? Let's look at the data.\n\nLooking more closely at the output, we can notice that values are identical up to timestep #105 : \n\n(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[104]\n\n(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[105]\n\nWe have the values 132.33333333333331 (multi-scale) and 132.33333333333334 (single-scale). The final output values are : 2193.8166666666643 (multi-scale) and 2193.816666666666 (single-scale).\n\nThe divergence isn't huge, but in other situations or over more timesteps it could start becoming a problem.","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/#Floating-point-summation","page":"Floating-point considerations","title":"Floating-point summation","text":"The reason values aren't identical, is due to the fact that many numbers do not have an exact floating point representation. A classical example is the fact that 0.1 + 0.2 != 0.3 : \n\nprintln(0.1 + 0.2 - 0.3)\n\nWhen summing many numbers, depnding on the order in which they are summed, floating-point approximation errors may aggregate more or less quickly. \n\nThe default summation per-timestep in our example Toy_Tt_CuModel was a naive summation. The cumsum function used in the single-scale simulation to directly compute the TT_cu uses a pairwise summation method that provides approximation error on fewer digits compared to naive summation. Errors aggregate more slowly.\n\nIn our simple example, using Float64 values, the difference wasn't significant enough to matter, but if you are writing a simulation over many timesteps or aggregating a value over many nodes, you may need to alter models to avoid numerical errors blowing up due to floating-point accuracy.\n\nDepending on what value is being computed and the mathematical operations used, changes may range from applying a simple scale to a range of values, to significant refactoring.","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/#Other-links-related-to-floating-point-numerical-concerns","page":"Floating-point considerations","title":"Other links related to floating-point numerical concerns","text":"Note that many of the examples in these blogposts discuss Float32 accuracy. Float64 values have several extra precision bits to work.\n\nA series of blog posts on floating-point accuracy: https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ Floating-Point Visually Explained : https://fabiensanglard.net/floatingpointvisually_explained/ Examples of floating point problems: https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/\n\nRelating specifically to floating-point sums:\n\nPairwise summation: https://en.wikipedia.org/wiki/Pairwise_summation Kahan summation: https://en.wikipedia.org/wiki/Kahansummationalgorithm Taming Floating-Point Sums: https://orlp.net/blog/taming-float-sums/","category":"section"},{"location":"documentation_improvement/#Help-improve-our-documentation-!","page":"Improving our documentation","title":"Help improve our documentation !","text":"One goal for PlantSimEngine is to ensure testing ecophysiological hypotheses, or building plant simulations is as easy as can be for a wider range of people than previous frameworks.\n\nGood documentation is essential for that purpose.\n\nIf parts of the documentation are unclear to you, you are very welcome to send a PR, an email, or a message (either on Github or on the FSPM Discourse) so that we can improve upon it.","category":"section"},{"location":"multiscale/multiscale_considerations/#Multi-scale-considerations","page":"Multiscale considerations","title":"Multi-scale considerations","text":"Pages = [\"multiscale_considerations.md\"]\nDepth = 3\n\nThis page briefly details the subtle ways in which multi-scale simulations differ from prior single-scale simulations. The next few pages will showcase some of these subtleties with examples.\n\nDeclaring and running a multi-scale simulation follows the same general workflow as the single-scale version, but multi-scale simulations do have some differences : \n\na simulation requires a Multi-scale Tree Graph (MTG) to run and operates on that graph\nwhen running, models are tied to a scale and only access local information\nmodels can run multiple times per timestep, \nthe ModelList is replaced by a slightly more complex model mapping to link models to the scale they will operate at.\n\nThe simulation dependency graph will still be computed automatically and handle most couplings, meaning users don't need to specify the order of model execution once the extra code to declare the models is written. You will still need to declare hard dependencies, with extra considerations for multi-scale hard dependencies.\n\nMulti-scale simulations also tend to require more extra ad hoc models to prepare some variables for some models.","category":"section"},{"location":"multiscale/multiscale_considerations/#Related-pages","page":"Multiscale considerations","title":"Related pages","text":"Other pages in the multiscale section describe :\n\nHow to write a direct conversion of a single-scale ModelList simulation to a multi-scale simulation and add a second scale to it: Converting a single-scale simulation to multi-scale, \nA more complex multi-scale version of the single-scale simulation showcasing different variable mappings between scales: Multi-scale variable mapping, \nA three-part tutorial describing how to build up a combination of models to simulate a growing toy plant: Writing a multiscale simulation,\nWays to handle situations where a variable ends up causing a cyclic dependency: Avoiding cyclic dependencies,\nMulti-scale specific coupling considerations and subtleties:Handling dependencies in a multiscale context","category":"section"},{"location":"multiscale/multiscale_considerations/#Multi-scale-tree-graphs","page":"Multiscale considerations","title":"Multi-scale tree graphs","text":"Functional-Structural Plant Models are often about simulating plant growth. A multi-scale simulation is implicitely expected to operate on a plant-like object, represented by a multi-scale tree graph.\n\nA multi-scale tree graph (MTG) object (see the Multi-scale Tree Graphs subsection for a quick description) is therefore required to run a multi-scale simulations. It can be a dummy MTG if the simulation doesn't actually affect it, but is nevertheless a required argument to the multi-scale run! function.\n\nAll the multi-scale examples make use of the companion package MultiScaleTreeGraph.jl, which we therefore recommend for running your own multi-scale simulations. Visualizing a Multi-scale Tree Graph can be done using PlantGeom.\n\nnote: Note\nMulti-scale Tree Graphs make use of conflicting terminology with PlantSimEngine's concepts, which is discussed in Scale/symbol terminology ambiguity. If you are new to those concepts, make sure to read that section and keep note of it.","category":"section"},{"location":"multiscale/multiscale_considerations/#Models-run-once-per-organ-instance,-not-once-per-organ-level","page":"Multiscale considerations","title":"Models run once per organ instance, not once per organ level","text":"Some models, like the ones we've seen in single-scale simulations, work on a very simple model of a whole plant.\n\nMore fine-grained models can be tied to a specific plant organ. \n\nFor instance, a model computing a leaf's surface area depending on its age would operate at the \"leaf\" scale, and be called for every leaf at every timestep. On the other hand, a model computing the plant's total leaf area only needs to be run once per timestep, and can be run at the \"Plant\" scale.\n\nThis is a major difference between a single-scale simulation and a multi-scale one. By default, any model in a single-scale simulation will only run once per timestep. However, in multi-scale, if a plant has several instances of an organ type -say it has a hundred leaves- then any model operating at the \"Leaf\" scale will by default run one hundred times per timestep, unless it is explicitely controlled by another model (which can happen in hard dependency configurations).","category":"section"},{"location":"multiscale/multiscale_considerations/#Mappings","page":"Multiscale considerations","title":"Mappings","text":"When users define which models they use, PlantSimEngine cannot determine in advance which scale level they operate at. This is partly because the plant organs in an MTG do not have standardized names, and partly because some plant organs might not be part of the initial MTG, so parsing it isn't enough to infer what scales are used.\n\nThe user therefore needs to indicate for a simulation's which models are related to which scale.\n\nA multi-scale mapping links models to the scale at which they operate, and is implemented as a Julia Dict, tying a scale, such as \"Leaf\" to models operating at that scale, such as \"LeafSurfaceAreaModel\". It is the equivalent of a ModelList in a single-scale simulation.\n\nMulti-scale models can be similar models to the ones found in earlier sections, or, if they need to make use of variables at other scales, may need to be wrapped as part of a MultiScaleModel object. Many models are not tied to a particular scale, which means those models can be reused at different scales or in single-scale simulations.","category":"section"},{"location":"multiscale/multiscale_considerations/#The-simulation-operates-on-an-MTG","page":"Multiscale considerations","title":"The simulation operates on an MTG","text":"Unlike in single-scale simulations, which make use of a Status object to store the current state of every variable in a simulation, multi-scale simulations operate on a per-organ basis. \n\nThis means every organ instance has its own Status, with scale-specific attributes.\n\nThis has two important consequences in terms of running a simulation :\n\nFirst, any scale absent from the MTG will not be run. If your MTG contains no leaves, then no model operating at the scale \"Leaf\" will be able to run until a \"Leaf\" organ is created and a node is added in the MTG. Otherwise, it has no MTG node to operate on. The only exceptions are hard dependency models which can be called from a different scale, since they can be called directly by a model on a node at a different existing scale, even if there is no node at their own scale.\nSecondly, models only have access to local organ information. The status argument in the run! function only contains variables at the model's scale, unless variables from other scales are mapped via a MultiScaleModel wrapping. ","category":"section"},{"location":"multiscale/multiscale_considerations/#The-run!-function's-signature","page":"Multiscale considerations","title":"The run! function's signature","text":"The run! function differs slightly from its single-scale version. The current structure (excluding a couple of advanced/deprecated kwargs) is the following:\n\nrun!(mtg, mapping, meteo, constants, extra; nsteps, tracked_outputs)\n\nInstead of a ModelList, it takes an MTG and a mapping. The optional meteo and constants argument are identical to the single-scale version. The extra argument is now reserved and should not be used. A new nsteps keyword argument is available to restrict the simulation to a specified number of steps. ","category":"section"},{"location":"multiscale/multiscale_considerations/#Multi-scale-output-data-structure","page":"Multiscale considerations","title":"Multi-scale output data structure","text":"The output structure, like the mapping, is a Julia Dict structure indexed by the scale name. Values are a per-scale Vector{NamedTuple} which lists the requested variables for every node at that scale, for every timestep in the simulation. Timestep and Multiscale Tree Graph nodes are also added to the output data, as a :timestepand a :node entry. \n\nThis dictionary structure makes the outputs as-is a little more verbose to inspect than in single-scale, but the general usage is similar, and it is both compact, and fast to convert to a Dict{String, DataFrame} which can make queries easier. \n\nnote: Note\n\n\nSome of the mapped variables -those that map from scalar to vector- will not be added to the outputs to save some memory and space since they are redundant.\n\nTo illustrate, here's an example output from part 3 of the Toy plant tutorial, zeroing in on a variable at the \"Root\" scale: Fixing bugs in the plant simulation:\n\njulia> outs\n\nDict{String, Vector} with 5 entries:\n  \"Internode\" => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, TT_cu::Float64, carbon_…\n  \"Root\"      => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, water_absorbed::Float64…\n  \"Scene\"     => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, TT_cu::Float64, TT::Float64}[(timestep = 1, node = / 1: Scene…\n  \"Plant\"     => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, carbon_stock::Float64, …\n  \"Leaf\"      => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_captured::Float64}[(timestep = 1, node = + 4: Leaf…\n\njulia> outs[\"Root\"]\n3257-element Vector{@NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, water_absorbed::Float64, root_water_assimilation::Float64}}:\n (timestep = 1, node = + 9: Root\n└─ < 10: Root\n   └─ < 11: Root\n      └─ < 12: Root\n         └─ < 13: Root\n            └─ < 14: Root\n               └─ < 15: Root\n                  └─ < 16: Root\n                     └─ < 17: Root\n, carbon_root_creation_consumed = 50.0, water_absorbed = 0.5, root_water_assimilation = 1.0)\n ⋮\n\nValues are more complex to query than in a single-scale simulation since the indexing isn't straightforward to map to a timestep:\n\njulia> [Pair(outs[\"Root\"][i][:timestep], outs[\"Root\"][i][:carbon_root_creation_consumed]) for i in 1:length(outs[\"Root\"])]\n3257-element Vector{Pair{Int64, Float64}}:\n   1 => 50.0\n   1 => 50.0\n   2 => 50.0\n   2 => 50.0\n   2 => 50.0\n     ⋮\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n\nConverting to a dictionary of DataFrame objects can make such queries easier to write.\n\nwarning: Warning\nCurrently, the :node entry only shallow copies nodes. The :node values at each scale for every timestep actually reflect the final state of the node, meaning attribute values may not correspond to the value at that timestep. You may need to output these values via a dedicated model to keep track of them properly. Also note that there currently is no way of removing nodes. Nodes corresponding to organs considered to be pruned/dead/aborted are still present in the output data structure.\n\nMulti-scale simulations, especially for plants which have thousands of leaves, internodes, root branches, buds and fruits, may compute huge amounts of data. Just like in single-scale simulations, it is possible to keep only variables whose values you want to track for every timestep, and filter the rest out, using the tracked_outputs keyword argument for the run! function. \n\nThose tracked variables also need to be indexed by scale to avoid ambiguity: \n\nouts = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"section"},{"location":"multiscale/multiscale_considerations/#Coupling-and-multi-scale-hard-dependencies","page":"Multiscale considerations","title":"Coupling and multi-scale hard dependencies","text":"Multi-scale brings new types of coupling: mappings are part of the approach used to handle variables used by models at different scales. A model can also have a hard dependency on another model that operates at another scale. This multi-scale-specific complexity is discussed in Handling dependencies in a multiscale context","category":"section"},{"location":"API/API_examples/#Example-models","page":"Example models","title":"Example models","text":"PlantSimEngine provides example processes and models to users. They are available from a sub-module called Examples. To get access to these models in a working environment with PlantSimEngine, you can simply use this sub-module:\n\nusing PlantSimEngine.Examples","category":"section"},{"location":"API/API_examples/#List","page":"Example models","title":"List","text":"Pages = [\"API_examples.md\"]","category":"section"},{"location":"API/API_examples/#Details","page":"Example models","title":"Details","text":"","category":"section"},{"location":"API/API_examples/#PlantSimEngine.Examples","page":"Example models","title":"PlantSimEngine.Examples","text":"A sub-module with example models.\n\nExamples used in the documentation for a set of multiscale models. The models can be found in the examples folder of the package, and are stored  in the following files:\n\nToyAssimModel.jl\nToyCDemandModel.jl\nToyCAllocationModel.jl\nToySoilModel.jl\n\nExamples\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nToyAssimModel()\n\n\n\n\n\n","category":"module"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_AllocationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_AllocationModel","text":"carbon_allocation process abstract model. \n\nAll models implemented to simulate the carbon_allocation process must be a subtype of this type, e.g.  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","text":"carbon_assimilation process abstract model. \n\nAll models implemented to simulate the carbon_assimilation process must be a subtype of this type, e.g.  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_BiomassModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_BiomassModel","text":"carbon_biomass process abstract model. \n\nAll models implemented to simulate the carbon_biomass process must be a subtype of this type, e.g.  struct MyCarbon_BiomassModel <: AbstractCarbon_BiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_DemandModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_DemandModel","text":"carbon_demand process abstract model. \n\nAll models implemented to simulate the carbon_demand process must be a subtype of this type, e.g.  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractDegreedaysModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractDegreedaysModel","text":"Degreedays process abstract model. \n\nAll models implemented to simulate the Degreedays process must be a subtype of this type, e.g.  struct MyDegreedaysModel <: AbstractDegreedaysModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractDegreedaysModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractGrowthModel","text":"growth process abstract model. \n\nAll models implemented to simulate the growth process must be a subtype of this type, e.g.  struct MyGrowthModel <: AbstractGrowthModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractGrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLai_DynamicModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLai_DynamicModel","text":"LAI_Dynamic process abstract model. \n\nAll models implemented to simulate the LAI_Dynamic process must be a subtype of this type, e.g.  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","text":"leaf_surface process abstract model. \n\nAll models implemented to simulate the leaf_surface process must be a subtype of this type, e.g.  struct MyLeaf_SurfaceModel <: AbstractLeaf_SurfaceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_SurfaceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLight_InterceptionModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLight_InterceptionModel","text":"light_interception process abstract model. \n\nAll models implemented to simulate the light_interception process must be a subtype of this type, e.g.  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLight_PartitioningModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLight_PartitioningModel","text":"light_partitioning process abstract model. \n\nAll models implemented to simulate the light_partitioning process must be a subtype of this type, e.g.  struct MyLight_PartitioningModel <: AbstractLight_PartitioningModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_PartitioningModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","text":"maintenance_respiration process abstract model. \n\nAll models implemented to simulate the maintenance_respiration process must be a subtype of this type, e.g.  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","text":"organ_emergence process abstract model. \n\nAll models implemented to simulate the organ_emergence process must be a subtype of this type, e.g.  struct MyOrgan_EmergenceModel <: AbstractOrgan_EmergenceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractOrgan_EmergenceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess1Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess1Model","text":"process1 process abstract model. \n\nAll models implemented to simulate the process1 process must be a subtype of this type, e.g.  struct MyProcess1Model <: AbstractProcess1Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess1Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess2Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess2Model","text":"process2 process abstract model. \n\nAll models implemented to simulate the process2 process must be a subtype of this type, e.g.  struct MyProcess2Model <: AbstractProcess2Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess2Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess3Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess3Model","text":"process3 process abstract model. \n\nAll models implemented to simulate the process3 process must be a subtype of this type, e.g.  struct MyProcess3Model <: AbstractProcess3Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess3Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess4Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess4Model","text":"process4 process abstract model. \n\nAll models implemented to simulate the process4 process must be a subtype of this type, e.g.  struct MyProcess4Model <: AbstractProcess4Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess4Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess5Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess5Model","text":"process5 process abstract model. \n\nAll models implemented to simulate the process5 process must be a subtype of this type, e.g.  struct MyProcess5Model <: AbstractProcess5Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess5Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess6Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess6Model","text":"process6 process abstract model. \n\nAll models implemented to simulate the process6 process must be a subtype of this type, e.g.  struct MyProcess6Model <: AbstractProcess6Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess6Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess7Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess7Model","text":"process7 process abstract model. \n\nAll models implemented to simulate the process7 process must be a subtype of this type, e.g.  struct MyProcess7Model <: AbstractProcess7Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess7Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractSoil_WaterModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractSoil_WaterModel","text":"soil_water process abstract model. \n\nAll models implemented to simulate the soil_water process must be a subtype of this type, e.g.  struct MySoil_WaterModel <: AbstractSoil_WaterModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Beer","page":"Example models","title":"PlantSimEngine.Examples.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nRequired inputs: LAI in m² m⁻². Required meteorology data: Ri_PAR_f, the incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹).\n\nOutput: aPPFD, the absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process1Model","page":"Example models","title":"PlantSimEngine.Examples.Process1Model","text":"Process1Model(a)\n\nA dummy model implementing a \"process1\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process2Model","page":"Example models","title":"PlantSimEngine.Examples.Process2Model","text":"Process2Model()\n\nA dummy model implementing a \"process2\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process3Model","page":"Example models","title":"PlantSimEngine.Examples.Process3Model","text":"Process3Model()\n\nA dummy model implementing a \"process3\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process4Model","page":"Example models","title":"PlantSimEngine.Examples.Process4Model","text":"Process4Model()\n\nA dummy model implementing a \"process4\" process for testing purposes. It computes the inputs needed for the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process5Model","page":"Example models","title":"PlantSimEngine.Examples.Process5Model","text":"Process5Model()\n\nA dummy model implementing a \"process5\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process6Model","page":"Example models","title":"PlantSimEngine.Examples.Process6Model","text":"Process6Model()\n\nA dummy model implementing a \"process6\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3, but also from process 7 that is itself independant.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process7Model","page":"Example models","title":"PlantSimEngine.Examples.Process7Model","text":"Process7Model()\n\nA dummy model implementing a \"process7\" process for testing purposes. It is independent (needs :var0 only as for Process4Model), but its outputs are used by Process6Model, so it is a soft-coupling.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyAssimGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.ToyAssimGrowthModel","text":"ToyAssimGrowthModel(Rm_factor, Rg_cost)\nToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\nRm_factor=0.5: the fraction of assimilation that goes into maintenance respiration\nRg_cost=1.2: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the assimilation, in gC m⁻² time-step⁻¹\nRm: the maintenance respiration, in gC m⁻² time-step⁻¹\nRg: the growth respiration, in gC m⁻² time-step⁻¹\nbiomass_increment: the daily biomass increment, in gC m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyAssimModel","page":"Example models","title":"PlantSimEngine.Examples.ToyAssimModel","text":"ToyAssimModel(LUE)\n\nComputes the assimilation of a plant (= photosynthesis).\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\nsoil_water_content: the soil water content, in %\n\nOutputs\n\ncarbon_assimilation: the assimilation or photosynthesis, also sometimes denoted A, in gC m⁻² time-step⁻¹\n\nDetails\n\nThe assimilation is computed as the product of the absorbed photosynthetic photon flux density (aPPFD) and the light use efficiency (LUE), so the units of the assimilation usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of aPPFD, e.g.  if aPPFD is in mol[PAR] plant⁻¹ time-step⁻¹, the assimilation will be in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCAllocationModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCAllocationModel","text":"ToyCAllocationModel()\n\nComputes the carbon allocation to each organ of a plant based on the plant total carbon offer and individual organ demand. This model should be used at the plant scale, because it first computes the carbon availaible for allocation as the minimum between the total demand  (sum of organs' demand) and total carbon offer (sum of organs' assimilation - total maintenance respiration), and then allocates the carbon relative  to each organ's demand.\n\nInputs\n\ncarbon_assimilation: a vector of the assimilation of all photosynthetic organs, usually in gC m⁻² time-step⁻¹\nRm: the maintenance respiration of the plant, usually in gC m⁻² time-step⁻¹\ncarbon_demand: a vector of the carbon demand of the organs, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the carbon assimilation, usually in gC m⁻² time-step⁻¹\n\nDetails\n\nThe units usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of the inputs, e.g. in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCBiomassModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCBiomassModel","text":"ToyCBiomassModel(construction_cost)\n\nComputes the carbon biomass of an organ based on the carbon allocation and construction cost.\n\nArguments\n\nconstruction_cost: the construction cost of the organ, usually in gC gC⁻¹. Should be understood as the amount of carbon needed to build 1g of carbon biomass.\n\nInputs\n\ncarbon_allocation: the carbon allocation to the organ for the time-step, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_biomass_increment: the increment of carbon biomass, usually in gC time-step⁻¹\ncarbon_biomass: the carbon biomass, usually in gC\ngrowth_respiration: the growth respiration, usually in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCDemandModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCDemandModel","text":"ToyCDemandModel(optimal_biomass, development_duration)\nToyCDemandModel(; optimal_biomass, development_duration)\n\nComputes the carbon demand of an organ depending on its biomass under optimal conditions and the duration of its development in degree days. The model assumes that the carbon demand is linear througout the duration of the development.\n\nArguments\n\noptimal_biomass: the biomass of the organ under optimal conditions, in gC\ndevelopment_duration: the duration of the development of the organ, in degree days\n\nInputs\n\nTT: the thermal time, in degree days\n\nOutputs\n\ncarbon_demand: the carbon demand, in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyDegreeDaysCumulModel","page":"Example models","title":"PlantSimEngine.Examples.ToyDegreeDaysCumulModel","text":"ToyDegreeDaysCumulModel(;init_TT=0.0, T_base=10.0, T_max=43.0)\n\nComputes the thermal time in degree days and cumulated degree-days based on the average daily temperature (T), the initial cumulated degree days, the base temperature below which there is no growth, and the maximum  temperature for growh.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyInternodeEmergence","page":"Example models","title":"PlantSimEngine.Examples.ToyInternodeEmergence","text":"ToyInternodeEmergence(;init_TT=0.0, TT_emergence = 300)\n\nComputes the organ emergence based on cumulated thermal time since last event.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLAIModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLAIModel","text":"ToyLAIModel(;max_lai=8.0, dd_incslope=800, inc_slope=110, dd_decslope=1500, dec_slope=20)\n\nComputes the Leaf Area Index (LAI) based on a sigmoid function of thermal time.\n\nArguments\n\nmax_lai: the maximum LAI value\ndd_incslope: the thermal time at which the LAI starts to increase\ninc_slope: the slope of the increase\ndd_decslope: the thermal time at which the LAI starts to decrease\ndec_slope: the slope of the decrease\n\nInputs\n\nTT_cu: the cumulated thermal time since the beginning of the simulation, usually in °C days\n\nOutputs\n\nLAI: the Leaf Area Index, usually in m² m⁻²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","text":"ToyLAIfromLeafAreaModel()\n\nComputes the Leaf Area Index (LAI) of the scene based on the plants leaf area.\n\nArguments\n\nscene_area: the area of the scene, usually in m²\n\nInputs\n\nsurface: a vector of plant leaf surfaces, usually in m²\n\nOutputs\n\nLAI: the Leaf Area Index of the scene, usually in m² m⁻²\ntotal_surface: the total surface of the plants, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLeafSurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLeafSurfaceModel","text":"ToyLeafSurfaceModel(SLA)\n\nComputes the individual leaf surface from its biomass using the SLA.\n\nArguments\n\nSLA: the specific leaf area, usually in m² gC⁻¹. Should be understood as the surface area of a leaf per unit of carbon biomass.\n\nValues typically range from 0.002 to 0.027 m² gC⁻¹.\n\nInputs\n\ncarbon_biomass: the carbon biomass of the leaf, usually in gC\n\nOutputs\n\nsurface: the leaf surface, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLightPartitioningModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLightPartitioningModel","text":"ToyLightPartitioningModel()\n\nComputes the light partitioning based on relative surface.\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density at the larger scale (e.g. scene), in mol[PAR] m⁻² time-step⁻¹ \n\nOutputs\n\naPPFD: the assimilation or photosynthesis, also sometimes denoted A, in gC time-step⁻¹\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyMaintenanceRespirationModel","page":"Example models","title":"PlantSimEngine.Examples.ToyMaintenanceRespirationModel","text":"RmQ10FixedN(Q10, Rm_base, T_ref, P_alive, nitrogen_content)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nRm_base: Base maintenance respiration (gC gDM⁻¹ time-step⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nnitrogen_content: nitrogen content of the organ (gN gC⁻¹)\n\nInputs\n\ncarbon_biomass: the carbon biomass of the organ in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","text":"ToyPlantLeafSurfaceModel()\n\nComputes the leaf surface at plant scale by summing the individual leaf surfaces.\n\nInputs\n\nleaf_surfaces: a vector of leaf surfaces, usually in m²\n\nOutputs\n\nsurface: the leaf surface at plant scale, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyPlantRmModel","page":"Example models","title":"PlantSimEngine.Examples.ToyPlantRmModel","text":"ToyPlantRmModel()\n\nTotal plant maintenance respiration based on the sum of Rm_organs, the maintenance respiration of the organs.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC time-step⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyRUEGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.ToyRUEGrowthModel","text":"ToyRUEGrowthModel(efficiency)\n\nComputes the carbon biomass increment of a plant based on the radiation use efficiency principle.\n\nArguments\n\nefficiency: the radiation use efficiency, in gC[biomass] mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\nbiomass_increment: the daily biomass increment, in gC[biomass] m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC[biomass] m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToySoilWaterModel","page":"Example models","title":"PlantSimEngine.Examples.ToySoilWaterModel","text":"ToySoilWaterModel(values=[0.5])\n\nA toy model to compute the soil water content. The model simply take a random value in the values range using rand.\n\nOutputs\n\nsoil_water_content: the soil water content (%).\n\nArguments\n\nvalues: a range of soil_water_content values to sample from. Can be a vector of values [0.5,0.6] or a range 0.1:0.1:1.0. Default is [0.5].\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.import_mtg_example-Tuple{}","page":"Example models","title":"PlantSimEngine.Examples.import_mtg_example","text":"import_mtg_example()\n\nReturns an example multiscale tree graph (MTG) with a scene, a soil, and a plant with two internodes and two leaves.\n\nExamples\n\njulia> using PlantSimEngine.Examples\n\njulia> import_mtg_example()\n/ 1: Scene\n├─ / 2: Soil\n└─ + 3: Plant\n   └─ / 4: Internode\n      ├─ + 5: Leaf\n      └─ < 6: Internode\n         └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples/#PlantSimEngine.fit-Tuple{Type{PlantSimEngine.Examples.Beer}, Any}","page":"Example models","title":"PlantSimEngine.fit","text":"fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n\nCompute the k parameter of the Beer-Lambert law from measurements.\n\nArguments\n\n::Type{Beer}: the model type\ndf: a DataFrame with the following columns:\naPPFD: the measured absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹\nLAI: the measured leaf area index in m² m⁻²\nRi_PAR_f: the measured incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹)\n\nExamples\n\nImport the example models defined in the Examples sub-module:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\n\nCreate a model list with a Beer model, and fit it to the data:\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples/#PlantSimEngine.run!","page":"Example models","title":"PlantSimEngine.run!","text":"run!(::Beer, object, meteo, constants=Constants(), extra=nothing)\n\nComputes the photosynthetic photon flux density (aPPFD, µmol m⁻² s⁻¹) absorbed by an  object using the incoming PAR radiation flux (Ri_PAR_f, W m⁻²) and the Beer-Lambert law of light extinction.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for LAI (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\nextra = nothing: extra arguments, not used here.\n\nExamples\n\nm = ModelList(Beer(0.5), status=(LAI=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_q=300.0)\n\nrun!(m, meteo)\n\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"multiscale/multiscale_cyclic/#Avoiding-cyclic-dependencies","page":"Handling cyclic dependencies","title":"Avoiding cyclic dependencies","text":"When defining a mapping between models and scales, it is important to avoid cyclic dependencies. A cyclic dependency occurs when a model at a given scale depends on a model at another scale that depends on the first model. Cyclic dependencies are bad because they lead to an infinite loop in the simulation (the dependency graph keeps cycling indefinitely).\n\nPlantSimEngine will detect cyclic dependencies and raise an error if one is found. The error message indicates the models involved in the cycle, and the model that is causing the cycle will be highlighted in red.\n\nFor example the following mapping will raise an error:\n\ndetails: Details\n<summary>Example mapping</summary>mapping_cyclic = Dict(\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n        Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6),\n    ),\n    \"Internode\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(TT=10.0, carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        ToyCBiomassModel(1.2),\n        Status(TT=10.0),\n    )\n)\n\nLet's see what happens when we try to build the dependency graph for this mapping:\n\njulia> dep(mapping_cyclic)\nERROR: Cyclic dependency detected in the graph. Cycle:\n Plant: ToyPlantRmModel\n └ Leaf: ToyMaintenanceRespirationModel\n  └ Leaf: ToyCBiomassModel\n   └ Plant: ToyCAllocationModel\n    └ Plant: ToyPlantRmModel\n\n You can break the cycle using the `PreviousTimeStep` variable in the mapping.\n\nHow can we interpret the message? We have a list of five models involved in the cycle. The first model is the one causing the cycle, and the others are the ones that depend on it. In this case, the ToyPlantRmModel is the one causing the cycle, and the others are inter-dependent. We can read this as follows:\n\nToyPlantRmModel depends on ToyMaintenanceRespirationModel, the plant-scale respiration sums up all organs respiration;\nToyMaintenanceRespirationModel depends on ToyCBiomassModel, the organs respiration depends on the organs biomass;\nToyCBiomassModel depends on ToyCAllocationModel, the organs biomass depends on the organs carbon allocation;\nAnd finally ToyCAllocationModel depends on ToyPlantRmModel again, hence the cycle because the carbon allocation depends on the plant scale respiration.\n\nThe models can not be ordered in a way that satisfies all dependencies, so the cycle can not be broken. To solve this issue, we need to re-think how models are mapped together, and break the cycle.\n\nThere are several ways to break a cyclic dependency:\n\nMerge models: If two models depend on each other because they need e.g. recursive computations, they can be merged into a third model that handles the computation and takes the two models as hard dependencies. Hard dependencies are models that are explicitly called by another model and do not participate on the building of the dependency graph.\nChange models: Of course models can be interchanged to avoid cyclic dependencies, but this is not really a solution, it is more a workaround.\nPreviousTimeStep: We can break the dependency graph by defining some variables as taken from the previous time step. A very well known example is the computation of the light interception by a plant that depends on the leaf area, which is usually the result of a model that also depends on the light interception. The cyclic dependency is usually broken by using the leaf area from the previous time step in the interception model, which is a good approximation for most cases.\n\nWe can fix our previous mapping by computing the organs respiration using the carbon biomass from the previous time step instead. Let's see how to fix the cyclic dependency in our mapping (look at the leaf and internode scales):\n\ndetails: Details\nmapping_nocyclic = Dict(\n        \"Plant\" => (\n            MultiScaleModel(\n                model=ToyCAllocationModel(),\n                mapping=[\n                    :carbon_demand => [\"Leaf\", \"Internode\"],\n                    :carbon_allocation => [\"Leaf\", \"Internode\"]\n                ],\n            ),\n            MultiScaleModel(\n                model=ToyPlantRmModel(),\n                mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n            ),\n            Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6, carbon_assimilation=5.0),\n        ),\n        \"Internode\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (first break)\n            ),\n            Status(TT=10.0, carbon_biomass=1.0),\n        ),\n        \"Leaf\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (second break)\n            ),\n            ToyCBiomassModel(1.2),\n            Status(TT=10.0),\n        )\n    );\nnothing # hide\n\nThe ToyMaintenanceRespirationModel models are now defined as MultiScaleModel, and the carbon_biomass variable is wrapped in a PreviousTimeStep structure. This structure tells PlantSimEngine to take the value of the variable from the previous time step, breaking the cyclic dependency.\n\nnote: Note\nPreviousTimeStep tells PlantSimEngine to take the value of the previous time step for the variable it wraps, or the value at initialization for the first time step. The value at initialization is the one provided by default in the models inputs, but is usually provided in the Status structure to override this default. A PreviousTimeStep is used to wrap the input variable of a model, with or without a mapping to another scale e.g. PreviousTimeStep(:carbon_biomass) => \"Leaf\".","category":"section"},{"location":"prerequisites/julia_basics/#Getting-started-with-Julia","page":"Julia language basics","title":"Getting started with Julia","text":"PlantSimEngine (as well as its related packages) is written in Julia. The reasons why Julia was chosen are briefly discussed here : The choice of using Julia.\n\nJulia is a language that is gaining traction, but it isn't the most widely used in research and data science. \n\nMany elements will be familiar to those with an R, Python or Matlab background, but there are some noteworthy differences, and if you are new to the language, there will be a few hurdles you might have to overcome to be comfortable using the language.\n\nThis page is here to list to the parts of Julia that are most relevant regarding usage of PlantSimEngine, and point to resources that can help you grasp those basics.","category":"section"},{"location":"prerequisites/julia_basics/#New-to-programming","page":"Julia language basics","title":"New to programming","text":"It is not meant as a full-fledged from-scratch Julia tutorial. If you are completely new to programming, you may wish to check some other resources first, such as ones found here. The video course Julia Programming for Nervous Beginners is tailored for people with no programming experience.","category":"section"},{"location":"prerequisites/julia_basics/#Installing-packages-and-setting-up-and-environment","page":"Julia language basics","title":"Installing packages and setting up and environment","text":"For PlantSimEngine, you can check our documentation page on the topic:  Installing and running PlantSimEngine","category":"section"},{"location":"prerequisites/julia_basics/#Cheatsheets","page":"Julia language basics","title":"Cheatsheets","text":"You can also find a few cheatsheets here as well as a short introductory notebook along with its install instructions.","category":"section"},{"location":"prerequisites/julia_basics/#Troubleshooting","page":"Julia language basics","title":"Troubleshooting","text":"There is a documentation page showcasing some of the common errors than can occur when using PlantSimEngine, which may be worth checking if you are encountering issues: Troubleshooting error messages.\n\nFor more Julia learning-related difficulties, you will find quick responses on the Discourse forum: https://discourse.julialang.org.","category":"section"},{"location":"prerequisites/julia_basics/#Noteworthy-differences-with-other-languages:","page":"Julia language basics","title":"Noteworthy differences with other languages:","text":"If you wish to compare Julia to a specific language, the noteworthy differences section will provide you with a quick overview of the differences.\n\n(Array indexing starts at 1, for example)","category":"section"},{"location":"prerequisites/julia_basics/#Essential-Julia-concepts-for-PlantSimEngine","page":"Julia language basics","title":"Essential Julia concepts for PlantSimEngine","text":"Here's a list of the main aspects of the Julia language required (beyond package management) to understand how to use PlantSimEngine to its potential:\n\nStandard notions and constructs:\n\nStandard concepts of a variable, arrays, functions, function arguments\nThe typing system and custom types\nDictionaries and NamedTuple objects are used throughout the codebase\n\nThe Julia manual goes more in-depth than lighter introductions to some of these topics, so might be more useful as a reference than a starting point. You might find other guides or courses, such as the first section in https://julia.quantecon.org/intro.html, chapters 0-4 and 7 of the Learn Julia the Hard Way draft or the interactive Mathigon course.\n\nAlso of importance:\n\nKeyword arguments (kwargs) are present in many API functions\nType promotion, splatting, broadcasting, and comprehensions are also very useful, but not compulsory to get started\n\nMany of these are also briefly presented in this Julia Data Science guide, which also happens to focus on the DataFrames.jl package.\n\nUnderstanding more about methods, parametric types and the typing system is usually worthwhile, when working with Julia packages.","category":"section"},{"location":"step_by_step/implement_a_model/#model_implementation_page","page":"Implementing a model","title":"Implementing a model","text":"For your own simulations, you might want to move beyond simple usage at some point and implement your own models. In this page, we'll go through the required steps for writing a new model. The detailed version is tailored for people less familiar with programming.","category":"section"},{"location":"step_by_step/implement_a_model/#Quick-version","page":"Implementing a model","title":"Quick version","text":"Declare a new process : \n\n@process \"light_interception\" verbose = false\n\nDeclare your model struct, and its parameters : \n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\nDeclare the inputs_ and outputs_ methods for that model (note the '_', these methods are distinct from inputs and outputs)\n\nfunction PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend\n\nWrite the run! function that operates on a single timestep : \n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend\n\nDetermine if parallelization is possible, and which traits to declare :\n\nPlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()\n\nAnd that is all you need to get going, for this example with a single parameter and no interdependencies. \n\nThe @process macro does some boilerplate work described here\n\nSome extra utility functions can also be interesting to implement to make users' lives simpler. See the Model implementation additional notes page for details. If your custom model needs to handle more complex couplings than the simple input/output described in this example, check out the Coupling more complex models page.","category":"section"},{"location":"step_by_step/implement_a_model/#Detailed-version","page":"Implementing a model","title":"Detailed version","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.\n\nThe model we'll (re)implement is available as an example model from the Examples sub-module. You can access the script from here: examples/Beer.jl. It is also available in the PlantBioPhysics.jl package.\n\nYou can import the model and PlantSimEngine's other example models into your environment with using:\n\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"section"},{"location":"step_by_step/implement_a_model/#Other-examples","page":"Implementing a model","title":"Other examples","text":"PlantSimEngine's other toy models can be found in the examples folder.\n\nFor other examples, you can look at the code in PlantBiophysics.jl, where you will find e.g. a photosynthesis model, with the implementation of the FvCB model in src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"section"},{"location":"step_by_step/implement_a_model/#Requirements","page":"Implementing a model","title":"Requirements","text":"If you have a look at example models, you'll see that in order to implement a new model you'll need to implement:\n\na structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"section"},{"location":"step_by_step/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Implementing a model","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"step_by_step/implement_a_model/#The-process","page":"Implementing a model","title":"The process","text":"We start by declaring the light interception process at l.7 using @process: \n\n@process \"light_interception\" verbose = false\n\nSee Implementing a new process for more details on how that works and how to use the process.","category":"section"},{"location":"step_by_step/implement_a_model/#The-structure","page":"Implementing a model","title":"The structure","text":"To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:\n\nhold the parameter values\ndispatch to the right run! method when calling it\n\nThe structure of the model (or type) is defined as follows:\n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\nThe first line defines the name of the model (Beer). It is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. \n\nThe Beer structure is defined as a subtype of AbstractLight_InterceptionModel indicating what kind of process the model simulates. The AbstractLight_InterceptionModel type is automatically created when defining the process \"light_interception\".\n\nWe can therefore infer from the declaration that Beer is a model to simulate the light interception process.\n\nThen come the parameters names, and their types. ","category":"section"},{"location":"step_by_step/implement_a_model/#User-types-and-parametric-types","page":"Implementing a model","title":"User types and parametric types","text":"There is a little Julia specificity here, to enable the user to pass their own types to the simulation.\n\nBeer is a parameterized struct, indicated by the {T} annotation\nWe indicate the k parameter is of type T by adding ::T after the name.\n\nThe T is an arbitrary letter here. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:\n\nstruct CustomModel{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend\n\nParameterized types are practical because they let the user choose the type of the parameters, and potentially change them at runtime. For example a user could use the Particles type from MonteCarloMeasurements.jl for automatic uncertainty propagation throughout the simulation. We refer you to the Parametric types subsection of the Model implementation additional notes page for more information on parametric types.","category":"section"},{"location":"step_by_step/implement_a_model/#Inputs-and-outputs","page":"Implementing a model","title":"Inputs and outputs","text":"When implementing a new model, it is necessary to declare what variables will be required, whether provided as an input to our model or computed for every timestep as an output. Input variables will either be initialized by the user in a Status object, or provided by another model. Output variables may be global simulation outputs and/or used by other models.\n\nIn our case, the Beer model, computing light interception, has one input variable and one output variable:\n\nInputs: :LAI, the leaf area index (m² m⁻²)\nOutputs: :aPPFD, the photosynthetic photon flux density (μmol m⁻² s⁻¹)\n\nWe declare these inputs/outputs by adding a method for the inputs and outputs functions. These functions take the type of the model as argument, and return a NamedTuple with the names of the variables as keys, and their default values as values:\n\nfunction PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend\n\nThese functions are internal, and end with an \"_\". Users instead use inputs and outputs to query model variables.","category":"section"},{"location":"step_by_step/implement_a_model/#The-run!-method","page":"Implementing a model","title":"The run! method","text":"When running a simulation with run!, each model is run in turn at every timestep, following whatever order was deduced from the ModelList definition and Status. Each model also has its run! method for that purpose that update the simulation's current state, with a slightly different signature. The function takes six arguments:\n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n\nthe model's type\nmodels: a ModelList object, which contains all the models of the simulation\nstatus: a Status object, which contains the current values (i.e. state) of the variables for one time-step (e.g. the value of the plant LAI at time t)\nmeteo: (usually) an Atmosphere object, or a row of the meteorological data, which contains the current values of the meteorological variables for one time-step (e.g. the value of the PAR at time t)\nconstants: a Constants object, or a NamedTuple, which contains the values of the constants for the simulation (e.g. the value of the Stefan-Boltzmann constant, unit-conversion constants...)\nextras: any other object you want to pass to your model, mostly for advanced usage, not detailed here\n\nA typical run! function can therefore make use of simulation constants, input/output variables accessible through the [Status](@ref object, or weather data. \n\nHere is the run! implementation of the light interception for a ModelList component models. Note that the input and output variable are accessed through the status argument :\n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"section"},{"location":"step_by_step/implement_a_model/#Additional-notes","page":"Implementing a model","title":"Additional notes","text":"To use this model, users will have to make sure that the variables for that model are defined in the Status object, the meteorology, and the Constants object.\n\n!!! Note     Status objects contain the current state of the simulation. It is not, by default, possible to make use of earlier variable states, unless a custom model is written for that purpose.\n\nModel parameters are available from the ModelList that is passed via the models argument. Index by the process name, then the parameter name. For example, the k parameter of the Beer model is found in models.light_interception.k.\n\nwarning: Warning\nYou need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_. The troubleshooting subsection Implementing a model: forgetting to import or prefix functions showcases output errors that can occur when you forget to prefix.","category":"section"},{"location":"step_by_step/implement_a_model/#Parallelization-traits","page":"Implementing a model","title":"Parallelization traits","text":"PlantSimEngine defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (i.e. objects) and/or time (i.e. time-steps).\n\nBy default, all models are assumed to be not parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.\n\nFor example, if we want to add the trait for parallelization over objects to our Beer model, we would do:\n\nPlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\n\nAnd if we want to add the trait for parallelization over time-steps to our Beer model, we would do:\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()\n\nnote: Note\nA model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.\n\nOK that's it! We now a full new model implementation for the light interception process! Other models might be more complex in terms of what computations they do, or how they couple with other models, but the approach remains the same.","category":"section"},{"location":"step_by_step/implement_a_model/#Dependencies","page":"Implementing a model","title":"Dependencies","text":"If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.\n\nTo do so, we can add a method to the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run.\n\nOur example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:\n\nPlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)\n\nHere we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.\n\nYou can read more about hard dependencies in Coupling more complex models.","category":"section"},{"location":"step_by_step/model_switching/#Model-switching","page":"Model Switching","title":"Model switching","text":"One of the main objective of PlantSimEngine is allowing users to switch between model implementations for a given process without making any change to the PlantSimEngine codebase.\n\nThe package was designed around this idea to make easy changes easy and efficient. Switch models in the ModelList, and call the run! function again. No other changes are required if no new variables are introduced.","category":"section"},{"location":"step_by_step/model_switching/#A-first-simulation-as-a-starting-point","page":"Model Switching","title":"A first simulation as a starting point","text":"With a working environment, let's create a ModelList with several models from the example scripts in the examples folder:\n\nImporting the models from the scripts:\n\nusing PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nCoupling the models in a ModelList:\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide\n\nWe can the simulation by calling the run! function with meteorology data. Here we use an example data set:\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide\n\nWe can now run the simulation:\n\noutput_initial = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/model_switching/#Switching-one-model-in-the-simulation","page":"Model Switching","title":"Switching one model in the simulation","text":"Now what if we want to switch the model that computes growth ? We can do this by simply replacing the model in the ModelList, and PlantSimEngine will automatically update the dependency graph, and adapt the simulation to the new model.\n\nLet's switch ToyRUEGrowthModel with ToyAssimGrowthModel:\n\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(), # This was `ToyRUEGrowthModel(0.2)` before\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide\n\nToyAssimGrowthModel is a little bit more complex than ToyRUEGrowthModel](@ref), as it also computes the maintenance and growth respiration of the plant, so it has more parameters (we use the default values here). \n\nWe can run a new simulation and see that the simulation's results are different from the previous simulation:\n\noutput_updated = run!(models2, meteo_day)\n\nAnd that's it! We can switch between models without changing the code, and without having to recompute the dependency graph manually. This is a very powerful feature of PlantSimEngine!💪\n\nnote: Note\nThis was a very standard but straightforward example. Sometimes other models will require to add other models to the ModelList. For example ToyAssimGrowthModel could have required a maintenance respiration model. In this case PlantSimEngine will indicate what kind of model is required for the simulation.\n\nnote: Note\nIn our example we replaced what we call a soft-dependency coupling, but the same principle applies to hard-dependencies. Hard and Soft dependencies are concepts related to model coupling, and are discussed in more detail in Standard model coupling and Coupling more complex models.","category":"section"},{"location":"multiscale/multiscale/#Multi-scale-variable-mapping","page":"More variable mapping examples","title":"Multi-scale variable mapping","text":"The previous page showed how to convert a single-scale simulation to multi-scale.\n\nThis page provides another example showcasing the nuances in variable mapping, with a more complex fully multiscale version of a prior simulation. The models will all be taken form the examples folder.\n\nPages = [\"multiscale.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale/#Starting-with-a-single-model-mapping","page":"More variable mapping examples","title":"Starting with a single-model mapping","text":"Let's import the PlantSimEngine package and all the example models we will use in this tutorial:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples # Import some example models\n\nLet's create a simple mapping with only one initial model, the carbon assimilation process ToyAssimModel, which will operate on leaves. It resembles the ToyAssimGrowth model used in the single-scale simulation Model switching subsection.\n\nOur mapping between scale and model is therefore:\n\nmapping = Dict(\"Leaf\" => ToyAssimModel())\n\nJust like in single-scale simulations, we can call to_initialize to check whether variables need to be initialised. It will this time index by scale:\n\nto_initialize(mapping)\n\nIn this example, the ToyAssimModel needs :aPPFD and :soil_water_content as inputs, which aren't initialised in our mapping.\n\nThe initialization values for the variables can be passed along via a Status object:\n\nmapping = Dict(\n    \"Leaf\" => (\n        ToyAssimModel(),\n        Status(aPPFD=1300.0, soil_water_content=0.5),\n    ),\n)\n\nIf we call to_initialize on this new mapping, it returns an empty dictionary, meaning the mapping is valid, and we can start the simulation:\n\nto_initialize(mapping)","category":"section"},{"location":"multiscale/multiscale/#Multiscale-mapping-between-models-and-scales","page":"More variable mapping examples","title":"Multiscale mapping between models and scales","text":"The soil_water_content variable was provided via the mapping. No model affects it, so it is constant in the above example. We could instead provide a model that computes it based on weather data, and/or a more realistic physical process. \n\nIt also makes sense to have that model operate at a different scale than the \"Leaf\" scale. There is a dummy soil model called ToySoilModel in the examples folder. Let's put it at a new \"Soil\" scale level.\n\nToyAssimModel is now makes use of the soil_water_content variable from the \"Soil\" scale, instead of at its own scale via the Status initialization. We therefore need to map soil_water_content from the \"Soil\" to the \"Leaf\" scale by wrapping ToyAssimModel in a MultiScaleModel:\n\nmapping = Dict(\n    \"Soil\" => ToySoilWaterModel(),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\" => :soil_water_content,],\n        ),\n        Status(aPPFD=1300.0),        \n    ),\n);\nnothing # hide\n\nIn this example, we map the soil_water_content variable at scale \"Leaf\" to the soil_water_content variable at the \"Soil\" scale. If the name of the variable is the same between both scales, we can omit the variable name at the origin scale, e.g. [:soil_water_content => \"Soil\"].\n\nThe variable aPPFD is still provided in the Status type as a constant value.\n\nWe can check again if the mapping is valid by calling to_initialize:\n\nto_initialize(mapping)\n\nOnce again, to_initialize returns an empty dictionary, meaning the mapping is valid.","category":"section"},{"location":"multiscale/multiscale/#A-more-elaborate-multiscale-model-mapping","page":"More variable mapping examples","title":"A more elaborate multiscale model mapping","text":"Let's now expand this mapping, to showcase other ways in which variables can be mapped from one scale to another. We'll keep the first two models, and add several more to simulate a couple of other processes within our plant.\n\nmapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\", :aPPFD => \"Plant\"],\n        ),\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=0.5),\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide\n\nThis mapping might seem a little more daunting than previous examples, but several models should be recognizable in passing. In fact, you can consider this mapping to be an enhanced and more complex multi-scale version of a previous single-scale example, the coupling between photosynthesis model, a LAI model and a carbon biomass increment model, used in the Model switching subsection.\n\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nThe multi-scale models simulate carbon capture via photosynthesis and carbon allocation for the plant organs' maintenance respiration and development.\n\nThe LAI and photosynthesis models are the same as in the ModelList example. The ToyDegreeDaysCumulModel provides the Cumulative Thermal Time to the plant. \n\nThe newly introduced models have the following dynamic : \n\nCarbon allocation is determined (ToyCAllocationModel) for the different organs of the plant (\"Leaf\" and \"Internode\") from the assimilation at the \"Leaf\" scale (i.e. the offer) and their carbon demand (ToyCDemandModel). The \"Soil\" scale is used to compute the soil water content (ToySoilWaterModel](@ref)), which is needed to calculate the assimilation at the \"Leaf\" scale (ToyAssimModel). Also note that maintenance respiration at computed at the \"Leaf\" and \"Internode\" scales (ToyMaintenanceRespirationModel), and aggregated to compute the total maintenance respiration at the \"Plant\" scale (ToyPlantRmModel). ","category":"section"},{"location":"multiscale/multiscale/#Different-possible-variable-mappings","page":"More variable mapping examples","title":"Different possible variable mappings","text":"The above mapping showcases the different ways to define how the variables are mapped in a MultiScaleModel :\n\n mapped_variables=[:TT_cu => \"Scene\",],\n\nAt the \"Plant\" scale, the TTcu variable is mapped as a scalar from the \"Scene\" scale. There is only a single \"Scene\" node in the MTG, and only a single \"TTcu\" value per timestep for the simulation.\n\n:carbon_allocation => [\"Leaf\"]\n\nOn the other hand, we have :carbon_allocation => [\"Leaf\"] at the plant scale for ToyCAllocationModel. The carbon_assimilation variable is mapped as a vector: there are multiple \"Leaf\" nodes, but only one \"Plant\" node, which aggregrates the value over every single leaf. This gives us a 'many-to-one' vector mapping, and in the run! functions for models at that scale carbon_allocation will be available in the status as a vector.\n\n:carbon_allocation => [\"Leaf\", \"Internode\"]\n\nA third type of the mapping would be :carbon_allocation => [\"Leaf\", \"Internode\"], which provides values for a variable from several other scales simultaneously. In this case, the values are also available as a vector in the carbon_assimilation variable of the status inside the model, sorted in the same order as nodes are traversed in the graph.\n\n:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]\n\nFinally, to map to a specific variable name at the target scale, e.g. :Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]. This syntax is useful when the variable name is different between scales, and we want to map to a specific variable name at the target scale. In this example, the variable Rm_organs at plant scale takes its values (is mapped) from the variable Rm at the \"Leaf\" and \"Internode\" scales.","category":"section"},{"location":"multiscale/multiscale/#Running-a-simulation","page":"More variable mapping examples","title":"Running a simulation","text":"Now that we have a valid mapping, we can run a simulation. Running a multiscale simulation requires a plant graph and the definition of the output variables we want dynamically for each scale.","category":"section"},{"location":"multiscale/multiscale/#Plant-graph","page":"More variable mapping examples","title":"Plant graph","text":"We can import an example multi-scale tree graph like so:\n\nmtg = import_mtg_example()\n\nnote: Note\nYou can use import_mtg_example only if you previously imported the Examples sub-module of PlantSimEngine, i.e. using PlantSimEngine.Examples.\n\nThis graph has a root node that defines a scene, then a soil, and a plant with two internodes and two leaves.","category":"section"},{"location":"multiscale/multiscale/#Output-variables","page":"More variable mapping examples","title":"Output variables","text":"For long simulations on plants with many organs, the output data can be very significant. It's possible to restrict the output variables that are tracked for the whole simulation to a subset of all the variables:\n\nouts = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)\n\nThis dictionary can be passed to the simulation via the optional tracked_outputs keyword argument to the run! function (see the next part). If no dictionary is provided, every variable will be tracked.\n\nThese variables will be available in the output returned by run!, with a value for each time step. The corresponding timestep and node in the MTG are also returned. ","category":"section"},{"location":"multiscale/multiscale/#Meteorological-data","page":"More variable mapping examples","title":"Meteorological data","text":"As for mono-scale models, we need to provide meteorological data to run a simulation. We can use the PlantMeteo package to generate some dummy data for two time steps:\n\nmeteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f = 200.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f = 180.0)\n]\n)","category":"section"},{"location":"multiscale/multiscale/#Simulation","page":"More variable mapping examples","title":"Simulation","text":"Let's make a simulation using the graph and outputs we just defined:\n\noutputs_sim = run!(mtg, mapping, meteo, tracked_outputs = outs);\nnothing # hide\n\nAnd that's it! We can now access the outputs for each scale as a dictionary of vectors of NamedTuple objects.\n\nOr as a DataFrame dictionary using the DataFrames package:\n\nusing DataFrames\ndf_dict = convert_outputs(outputs_sim, DataFrame)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Quick-examples","page":"Quick examples","title":"Quick examples","text":"This page is meant for people who have set up their environment and just want to copy-paste an example or two, see what the REPL returns and start tinkering. \n\nIf you are less comfortable with Julia, or need to set up an environment first, see this page : Getting started with Julia. If you wish for a more detailed rundown of the examples, you can instead have a look at the step by step section, which will go into more detail.\n\nThese examples are all for single-scale simulations. For multi-scale modelling tutorials and examples, refer to [this section][#multiscale]\n\nYou can find the implementation for all the example models, as well as other toy models in the examples folder.\n\nPages = [\"quick_and_dirty_examples.md\"]\nDepth = 2","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Environment","page":"Quick examples","title":"Environment","text":"These examples assume you have a working Julia environment with PlantSimengine added to it, as well as the other packages used in these examples. Details for getting to that point are provided on the Installing and running PlantSimEngine page.","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Example-with-a-single-light-interception-model-and-a-single-weather-timestep","page":"Quick examples","title":"Example with a single light interception model and a single weather timestep","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout = run!(leaf, meteo)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-model-with-a-Leaf-Area-Index-model","page":"Quick examples","title":"Coupling the light interception model with a Leaf Area Index model","text":"The weather data in this example contains data over 365 days, meaning the simulation will have as many timesteps.\n\nusing PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-and-Leaf-Area-Index-models-with-a-biomass-increment-model","page":"Quick examples","title":"Coupling the light interception and Leaf Area Index models with a biomass increment model","text":"using PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/#Example-using-PlantBioPhysics","page":"Quick examples","title":"Example using PlantBioPhysics","text":"A companion package, PlantBioPhysics, uses PlantSimEngine, and contains other models used in ecophysiological simulations.\n\nYou can have a look at its documentation here\n\nSeveral example simulations are provided there. Here's one taken from this page : \n\nusing PlantBiophysics, PlantSimEngine\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        Monteith(),\n        Fvcb(),\n        Medlyn(0.03, 12.0),\n        status = (Ra_SW_f = 13.747, sky_fraction = 1.0, aPPFD = 1500.0, d = 0.03)\n    )\n\nout = run!(leaf,meteo)","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Tips-and-workarounds","page":"Tips and Workarounds","title":"Tips and workarounds","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#PlantSimEngine-is-actively-being-developed","page":"Tips and Workarounds","title":"PlantSimEngine is actively being developed","text":"PlantSimEngine, despite the somewhat abstract codebase and generic simulation ambitions, is quite grounded in reality. There IS a desire to accomodate for a wide range of possible simulations, without constraining the user too much, but most features are developed on an as-needed basis, and grow out of necessity, partly from the requirements of an increasingly complex and refined implementation of an oil palm model, XPalm.\n\nSince the oil palm model is actively being developed, and some features aren't ready in PlantSimEngine, or require a lot of rewriting that we're not certain would be worth it (especially if it ends up constraining the codebase or what the user can do), some workarounds and shortcuts are occasionally used to circumvent a limitation. \n\nThere are also a couple of features that are quick hacks or that are meant for quick and dirty prototyping, not for production. \n\nWe'll list a few of them here, and will likely add some entry in the future listing some built-in limitations or implicit expectations of the package.\n\nPages = [\"tips_and_workarounds.md\"]\nDepth = 2","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Making-use-of-past-states-in-multi-scale-simulations","page":"Tips and Workarounds","title":"Making use of past states in multi-scale simulations","text":"It is possible to make use of the value of a variable in the past simulation timestep via the PreviousTimeStep mechanism in the mapping API (In fact, as mentioned elsewhere, it is the default way to break undesirable cyclic dependencies that can come up when coupling models, see : Avoiding cyclic dependencies).\n\nHowever, it is not possible to go beyond that through the mapping API. Something like PreviousTimeStep(PreviousTimeStep(PreviousTimeStep(:carbon_biomass))) is not supported. Don't do that.\n\nOne way to access prior variable states is simply to write an ad hoc model that stores a few values into an array or however many variables you might need, which you can then update every timestep and feed into other models that might need it.","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Having-a-variable-simultaneously-as-input-and-output-of-a-model","page":"Tips and Workarounds","title":"Having a variable simultaneously as input and output of a model","text":"One current limitation of PlantSimEngine that can be occasionally awkward is that using the same variable name as input and output in a single model is unsupported. \n\n(On a related note : it is not possible to have two variables with the same name in the same scale. They are considered as the same variable.)\n\nThe reason being that it is usually impossible to automatically determine how the coupling is supposed to work out, when other dependencies latch onto such a model. The user would have to explicitely declare some order of simulation between several models, and some amount of programmer work would also be necessary to implement that extra API feature into PlantSimEngine.\n\nWe haven't found an approach that was fully satisfactory from both a code simplicity and an API convenience POV. Especially when prototyping and adding in new models, as that might require redeclaring the simulation order for those specific variables.\n\nThere are two workarounds : \n\nOne possibly awkward approach is to rename one of the variables. It is not ideal, of course, as it means you might not be able to use a predefined model 'out of the box', but it does not have any of the tradeoffs and constraints mentioned above.\nIn many other situations one can work with what PlantSimEngine already provides.\n\nFor example, one model in XPalm.jl handles leaf pruning, affecting biomass. A straightforward implementation would be to have a leaf_biomass variable as both input and output. The workaround is to instead output a variable leaf_biomass_pruning_loss and to have that as input in the next timestep to compute the new leaf biomass.\n\nPart 3 of the Toy Plant tutorial does something similar for its carbon stock. The carbon_stock variable indicates how much carbon is available for root and internode growth, but instead of updating it and passing it along after the root growth decision model decided whether or not roots should be added, that model computes a carbon_stock_updated_after_roots which is then used by the internode growth model. \n\nThis change in design avoids model order ambiguity and also improves readability, and makes sense in terms of PlantSimEngine's philosophy.","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#multiscale_vector","page":"Tips and Workarounds","title":"Multiscale : passing in a vector in a mapping status at a specific scale","text":"note: Note\nThis section is a little more advanced and not recommended for beginners\n\nYou may have noticed that sometimes a vector (1-dimensional array) variable is passed into the status component of a ModelList in documentation examples (An example here with cumulative thermal time : Model switching).\n\nThis is practical for simple simulations, or when quickly prototyping, to avoid having to write a model specifically for it. Whatever models make use of that variable are provided with one element corresponding to the current timestep every iteration.\n\nIn multi-scale simulations, this feature is also supported, though not part of the main API. The way outputs and statuses work is a little different, so that little convenience feature is not as straightforward. \n\nIt is more brittle, makes use of not-recommended Julia metaprogramming features (eval()), fiddles with global variables, might not work outside of a REPL environment and is not tested for more complex interactions, so it may interact badly with variables that are mapped to different scales or in bizarre dependency couplings.\n\nDue to, uh, implementation quirks, the way to use this is as follows : \n\nCall the function replace_mapping_status_vectors_with_generated_models(mapping_with_vectors_in_status, timestep_model_organ_level, nsteps)on your mapping.\n\nIt will parse your mapping, generate custom models to store and feed the vector values each timestep, and return the new mapping you can then use for your simulation. It also slips in a couple of internal models that provide the timestep index to these models (so note that symbols :current_timestep and :next_timestep will be declared for that mapping). You can decide which scale/organ level you want those models to be in via the timestep_model_organ_levelparameter. nsteps is used as a sanity check, and expects you to provide the amount of simulation timesteps.\n\nwarning: Warning\nOnly subtypes of AbstractVector present in statuses will be affected. In some cases, meteo values might need a small conversion. For instance : meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18) status(TT_cu=cumsum(meteo_day.TT),)cumsum(meteoday.TT) actually returns a CSV.SentinelArray.ChainedVectors{T, Vector{T}}, which is not a subtype of AbstractVector.  Replacing it with Vector(cumsum(meteoday.TT)) will provide an adequate type.\n\nHere's an example usage, fixing the first attempt at Converting a single-scale simulation to multi-scale :\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo, CSV, DataFrames\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Direct translation of the single-scale simulation\nmapping_pseudo_multiscale = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 0),)\n\n# will generate an error as vectors can't be directly passed into a Status in multi-scale simulations\n#out_pseudo_multiscale_error = run!(mtg, mapping_pseudo_multiscale, meteo_day)\n\nmapping_pseudo_multiscale_adjusted = PlantSimEngine.replace_mapping_status_vectors_with_generated_models(mapping_pseudo_multiscale, \"Plant\", PlantSimEngine.get_nsteps(meteo_day))\n\nout_pseudo_multiscale_successful = run!(mtg, mapping_pseudo_multiscale_adjusted, meteo_day)\n\n\nThis feature is likely to break in simulations that make use of planned future features (such as mixing models with different timesteps), without guarantee of a fix on a short notice. Again, bear in mind it is mostly a convenient shortcut for prototyping, when doing multi-scale simulations.","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Cyclic-dependencies-in-single-scale-simulations","page":"Tips and Workarounds","title":"Cyclic dependencies in single-scale simulations","text":"Cyclic dependencies can happen in single-scale simulations, but the PreviousTimestep feature currently isn't available. Hard dependencies are one way to deal with them, creating a multi-scale simulation with a single effective scale is also an option.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Installing-and-running-PlantSimEngine","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Pages = [\"installing_plantsimengine.md\"]\nDepth = 3\n\nThis page is meant to help along people newer to Julia. If you are quite accustomed to Julia, installing PlantSimEngine should be par for the course, and you can move on to the next section, or read about PlantSimEngine's Key Concepts.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Installing-Julia","page":"Installing and running PlantSimEngine","title":"Installing Julia","text":"The direct download link can be found here, and some additional pointers in the official manual.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Installing-VSCode","page":"Installing and running PlantSimEngine","title":"Installing VSCode","text":"You can get by using a REPL, but if writing a larger piece of software you may prefer using an IDE. PlantSimEngine is developed using VSCode, which you can install by following instruction on this page. A documentation section specific to using Julia in VSCode can be found here.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Installing-PlantSimEngine-and-its-dependencies","page":"Installing and running PlantSimEngine","title":"Installing PlantSimEngine and its dependencies","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Julia-environments","page":"Installing and running PlantSimEngine","title":"Julia environments","text":"Julia package management is done via the Pkg.jl package. You can find more in-depth sections detailing its usage, and working with Julia environments in its documentation\n\nIf you find this page insufficient to get started, this tutorial explains in detail the subtleties of Julia environments.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Running-an-environment","page":"Installing and running PlantSimEngine","title":"Running an environment","text":"Once your environment is set up, you can launch a command prompt and type julia. This will launch Julia, and you should see julia> in the command prompt.\n\nYou can always type ? from there to enter help mode, and type the name of a function or language feature you wish to know more about.\n\nYou can find out which directory you are in by typing pwd() in a Julia session.\n\nHandling environments and dependencies is done in Julia through a specific Package called Pkg, which comes with the base install. You can either call Pkg features the same way you would for another package, or enter Pkg mode by typing ], which will change the display from julia> to something like (@v1.11) pkg>, indicating your current environment (in this case, the default julia environment, which we don't recommend bloating).\n\nOnce in Pkg mode, you can choose to create an environment by typing activate path/to/environment. \n\nYou can then add packages that have been added to Julia's online global registry by typing add packagename and you can remove them by typing remove packagename. Typing status or st will indicate what your current environment is comprised of. To update packages in need of updating (a ^ symbol will display next to their name), type update… or up.\n\nIf you are editing/developing a package or using one locally, typing develop path/to/package source/ (or dev path/to/package/source) will cause your environment to use that version instead of the registered one.\n\nTyping instantiate will download all the packages declared in the manifest file (if it exists) of an environment.\n\nFor instance, PlantSimEngine has a test folder used in development. If you wanted to run tests, you would type ] then activate ../path/to/PlantSimEngine/test then instantiate and then you would be ready to run some scripts.\n\nSo if you wish to use PlantSimEngine, you can enter Pkg mode (]), choose an environment folder, then activate that environment with activate ../path/to/your_environment, add PlantSimEngine to it with add PlantSimEngine then download the package and its dependencies with instantiate.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Companion-packages","page":"Installing and running PlantSimEngine","title":"Companion packages","text":"You'll also, for most of our examples, need PlantMeteo. For several multi-scale simulations, you'll need MultiScaleTreeGraph.\n\nSome of the weather data examples make use of the CSV package, some output data is manipulated as a DataFrame, which is part of the DataFrames package.","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Using-the-example-models","page":"Installing and running PlantSimEngine","title":"Using the example models","text":"Example models are exported as a distinct submodule of PlantSimEngine, meaning they aren't part of the main API. You can use them by typing:\n\nusing PlantSimEngine.Examples","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Running-a-test-simulation","page":"Installing and running PlantSimEngine","title":"Running a test simulation","text":"Assuming you've setup you're environement, correctly added PlantMeteo and PlantSimEngine to that environment, and downloaded everything with instantiate, you'll be able to run a test example in your REPL by typing line-by-line:\n\nusing PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout_sim = run!(leaf, meteo)","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Environments-in-VSCode","page":"Installing and running PlantSimEngine","title":"Environments in VSCode","text":"There is detailed documentation explaining how to make use of Julia with VSCode with one section indicating how to handle environments in VSCode: https://www.julia-vscode.org/docs/stable/userguide/env/","category":"section"},{"location":"working_with_data/visualising_outputs/#Visualizing-outputs-and-data","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/#Output-structure","page":"Visualizing outputs and data","title":"Output structure","text":"PlantSimEngine's run! functions return for each timestep the state of the variables that were requested using the tracked_outputs kwarg (or the state of every variable if this kwarg was left unspecified). Multi-scale simulations also indicate which organ and MTG node these state variables are related to.\n\nHere's an example indicating how to plot output data using CairoMakie, a package used for plotting.\n\n# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Include the model definition from the examples folder:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nsim_outputs = run!(models, meteo_day)\n\nThe output data is displayed as a by default as a TimeStepTable. It is also possible to filter which variables are kept via the optional tracked_outputs keyword argument.","category":"section"},{"location":"working_with_data/visualising_outputs/#Plotting-outputs","page":"Visualizing outputs and data","title":"Plotting outputs","text":"Using CairoMakie, one can plot out selected variables :\n\nnote: Note\nYou will need to add CairoMakie to your environment through Pkg mode first.\n\n# Plot the results:\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, sim_outputs[:TT_cu], sim_outputs[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, sim_outputs[:TT_cu], sim_outputs[:aPPFD], color=:firebrick1)\n\nfig","category":"section"},{"location":"working_with_data/visualising_outputs/#TimeStepTables-and-DataFrames","page":"Visualizing outputs and data","title":"TimeStepTables and DataFrames","text":"The output data is usually stored in a TimeStepTable structure defined in PlantMeteo.jl, which is a fast DataFrame-like structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. Weather data is also usually stored in a TimeStepTable but with each time step being an Atmosphere.\n\nAnother simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:\n\nusing DataFrames\nsim_outputs_df = PlantSimEngine.convert_outputs(sim_outputs, DataFrame)\nsim_outputs_df[[1, 2, 3, 363, 364, 365], :]\n\nIt is also possible to create DataFrames from specific variables:\n\ndf = DataFrame(aPPFD=sim_outputs[:aPPFD][1], LAI=sim_outputs.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\n\nWhich can also be useful for Parameter fitting .","category":"section"},{"location":"multiscale/multiscale_example_2/#Expanding-on-the-multiscale-simulation","page":"Expanding the plant simulation","title":"Expanding on the multiscale simulation","text":"Let's build on the previous example and add some other organ growth, as well as some very mild coupling between the two.\n\nYou can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.\n\nPages = [\"multiscale_example_2.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_2/#Setup","page":"Expanding the plant simulation","title":"Setup","text":"Once again, with a properly set-up Julia environment:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo\nusing MultiScaleTreeGraph\nusing CSV, DataFrames\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # No inputs\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend","category":"section"},{"location":"multiscale/multiscale_example_2/#Adding-roots-to-our-plant","page":"Expanding the plant simulation","title":"Adding roots to our plant","text":"We'll add a root that extracts water and adds it to the stock. Initial water stocks are low, so root growth is prioritized, then the plant also grows leaves and a new internode like it did before. Roots only grow up to a certain point, and don't branch.\n\nThis leads to adding a new scale, \"Root\" to the mapping, as well as two more models, one for water absorption, the other for root growth. Other models are updated here and there to account for water. The carbon capture model remains unchanged, and so is the get_n_leaves helper function.","category":"section"},{"location":"multiscale/multiscale_example_2/#Root-models","page":"Expanding the plant simulation","title":"Root models","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Water-absorption","page":"Expanding the plant simulation","title":"Water absorption","text":"Let's implement a very fake model of root water absorption. It'll capture the amount of precipitation in the weather data multiplied by some assimilation factor.\n\nPlantSimEngine.@process \"water_absorption\" verbose = false\n\nstruct ToyWaterAbsorptionModel <: AbstractWater_AbsorptionModel\nend\n\nPlantSimEngine.inputs_(::ToyWaterAbsorptionModel) = (root_water_assimilation=1.0,)\nPlantSimEngine.outputs_(::ToyWaterAbsorptionModel) = (water_absorbed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyWaterAbsorptionModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_absorbed = meteo.Precipitations * status.root_water_assimilation\nend","category":"section"},{"location":"multiscale/multiscale_example_2/#Root-growth","page":"Expanding the plant simulation","title":"Root growth","text":"The root growth model is similar to the internode growth one : it checks for a water threshold and that there is enough carbon, and adds a new organ to the MTG if the maximum length hasn't been reached.\n\nIt also makes use of a couple of helper functions to find the end root and compute root length : \n\nfunction get_root_end_node(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\", filter_fun = MultiScaleTreeGraph.isleaf)\nend\n\nfunction get_roots_count(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return length(MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\"))\nend\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel{T} <: AbstractRoot_GrowthModel\n    water_threshold::T\n    carbon_root_creation_cost::T\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = (water_stock=0.0,carbon_stock=0.0,)\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        \n        root_end = get_root_end_node(status.node)\n        \n        if length(root_end) != 1 \n            throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n        end\n        root_len = get_roots_count(root_end[1])\n        if root_len < m.root_max_len\n            st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n            status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n        end\n    else\n        status.carbon_root_creation_consumed = 0.0\n    end\nend","category":"section"},{"location":"multiscale/multiscale_example_2/#Updating-other-models-to-account-for-water","page":"Expanding the plant simulation","title":"Updating other models to account for water","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Resource-storage","page":"Expanding the plant simulation","title":"Resource storage","text":"Water absorbed must now be accumulated, and root carbon creation costs taken into account.\n\nPlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(water_absorbed=0.0,carbon_captured=0.0,carbon_organ_creation_consumed=0.0,carbon_root_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (water_stock=-Inf,carbon_stock=-Inf)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_stock += sum(status.water_absorbed)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed) - sum(status.carbon_root_creation_consumed)\nend","category":"section"},{"location":"multiscale/multiscale_example_2/#Internode-creation","page":"Expanding the plant simulation","title":"Internode creation","text":"The minor change is that new organs are now created only if the water stock is above a given threshold.\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\n    water_leaf_threshold::T\nend\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0,leaves_max_surface_area=100.0,\nwater_leaf_threshold=30.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area, water_leaf_threshold)\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0,water_stock=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if water levels are low, prioritise roots\n    if status.water_stock < m.water_leaf_threshold\n        return nothing\n    end\n\n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"section"},{"location":"multiscale/multiscale_example_2/#Updating-the-mapping","page":"Expanding the plant simulation","title":"Updating the mapping","text":"The resource storage and internode emergence models now need a couple of extra water-related mapped variables.  The \"Root\" organ is added to the mapping with its own models. New parameters need to be initialized.\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>[\"Root\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:water_stock)=>\"Plant\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" => ( MultiScaleModel(\n            model=ToyRootGrowthModel(10.0, 50.0, 10),\n            mapped_variables=[PreviousTimeStep(:carbon_stock)=>\"Plant\",\n            PreviousTimeStep(:water_stock)=>\"Plant\"],\n        ),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)","category":"section"},{"location":"multiscale/multiscale_example_2/#Running-the-simulation","page":"Expanding the plant simulation","title":"Running the simulation","text":"Running this new simulation is almost the same as before. The weather data is unchanged, but a new \"Root\" node was added to the MTG.\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    plant_root_start = MultiScaleTreeGraph.Node(\n        plant, \n        MultiScaleTreeGraph.NodeMTG(\"+\", \"Root\", 1, 3), \n    )\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    \nouts = run!(mtg, mapping, meteo_day)\nmtg\n\nAnd that's it ! \n\n...Or is it ?\n\nIf you inspect the code and output data closely, you may notice some distinctive problems with the way the simulation runs... Some things aren't quite right. If you wish to know more, onwards to the next chapter: Fixing bugs in the plant simulation","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Model-implementation-additional-notes","page":"Implementing a model : additional notes","title":"Model implementation additional notes","text":"Pages = [\"implement_a_model_additional.md\"]\nDepth = 3","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Parametric-types","page":"Implementing a model : additional notes","title":"Parametric types","text":"In Implementing a model, the Beer model's structure was declared with a parametric type.\n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\nWhy not force the type ? Float64 is more accurate than Float32, after all:\n\nstruct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend\n\nDoing so would lose some flexibility in the way users can make use of your models. For example a user could use the Particles type from MonteCarloMeasurements.jl for automatic uncertainty propagation, and this is only possible if the model type is parameterizable. Forcing a Float64 type would render the model incompatible with Particles.","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Type-promotion","page":"Implementing a model : additional notes","title":"Type promotion","text":"When implementing a new model, you can do a little optional extra work to help future users.\n\nYou can add a method for type promotion. It wouldn't make any sense for the previous Beer example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:\n\nstruct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend\n\nTo add type promotion to Beer2 we would do:\n\nfunction Beer2(k,x)\n    Beer2(promote(k,x)...)\nend\n\nnote: Note\npromote returns a NamedTuple, which needs to be splatted for the constructor, see the Julia docs for a more in-depth explanation, or our Getting started with Julia page for some links to other references discussing Julia concepts used in PlantSimEngine.\n\nThis would allow users to instantiate the model parameters using different types of inputs. For example users may write the following:\n\nBeer2(0.6,2)\n\nBeer2 is a parametric type, with all fields sharing the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this forces the user to give all parameters with the same type.\n\nAnd in the example above, providin 0.6 for k, which is a Float64, and 2 for x, which is an Int. If you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were type promotion comes in handy, as it will convert all your inputs to a common type (when possible). In our case it will convert 2 to 2.0.","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Other-helper-functions-and-constructors","page":"Implementing a model : additional notes","title":"Other helper functions and constructors","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Default-parameter-values","page":"Implementing a model : additional notes","title":"Default parameter values","text":"You can simplify model usage by helping your user with default values for some parameters (if applicable). For example, in the Beer model a user will almost never change the value of k. So we can provide a default value like so:\n\nBeer() = Beer(0.6)\n\nNow the user can call Beer with no arguments, and k will default to 0.6.","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Parameter-values-as-kwargs","page":"Implementing a model : additional notes","title":"Parameter values as kwargs","text":"Another useful thing is the ability to instantiate your model type with keyword arguments, i.e. naming the arguments. You can do it by adding the following method:\n\nBeer(;k) = Beer(k)\n\nThe ; syntax indicates that subsequent arguments are provided as keyword arguments, so now we can call Beer like this:\n\nBeer(k = 0.7)\n\nThis helps readability when there are a lot of parameters and some have default values.","category":"section"},{"location":"step_by_step/implement_a_model_additional/#eltype","page":"Implementing a model : additional notes","title":"eltype","text":"The last optional utility function to implement is a method for the eltype function:\n\nBase.eltype(x::Beer{T}) where {T} = T\n\nThis one helps Julia know the type of the elements in the structure, and make it faster.","category":"section"},{"location":"step_by_step/simple_model_coupling/#Standard-model-coupling","page":"Coupling","title":"Standard model coupling","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/#Setting-up-your-environment","page":"Coupling","title":"Setting up your environment","text":"Again, make sure you have a working Julia environment with PlantSimengine added to it, and the other recommended companion packages. Details for getting to that point are provided on the Installing and running PlantSimEngine page.","category":"section"},{"location":"step_by_step/simple_model_coupling/#ModelList","page":"Coupling","title":"ModelList","text":"The ModelList is a container that holds a list of models, their parameter values, and the status of the variables associated to them.\n\nIf one looks at prior examples, the Modellists so far have only contained a single model, whose input variables are initialised in the Modellist status keyword argument. \n\nExample models are all taken from the example scripts in the examples folder.\n\nHere's a first ModelList declaration with a light interception model, requiring input Leaf Area Index (LAI): \n\nmodellist_coupling_part_1 = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\nHere's a second one with a Leaf Area Index model, with some example Cumulated Thermal Time as input. (This TT_cu is usually computed from weather data):\n\nmodellist_coupling_part_2 = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)","category":"section"},{"location":"step_by_step/simple_model_coupling/#Combining-models","page":"Coupling","title":"Combining models","text":"Suppose we want our ToyLAIModel to compute the LAI for the light interception model. \n\nWe can couple the two models by having them be part of a single ModelList. The LAI variable will then be a coupled output  computed by the ToyLAIModel, then used as input by Beer. It will no longer need to be declared as part of the [status .\n\nThis is an instance of what we call a \"soft dependency\" coupling: a model depends on another model's outputs for its inputs.\n\nHere's a first attempt : \n\nusing PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=1.0:2000.0,),\n)\nstruct UnexpectedSuccess <: Exception end #hack to enable checking an error without failing docbuild #hide\n# see https://github.com/JuliaDocs/Documenter.jl/issues/1420 #hide\ntry #hide\nrun!(models)\nthrow(UnexpectedSuccess()) #hide\ncatch err; err isa UnexpectedSuccess ? rethrow(err) : showerror(stderr, err); end  #hide\n\nOops, we get an error related to the weather data, with the detailed output being: \n\nERROR: type NamedTuple has no field Ri_PAR_f\nStacktrace:\n  [1] getindex(mnt::Atmosphere{(), Tuple{}}, i::Symbol)\n    @ PlantMeteo ~/Path/to/PlantMeteo/src/structs/atmosphere.jl:147\n  [2] getcolumn(row::PlantMeteo.TimeStepRow{Atmosphere{(), Tuple{}}}, nm::Symbol)\n    @ PlantMeteo ~/Path/to/PlantMeteo/src/structs/TimeStepTable.jl:205\n    ...\n\nThe Beer model requires a specific meteorological parameter. Let's fix that by importing the example weather data :\n\nusing PlantSimEngine\n\n# PlantMeteo and CSV packages are now used\nusing PlantMeteo, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import example weather data\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),), # We can now compute a genuine cumulative thermal time from the weather data\n)\n\n# Add the weather data to the run! call\noutputs_coupled = run!(models, meteo_day)\n\n\nAnd there you have it. The light interception model made its computations using the Leaf Area Index computed by ToyLAIModel.","category":"section"},{"location":"step_by_step/simple_model_coupling/#Further-coupling","page":"Coupling","title":"Further coupling","text":"Of course, one can keep adding models. Here's an example ModelList with another model, ToyRUEGrowthModel, which computes the carbon biomass increment caused by photosynthesis.\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"section"},{"location":"model_execution/#Model-execution","page":"Execution","title":"Model execution","text":"","category":"section"},{"location":"model_execution/#Simulation-order","page":"Execution","title":"Simulation order","text":"PlantSimEngine.jl uses the ModelList to automatically compute a dependency graph between the models and run the simulation in the correct order. When running a simulation with run!, the models are then executed following this simple set of rules:\n\nIndependent models are run first. A model is independent if it can be run independently from other models, only using initializations (or nothing).\nThen, models that have a dependency on other models are run. The first ones are the ones that depend on an independent model. Then the ones that are children of the second ones, and then their children ... until no children are found anymore. There are two types of children models (i.e. dependencies): hard and soft dependencies:\nHard dependencies are always run before soft dependencies. A hard dependency is a model that is directly called by another model. It is declared as such by its parent that lists its hard-dependencies as dep. See this example that shows Process2Model defining a hard dependency on any model that simulates process1.\nSoft dependencies are then run sequentially. A model has a soft dependency on another model if one or more of its inputs is computed by another model. If a soft dependency has several parent nodes (e.g. two different models compute two inputs of the model), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"section"},{"location":"developers/#Developer-guidelines","page":"Developer guidelines","title":"Developer guidelines","text":"This page is intended for people who wish to contribute to PlantSimEngine, and indicates the various parts to bear in mind when adding in new code.","category":"section"},{"location":"developers/#Working-on-PlantSimEngine","page":"Developer guidelines","title":"Working on PlantSimEngine","text":"Instructions are no different than for any other package. Use git to clone the repository https://github.com/VirtualPlantLab/PlantSimEngine.jl.\n\nWhen testing your changes, your environement will need to use a command such as Pkg.develop(\"PlantSimEngine\") to make use of your code.\n\nWe work with VSCode and are most comfortable with that IDE for Julia development. We mostly follow the manual's Julia style guide\n\nOnce you've made the necessary checks (see the Checklist before submitting PRs listed below), you’ll need to create your pull request and ask to be added to the contributors if you wish to submit new changes.\n\nThis documentation has a Roadmap. The list of known issues and related discussions can be found here. Some are outdated, some are discussions related to potential features, but others are genuine bugs or enhancement suggestions.\n\nOther details and questions can be posted on our issues page, or as part of your Pull Request.","category":"section"},{"location":"developers/#Quick-rundown","page":"Developer guidelines","title":"Quick rundown","text":"","category":"section"},{"location":"developers/#Testing-environments","page":"Developer guidelines","title":"Testing environments","text":"PlantSimEngine has several developer environements:\n\n/PlantSimEngine/test, to check for non-regressions\n/PlantSimEngine/test/downstream, whose folder contains a few benchmarks on PlantSimEngine, PlantBioPhysics and XPalm, run as a Github Action, to ensure changes don't cause performance regressions in packages depending on PlantSimEngine. You’ll need to have a version of those packages accessible if you wish to test them locally. Those are distinct from the Github Action that does some integration checks to ensure no unexpected breaking changes occurs.\n\n/PlantSimEngine/docs, to build the documentation. The documentation runs code, and some of the functions' documentation for the API are also tested as jldoctest instances","category":"section"},{"location":"developers/#Running-the-standard-test-suite","page":"Developer guidelines","title":"Running the standard test suite","text":"Simply execute the /PlantSimEngine/test/runtests.jl file in the test environment. Note that you'll need to start Julia with multiple threads for the multi-threading tests to successfully run.\n\nYou'll also need the companion packages PlantMeteo and MultiScaleTreeGraph, as well as other Julia packages such as DataFrames, CSV, Documenter, Test, Aqua and Tables.","category":"section"},{"location":"developers/#Downstream-tests","page":"Developer guidelines","title":"Downstream tests","text":"With XPalm and PlantBioPhysics properly instantiated, execute the /PlantSimEngine/test/downstream/test/test-all-benchmarks.jl. You may need to add some packages for the script to run locally.","category":"section"},{"location":"developers/#Building-the-documentation","page":"Developer guidelines","title":"Building the documentation","text":"In the /PlantSimEngine/docs environment, run /PlantSimEngine/docs/make.jl. It requires a couple of packages that aren't compulsory elsewhere (Documenter, CairoMakie, PlantGeom).","category":"section"},{"location":"developers/#Editing-benchmarks","page":"Developer guidelines","title":"Editing benchmarks","text":"⁃ If you wish for a branch to be benchmarked after every commit, then you need to declare it in the Github Action for benchmarks's yml file : https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/.github/workflows/benchmarksanddownstream.yml and add your branch to the on: push: section. ⁃ You can view benchmarks here: https://virtualplantlab.github.io/PlantSimEngine.jl/dev/bench/index.html. They are still somewhat WIP and not yet battle-tested. ⁃ You may occasionally need to update or delete a benchmark, in which case you will need to manually delete it in the gh-pages branch, in dev/bench/index.html ⁃ The actual benchmark list is located in the test/downstream folder.","category":"section"},{"location":"developers/#Things-to-keep-an-eye-out-for","page":"Developer guidelines","title":"Things to keep an eye out for","text":"","category":"section"},{"location":"developers/#Check-downstream-tests","page":"Developer guidelines","title":"Check downstream tests","text":"⁃ If your changes affect the API, then they might affect a package depending on PlantSimEngine. Benchmarks can be a way to check, as some benchmarks run other packages. Otherwise, a specific GitHub action, [https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/.github/workflows/Integration.yml] runs other packages’ test suites. If this action fails, then it is likely some breaking change was introduced that hasn’t been accounted for in the downstream package. If you expected a breaking change and labelled your release as such, there will be no action failure ⁃ Note that those tests don’t build the doc (iirc), so they don’t cover that. ⁃ API changes can also affect downstream packages’ documentation and tests...","category":"section"},{"location":"developers/#Which-documentation-pages-may-be-affected-by-changes","page":"Developer guidelines","title":"Which documentation pages may be affected by changes","text":"You may impact several specific documentation pages depending on what you changed. Features and API changes affect whatever they might affect, but there are some less obvious ramifications:\n\n⁃ Improving user errors may impact the Troubleshooting page. ⁃ Extra features might also expand the Tips and workarounds page, as well as the ‘implicit contracts’ page. ⁃ Some experimental features might be worth documenting in the dedicated API page, once it's added ⁃ The roadmap \"Planned features\" page needs updating ⁃ Potentially, other pages such as the Credits page, Key Concepts, etc. If the API makes use of new Julia features or syntax, the Julia basics page is probably also worth updating. ⁃ New examples are worth making doctests of.","category":"section"},{"location":"developers/#Previewing-documentation","page":"Developer guidelines","title":"Previewing documentation","text":"You can preview generated documentation (assuming it was able to build) relating to your PR (example given with #128) by checking the related link: https://virtualplantlab.github.io/PlantSimEngine.jl/previews/PR128/","category":"section"},{"location":"developers/#Checklist-before-submitting-PRs","page":"Developer guidelines","title":"Checklist before submitting PRs","text":"⁃ Ensure your code, uh, works ⁃ Ensure your major changes are covered by some tests, and new features are documented ⁃ Run the PlantSimEngine test suite locally and check errors ⁃ Check on Github which issues it affects, and update/comment those issues, or link them to your Pull Request ⁃ Check which doc page changes are needed (roadmap, … see further up), and update those ⁃ Build the PSE doc and update whatever doc tests were broken ⁃ Push your commit, and let the Github Actions run their course ⁃ Check the 'CI' GitHub action and fix if necessary ⁃ Check downstream and benchmark GitHub actions:     - If benchmarks tanked, then fix your code. If you need to add/update/delete benchmarks, do so.     - If you broke an integration/downstream test, you’ll need to investigate it     - If API changes were made, also check downstream packages’ documentation\n\nIt’s probably now safe to request a merge.","category":"section"},{"location":"developers/#A-few-extra-things-worth-doing","page":"Developer guidelines","title":"A few extra things worth doing","text":"⁃ You may have some new known issues, some remaining TODOs, document those somewhere, whether in the PR comments or in their own issue, make sure some trace remains ⁃ Finally, update this page and this checklist: If a doc page is added, it may be part of the list of pages you need to keep an eye on. If proper memory allocation tracking and type stability checking is implemented, then that’ll need to be added to the list of things to check prior to a release, etc.","category":"section"},{"location":"developers/#Other-helpful-things","page":"Developer guidelines","title":"Other helpful things","text":"⁃ In the /PlantSimEngine/test folder, there are a few basic helper functions. One of them outputs vectors of modellists, weather data, and output variables, which are used as a test bank/matrix for some tests, and provides wide coverage. If you wrote new models, new combinations of models, or added some new weather data, it helps to add them to the banks. ⁃ New downstream packages are worth adding to the integration and downstream package registry. ⁃ Unusual corner-cases are worth giving their own unit tests. Newly fixed bugs as well, even if the fix is fairly trivial.","category":"section"},{"location":"developers/#Noteworthy-aspects-of-the-codebase","page":"Developer guidelines","title":"Noteworthy aspects of the codebase","text":"","category":"section"},{"location":"developers/#Automatic-model-generation","page":"Developer guidelines","title":"Automatic model generation","text":"A specific feature requires generating models on the fly, to enable passing vectors to Status objects in multi-scale simulations. There may be more features that wish to generate models.\n\nThe solution makes use of a somewhat brittle feature, eval(), with some subtleties. You can read more about the related world age problem here, or here.\n\nThe related file is model_generation_from_status_vectors.jl, which has some additional comments.\n\nWhat is important to bear in mind, is that if you call functions which generate models via eval(), you will need to return to top-level scope for those changes to become visible. You can see an example in tests/helper_functions.jl with the functions test_filtered_output_begin and test_filtered_output. The first function calls modellist_to_mapping, which creates some models on the fly to convert status vectors between a ModelList and its equivalent pseudo-multiscale mapping. The function is split in two so that it is possible to return to global scope and make the eval() changes publicly available. The second function then is able to run the simulations on the mapping with its generated models, and complete the test successfully.\n\nThe errors returned by an eval()-related issue are very specific, and indicate that a generated model with an UUID suffix does not exist in the Main module, or something along those lines.\n\nThere may be a better approach that avoids those pitfalls, but that's what we have for now. Be cautious when calling functions from that file, and make sure to look out for comments indicating a function was split into two.","category":"section"},{"location":"developers/#Weather/timestep/status-combinations","page":"Developer guidelines","title":"Weather/timestep/status combinations","text":"Not all combinations of weather data structure/weather dataset size/status sizes combinations are tested in PlantSimEngine itself. Some are tested in PlantBioPhysics and XPalm. It'd be good to have those structures tested in PSE in the future, but for now it is highly recommended checking those packages' tests when changing the API.","category":"section"},{"location":"developers/#Test-banks","page":"Developer guidelines","title":"Test banks","text":"They were briefly mentioned earlier in the page, but the test banks to increase the number of combinations tested for in terms of weather data, modellists/mappings and tracked outputs, could definitely be improved upon.\n\nSome additional work and tests regarding tracking memory allocations, type stability etc. would also be worth implementing/documenting.","category":"section"},{"location":"multiscale/multiscale_coupling/#Handling-dependencies-in-a-multiscale-context","page":"Multiscale coupling considerations","title":"Handling dependencies in a multiscale context","text":"Pages = [\"multiscale_coupling.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_coupling/#Scalar-and-vector-variable-mappings","page":"Multiscale coupling considerations","title":"Scalar and vector variable mappings","text":"In the detailed example discussed previously Multi-scale variable mapping, there were several instances of mapping a variable from one scale to another, which we'll briefly describe again to help transition to the next and more advanced subsection. Here's a relevant exerpt from the mapping : \n\n\"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        ...\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        ...\n    ),\n\nFor flexibility reasons, instead of explicitely linking most models from different scales together, one only declares which variables are meant to be taken from another scale (or more accurately, a model at a different scale outputting those variables). This keeps the convenience of switching models while making few changes to the mapping. \n\nHowever, PlantSimEngine cannot infer which scales have multiple instances, and which are single-instance, as the scale names are user-defined.\n\nIn the above example, there is only one scene at the \"Scene\", and one plant at the \"Plant\" scale, meaning the TT_cu variable mapped between the two has a one-to-one scalar-to-scalar correspondance.\n\nOn the other hand, the carbon_assimilation variable is computed for every leaf, of which there could be hundreds, or thousands, giving a scalar-to-vector correspondance. The carbon assimilation model runs many times every timestep, whereas the carbon allocation model only runs once per timestep. There may be initially be only a single leaf, though, meaning PlantSimEngine cannot currently guess from the initial configuration that there might be multiple leaves created during the simulation.\n\nHence the difference in mapping declaration :  TT_cuis declared as a scalar correspondence : \n\n:TT_cu => \"Scene\",\n\nwhereas carbon_assimilation (and other variables) will be declared as a vector correspondence :\n\n:carbon_assimilation => [\"Leaf\"],\n\nNote that there may be instances where you might wish to write your own model to aggregate a variable from a multi-instance scale.","category":"section"},{"location":"multiscale/multiscale_coupling/#Hard-dependencies-between-models-at-different-scale-levels","page":"Multiscale coupling considerations","title":"Hard dependencies between models at different scale levels","text":"If a model requires some input variable that is computed at another scale, then providing the appropriate mapping for that variable will resolve name conflicts and enable that model to run with no further steps for the user or the modeler when the coupling is a 'soft dependency'.\n\nIn the case of a hard dependency that operates at the same scale as its parent, declaring the hard dependency is exactly the same as in single-scale simulations and there are also no new extra steps on the user-side:\n\nThe parent model directly handles the call to its hard dependency model(s), meaning they are not explicitely managed by the top-level dependency graph.\nThis means only the owning model of that dependency is visible in the graph, and its hard dependency nodes are internal.\nWhen the caller (or any downstream model that requires some variables from the hard dependency model) operates at the same scale, variables are easily accessible, and no mapping is required. \n\nOn the other hand, modelers do need to bear in mind a couple of subtleties when developing models that possess hard dependencies that operate at a different organ level from their parent: \n\nIf an model needs to be directly called by a parent but operates at a different scale/organ level, a modeler must declare hard dependencies with their respective organ level, similarly to the way the user provides a mapping. \n\nConceptually :\n\n PlantSimEngine.dep(m::ParentModel) = (\n    name_provided_in_the_mapping=AbstractHardDependencyModel => [\"Organ_Name_1\",],\n)","category":"section"},{"location":"multiscale/multiscale_coupling/#An-example-from-the-toy-plant-simulation-tutorial","page":"Multiscale coupling considerations","title":"An example from the toy plant simulation tutorial","text":"You can find an example of a hard dependency discussed in the A multi-scale hard dependency appears subsection of the third part of toy plant tutorial.","category":"section"},{"location":"multiscale/multiscale_coupling/#An-example-from-XPalm.jl","page":"Multiscale coupling considerations","title":"An example from XPalm.jl","text":"Here's a concrete example in XPalm, an oil palm model developed on top of PlantSimEngine.   Organs are produced at the phytomer scale, but need to run an age model and a biomass model at the reproductive organs' scales.\n\n PlantSimEngine.dep(m::ReproductiveOrganEmission) = (\n    initiation_age=AbstractInitiation_AgeModel => [m.male_symbol, m.female_symbol],\n    final_potential_biomass=AbstractFinal_Potential_BiomassModel => [m.male_symbol, m.female_symbol],\n)\n\nThe user-mapping includes the required models at specific organ levels. Here's the relevant portion of the mapping for the male reproductive organ :\n\nmapping = Dict(\n    ...\n    \"Male\" =>\n    MultiScaleModel(\n        model=XPalm.InitiationAgeFromPlantAge(),\n        mapped_variables=[:plant_age => \"Plant\",],\n    ),\n    ...\n    XPalm.MaleFinalPotentialBiomass(\n        p.parameters[:male][:male_max_biomass],\n        p.parameters[:male][:age_mature_male],\n        p.parameters[:male][:fraction_biomass_first_male],\n    ),\n    ...\n)\n\nThe model's constructor provides convenient default names for the scale corresponding to the reproductive organs. A user may override that if their naming schemes or MTG attributes differ.\n\nfunction ReproductiveOrganEmission(mtg::MultiScaleTreeGraph.Node; phytomer_symbol=\"Phytomer\", male_symbol=\"Male\", female_symbol=\"Female\")\n    ...\nend","category":"section"},{"location":"multiscale/multiscale_coupling/#Implementation-details:-accessing-a-hard-dependency's-variables-from-a-different-scale","page":"Multiscale coupling considerations","title":"Implementation details: accessing a hard dependency's variables from a different scale","text":"But how does a model M calling a hard dependency H provide H's variables when calling H's run! function ? The status argument the user provides M operates at M's organ level, so if used to call H's run! function any required variable for H will be missing.    \n\nPlantSimEngine provides what are called Status Templates in the simulation graph. Each organ level has its own Status template listing the available variables at that scale. So when a model M calls a hard dependency H's run! function, any required variables can be accessed through the status template of H's organ level.","category":"section"},{"location":"multiscale/multiscale_coupling/#Back-to-the-XPalm-example","page":"Multiscale coupling considerations","title":"Back to the XPalm example","text":"Using the same example in XPalm, the oil palm FSPM: \n\n# Note that the function's 'status' parameter does NOT contain the variables required by the hard dependencies as the calling model's organ level is \"Phytomer\", not \"Male\" or \"Female\"\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n    ...\n    status.graph_node_count += 1\n\n    # Create the new organ as a child of the phytomer:\n    st_repro_organ = add_organ!(\n        status.node[1], # The phytomer's internode is its first child \n        sim_object,  # The simulation object, so we can add the new status \n        \"+\", status.sex, 4;\n        index=status.phytomer_count,\n        id=status.graph_node_count,\n        attributes=Dict{Symbol,Any}()\n    )\n\n    # Compute the initiation age of the organ:\n    PlantSimEngine.run!(sim_object.models[status.sex].initiation_age, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\n    PlantSimEngine.run!(sim_object.models[status.sex].final_potential_biomass, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\nend\n\nIn the above example the organ and its status template are created on the fly. When that isn't the case, the status template can be accessed through the simulation graph :\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n\n    ...\n\n    if status.sex == \"Male\"\n\n        status_male = sim_object.statuses[\"Male\"][1]\n        run!(sim_object.models[\"Male\"].initiation_age, models, status_male, meteo, constants, sim_object)\n        run!(sim_object.models[\"Male\"].final_potential_biomass, models, status_male, meteo, constants, sim_object)\n    else\n        # Female\n        ...\n    end\nend","category":"section"},{"location":"troubleshooting_and_testing/downstream_tests/#Automated-tests-:-downstream-dependency-checking","page":"Automated testing","title":"Automated tests : downstream dependency checking","text":"PlantSimEngine is open sourced on Github, and so are its other companion packages, PlantGeom.jl, PlantMeteo.jl, PlantBioPhysics.jl, MultiScaleTreeGraph.jl, and XPalm.\n\nOne handy CI (Continuous Integration) feature implemented for these packages is automated integration and downstream testing: after changes to a package, its known downstream dependencies are tested to ensure no breaking changes were introduced. \n\nFor instance, PlantBioPhysics uses PlantSimEngine, so an integration test ensures that PlantBioPhysics's tests don't break in an unforeseen manner after a new PlantSimEngine release. There also is a benchmark check in the downstream tests: [https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/test/downstream/test-plantbiophysics.jl]\n\nThis is something you can take advantage of if you wish to develop using PlantSimEngine, by providing us with your package name (or adding it to the CI yml file in a Pull Request); we can then add it to the list of downstream packages to test, and generate PR when breaking changes are introduced.","category":"section"},{"location":"step_by_step/advanced_coupling/#Coupling-more-complex-models","page":"Advanced coupling and hard dependencies","title":"Coupling more complex models","text":"When two or more models have a two-way interdependency (rather than variables flowing out only one-way from one model into the next), we describe it as a hard dependency.\n\nThis kind of interdependency requires a little more work from the user/modeler for PlantSimEngine to be able to automatically create the dependency graph.","category":"section"},{"location":"step_by_step/advanced_coupling/#Declaring-hard-dependencies","page":"Advanced coupling and hard dependencies","title":"Declaring hard dependencies","text":"A model that explicitly and directly calls another process in its run! function is part of a hard dependency, or a hard-coupled model. \n\nLet's go through the example processes and models from a script provided by the package here examples/dummy.jl\n\nIn this script, we declare seven processes and seven models, one for each process. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model...\n\nWhen run, Process2Model calls another process's run! function explicitely, which requires defining that process as a hard-dependency of Process2Model :\n\nfunction PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # computing var3 using process1:\n    run!(models.process1, models, status, meteo, constants)\n    # computing var4 and var5:\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend\n\nProcess2Model is coupled to another process (process1), and calls its model's run function. The run! function is called with the same arguments as the run! function of the model that calls it, except that we pass the process we want to simulate as the first argument.\n\nnote: Note\nWe don't enforce any type of model to simulate process1. This is the reason why we can switch so easily between model implementations for any process, by just changing the model in the ModelList.\n\nA hard-dependency must always be declared to PlantSimEngine. This is done by adding a method to the dep function when implementing the model. For example, the hard-dependency to process1 into Process2Model is declared as follows:\n\nPlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)\n\nThis way PlantSimEngine knows that Process2Model needs a model for the simulation of the process1 process. To avoid imposing a specific model to be coupled with Process2Model, the dependency only requires a model that is a subtype of the abstract parent type AbstractProcess1Model. This avoids constraining to the specific Process1Model implementation, meaning an alternate model computing the same variables for the same process is still interchangeable with Process1Model.\n\nWhile not encouraged, if you have a valid reason to force the coupling with a particular model, you can force the dependency to require that model specifically. For example, if we want to use only Process1Model for the simulation of process1, we would declare the dependency as follows:\n\nPlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)\n\n## Examples in the wild\n\nYou can find a typical example in a companion package: PlantBioPhysics.jl. An energy balance model, the Monteith model, needs to iteratively run a photosynthesis model in its run! function.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Troubleshooting-error-messages","page":"Troubleshooting","title":"Troubleshooting error messages","text":"PlantSimEngine attempts to be as comfortable and easy to use as possible for the user, and many kinds of user error will be caught and explanations provided to resolve them, but there are still blind spots, as well as syntax errors that will often generate a Julia error (which can be less intuitive to decrypt) rather than a PlantSimEngine error.\n\nTo help people newer to Julia with troubleshooting, here are a few common 'easy-to-make' mistakes with the current API that might not be obvious to interpret, and pointers on how to fix them.\n\nThey are listed by 'nature of error', rather than by error message, so you may need to search the page to find your specific error.\n\nIf you need more help to decode Julia errors, you can find help on the Julia Discourse forums. If you need some advice on the FSPM side, the research community has its own discourse forum.\n\nIf the issue seems PlantSimEngine-related, or you have questions regarding modeling or have suggestions, you can also file an issue on Github.\n\nPages = [\"plantsimengine_and_julia_troubleshooting.md\"]\nDepth = 3","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Tips-and-workflow","page":"Troubleshooting","title":"Tips and workflow","text":"Some errors are very specific as to their cause, and the PlantSimEngine errors tend to be explicit about which parameter / variable / organ is causing the error, helping narrow down its origin.\n\nSome generic-looking errors usually do contain some extra information to help focus the debugging hunt. For instance, a dispatch failure on run! caused by some issue with args/kwargs may highlight explicitely indicate which arguments are currently causing conflict. In VSCode, such arguments are highlighted in red (the first and last arguments in the example below) : \n\na = 1\nrun!(a, simple_mtg, mapping, meteo_day, a)\n\nERROR: MethodError: no method matching run!(::Int64, ::Node{NodeMTG, Dict{…}}, ::Dict{String, Tuple{…}}, ::DataFrame, ::Int64)\nThe function [`run!`](@ref) exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyPlantLeafSurfaceModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ PlantSimEngine /PlantSimEngine/examples/ToyLeafSurfaceModel.jl:75\n   ...\n\nIf you wish to search for a specific error in the current page, copy the part of the description that is not specific to your script, and Ctrl+F it here. In the above example, the generic part would be : \n\nERROR: MethodError: no method matching","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Common-Julia-errors","page":"Troubleshooting","title":"Common Julia errors","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#NamedTuples-with-a-single-value-require-a-comma-:","page":"Troubleshooting","title":"NamedTuples with a single value require a comma :","text":"This one is easy to miss.\n\nEmpty NamedTuple objects are initialised with x = NamedTuple(). Ones with more than one variable can be initialised like this : \n\na = (var1 = 0, var2 = 0)\n\nor like this : \n\na = (var1 = 0, var2 = 0,)\n\nThe second comma being optional.\n\nHowever, if there is only a single variable, notation has to be : \n\na = (var1 = 0,)\n\nThe comma is compulsory. If it is forgotten : \n\na = (var1 = 0)\n\nthe line will be interpreted as setting the variable a to the value var1 is set to, hence a will be an Int64 of value 0.\n\nThis is a liability when writing custom models as some functions work with NamedTuples : \n\nfunction PlantSimEngine.inputs_(::HardDepSameScaleAvalModel)\n    (e2 = -Inf,)\nend\n\nThe error returned will likely be a Julia error along the lines of : \n\n[ERROR: MethodError: no method matching merge(::Float64, ::@NamedTuple{g::Float64})\n\nClosest candidates are:\nmerge(::NamedTuple{()}, ::NamedTuple)\n@ Base namedtuple.jl:337\nmerge(::NamedTuple{an}, ::NamedTuple{bn}) where {an, bn}\n@ Base namedtuple.jl:324\nmerge(::NamedTuple, ::NamedTuple, NamedTuple...)\n@ Base namedtuple.jl:343\n\nStacktrace:\n[1] variables_multiscale(node::PlantSimEngine.HardDependencyNode{…}, organ::String, vars_mapping::Dict{…}, st::@NamedTuple{})\n...\n\nIt is sometimes properly detected and explained on PlantSimEngine's side (when passing in tracked_outputs, for instance), but may also occur when declaring statuses.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Incorrectly-declaring-empty-inputs-or-outputs","page":"Troubleshooting","title":"Incorrectly declaring empty inputs or outputs","text":"The syntax for an empty NamedTuple is NamedTuple(). If instead one types () or (,)an error returned respectively by PlantSimEngine or Julia will be returned.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#PlantSimEngine-user-errors","page":"Troubleshooting","title":"PlantSimEngine user errors","text":"Most of the following errors occur exclusively in multi-scale simulations, which has a slightly more complex API, but some are common to both single- and multi-scale simulations.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Implementing-a-model:-forgetting-to-import-or-prefix-functions","page":"Troubleshooting","title":"Implementing a model: forgetting to import or prefix functions","text":"When implementing a model, you need to make sure that your implementation is correctly recognised as extending PlantSimEngine methods and types, and not writing new independent ones.\n\nIn the following working toy model implementation, note that the inputs_, outputs_ and run! function are all prefixed with the module name. If there were hard dependencies to manage, the dep function would also be identically prefixed.\n\nusing PlantSimEngine\n@process \"toy\" verbose = false\n\nstruct ToyToyModel{T} <: AbstractToyModel \n    internal_constant::T\nend\n\nfunction PlantSimEngine.inputs_(::ToyToyModel)\n    (a = -Inf, b = -Inf, c = -Inf)\nend\n\nfunction PlantSimEngine.outputs_(::ToyToyModel)\n    (d = -Inf, e = -Inf)\nend\n\n\nfunction PlantSimEngine.run!(m::ToyToyModel, models, status, meteo, constants=nothing, extra_args=nothing)\n    status.d = m.internal_constant * status.a \n    status.e += m.internal_constant\nend\n\nmeteo = Weather([\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=18.0, Wind=1.0, Rh=0.65, Ri_PAR_f=100.0),\n])\n\nmodel = ModelList(\n    ToyToyModel(1),\n   status = ( a = 1, b = 0, c = 0),\n)\nto_initialize(model) \nsim = PlantSimEngine.run!(model, meteo)\n\nIf you declare these functions without importing them first, or prefixing them with the module name, they will be considered to be part of your current environment, and won't be extending PlantSimEngine methods, which means PlantSimEngine will not be able to properly make use of your functions, and simulations are likely to error, or run incorrectly.\n\nForgetting to prefix the run! function definition gives the following error : \n\nERROR: MethodError: no method matching run!(::ModelList{@NamedTuple{…}, Status{…}}, ::TimeStepTable{Atmosphere{…}})\nThe function [`run!`](@ref) exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyToyModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ Main ~/path/to/file.jl:20\n\nForgetting to prefix the inputs_or outputs_ functions for your model might not always generate an error, depending on whether the variables declared in this function are present in your ModelList or mapping's corresponding Status.\n\nIn cases where they do throw an error, you may get the following kind of output:\n\nERROR: type NamedTuple has no field d\nStacktrace:\n [1] setproperty!(mnt::Status{(:a, :b, :c), Tuple{…}}, s::Symbol, x::Int64)\n   @ PlantSimEngine ~/path/to/package/PlantSimEngine/src/component_models/Status.jl:100\n [2] run!(m::ToyToyModel{…}, models::@NamedTuple{…}, status::Status{…}, meteo::PlantMeteo.TimeStepRow{…}, constants::Constants{…}, extra_args::Nothing)\n ...\n\nnote: Note\nThere may be more we can do on our end in the future to make the issue more obvious, but in the meantime it is safest to consistently prefix the methods you need to declare and call with PlantSimEngine., or to explicitely import the functions you wish to extend, e.g.: import PlantSimEngine: inputs_, outputs_.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#MultiScaleModel-:-forgetting-a-kwarg-in-the-declaration","page":"Troubleshooting","title":"MultiScaleModel : forgetting a kwarg in the declaration","text":"A MultiScaleModel requires two kwargs, model and mapped_variables : \n\nmodels = MultiScaleModel(\n        model=ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )\n\nForgetting 'model=' :\n\nmodels = MultiScaleModel(\n        ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )\nERROR: MethodError: no method matching MultiScaleModel(::ToyLAIModel; mapped_variables::Vector{Pair{Symbol, String}})\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n    \nClosest candidates are:\n    MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"mapped_variables\"\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:188\n    MultiScaleModel(; model, mapped_variables)\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n\nForgetting 'mapped_variables=' :\n\nmodels = MultiScaleModel(\n        model=ToyLAIModel(),\n        [:TT_cu => \"Scene\",],\n    )\n\nERROR: MethodError: no method matching MultiScaleModel(::Vector{Pair{Symbol, String}}; model::ToyLAIModel)\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  MultiScaleModel(; model, mapping)\n   @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n  MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"model\"\n\nThe message 'got unsupported keyword argument \"model\"' can be misleading, as in the error in this case is not that a kwarg is unsupported, but rather that a keyword argument is missing.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#MultiScaleModel-:-variable-not-defined-in-Module","page":"Troubleshooting","title":"MultiScaleModel : variable not defined in Module","text":"A possible cause for this error is that a variable was declared instead of a symbol in a mapping for a multiscale model :\n\nmapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables = [should_be_symbol => \"Other_Scale\"] # should_be_symbol is a variable, likely not found in the current module \n),\n...\n),\n\nHere's the correct version : \n\nmapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables=[:should_be_symbol => \"Other_Scale\"] # should_be_symbol is now a symbol\n),\n...\n),","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Kwarg-and-arg-parameter-issues-when-calling-run!","page":"Troubleshooting","title":"Kwarg and arg parameter issues when calling run!","text":"There are, unfortunately, multiple ways of passing in arguments to the run! functions that will confuse dynamic dispatch. Some of it is due to imperfections in type declarations on PlantSimEngine's end and may be improved upon in the future. \n\nHere are a few examples when modifying the usual multiscale run! call in this working example : \n\n    meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\n    var1 = 15.0\n\n    mapping = Dict(\n        \"Leaf\" => (\n            Process1Model(1.0),\n            Process2Model(),\n            Process3Model(),\n            Status(var1=var1,)\n        )\n    )\n\n    outs = Dict(\n        \"Leaf\" => (:var1,), # :non_existing_variable is not computed by any model\n    )\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\nThe exact signature is this : \n\nfunction run!(\n    object::MultiScaleTreeGraph.Node,\n    mapping::Dict{String,T} where {T},\n    meteo=nothing,\n    constants=PlantMeteo.Constants(),\n    extra=nothing;\n    nsteps=nothing,\n    tracked_outputs=nothing,\n    check=true,\n    executor=ThreadedEx()\n\nArguments after the mtg and mapping all have a default value and are optional, and arguments after the ';' delimiter are kwargs and need to be named.\n\nIf one forgets the mtg, a flaw in the way run! is defined will lead to this error :\n\nrun!(mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching check_dimensions(::PlantSimEngine.TableAlike, ::Tuple{…}, ::DataFrame)\nThe function `check_dimensions` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  check_dimensions(::Any, ::Any)\n   @ PlantSimEngine PlantSimEngine/src/checks/dimensions.jl:43\n ...\n\nIf one forgets the necessary 'tracked_outputs=' in the definition, outs will be interpreted as the 'extra' arg instead of a kwarg. 'extra' usually defaults to nothing, and is reserved in multiscale mode, leading to the following error :\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), outs)\n\nERROR: Extra parameters are not allowed for the simulation of an MTG (already used for statuses).\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] run!(::PlantSimEngine.TreeAlike, object::PlantSimEngine.GraphSimulation{…}, meteo::DataFrames.DataFrameRows{…}, constants::Constants{…}, extra::Dict{…}; tracked_outputs::Nothing, check::Bool, executor::ThreadedEx{…})\n\nIn case of a more generic error that returns a  For example, if one does the opposite and adds a non-existent kwarg, the generic dispatch failure has some more specific information :  got unsupported keyword argument \"constants\"\n\nrun!(mtg, mapping, meteo_day, constants=PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching run!(::Node{…}, ::Dict{…}, ::DataFrame, ::Dict{…}, ::Nothing; constants::Constants{…})\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\nClosest candidates are:\n  run!(::Node, ::Dict{String}, ::Any, ::Any, ::Any; nsteps, tracked_outputs, check, executor) got unsupported keyword argument \"constants\"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Hard-dependency-process-not-present-in-the-mapping","page":"Troubleshooting","title":"Hard dependency process not present in the mapping","text":"Another weakness in the current error checking leads to an unclear Julia error if a model A is present in a mapping and has a hard dependency on a model B, but B is absent from the mapping.\n\nIn the following example, A corresponds to Process3Model, which requires a model B implementing 'Process2Model' and referred to as 'process2'.  Looking at the source code for Process3Model, the hard dependency is declared here : \n\nPlantSimEngine.dep(::Process3Model) = (process2=Process2Model,)\n\nHowever, the model provided in the examples, Process2Model is absent from the mapping :\n\nsimple_mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))    \nmapping = Dict(\n    \"Leaf\" => (\n        Process3Model(),\n        Status(var5=15.0,)\n    )\n)\nouts = Dict(\n    \"Leaf\" => (:var5,),\n)\nrun!(simple_mtg, mapping, meteo_day, tracked_outputs=outs)\n\nERROR: type NamedTuple has no field process2\nStacktrace:\n [1] getproperty(x::@NamedTuple{process3::Process3Model}, f::Symbol)\n   @ Base ./Base.jl:49\n [2] run!(::Process3Model, models::@NamedTuple{…}, status::Status{…}, meteo::DataFrameRow{…}, constants::Constants{…}, extra::PlantSimEngine.GraphSimulation{…})\n ...\n\nThe fix is to add Process2Model() -or another model for the same process- to the mapping.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Status-API-ambiguity","page":"Troubleshooting","title":"Status API ambiguity","text":"One current problem with PlantSimEngine's API is that declaring a simulation's Status or Statuses differs between single- and multi-scale.\n\nReturning to the example in Implementing a model: forgetting to import or prefix functions, the ModelList status was declared like this:\n\nmodel = ModelList(\n    ToyToyModel(1),\n   status = ( a = 1, b = 0, c = 0),\n)\n\nIf instead you replace status = ...with the multi-scale declaration: Status(...), you will get the following error:\n\nERROR: MethodError: no method matching process(::Status{(:a, :b, :c), Tuple{Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}}})\nThe function `process` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  process(::Pair{Symbol, A}) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:16\n  process(::A) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:13\n\nStacktrace:\n [1] (::PlantSimEngine.var\"#5#6\")(i::Status{(:a, :b, :c), Tuple{Base.RefValue{…}, Base.RefValue{…}, Base.RefValue{…}}})\n   @ PlantSimEngine ./none:0\n [2] iterate\n\nIf you do the opposite in a multi-scale simulation by replacing the necessary Status(...) with status = ..., you may get an ERROR: syntax: invalid named tuple element error. Here's some output when tinkering with the Toy Plant tutorial's mapping:\n\nERROR: syntax: invalid named tuple element \"MultiScaleModel(...)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\n\nor \n\nERROR: syntax: invalid named tuple element \"ToyRootGrowthModel(50, 10)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Forgetting-to-declare-a-scale-in-the-mapping-but-having-variables-point-to-it","page":"Troubleshooting","title":"Forgetting to declare a scale in the mapping but having variables point to it","text":"If there is a need to collect variables at two different scales, and one scale is completely absent from the mapping, the error currently occurs on the Julia side :\n\n# No models at the E3 scale in the mapping !\n\n\"E2\" => (\n        MultiScaleModel(\n        model = HardDepSameScaleEchelle2Model(),\n        mapped_variables=[:c => \"E1\" => :c, :e3 => \"E3\" => :e3, :f3 => \"E3\" => :f3,], \n        ),\n    ),\n\nException has occurred: KeyError\n*\nKeyError: key \"E3\" not found\nStacktrace:\n[1] hard_dependencies(mapping::Dict{String, Tuple{Any, Any}}; verbose::Bool)\n@ PlantSimEngine ......./src/dependencies/hard_dependencies.jl:175\n...","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Parenthesis-placement-when-declaring-a-mapping","page":"Troubleshooting","title":"Parenthesis placement when declaring a mapping","text":"An unintuitive error encountered in the past when defining a mapping : \n\nERROR: ArgumentError: AbstractDict(kv): kv needs to be an iterator of 2-tuples or pairs\n\nmay occur when forgetting the parenthesis after '=>' in a mapping declaration, and combining it with another parenthesis error.\n\nmapping = Dict( \"Scale\" => (ToyAssimGrowthModel(0.0, 0.0, 0.0), ToyCAllocationModel(), Status( TT_cu=Vector(cumsum(meteo_day.TT))), ), )\n\nOther errors such as : \n\nERROR: MethodError: no method matching Dict(::Pair{String, ToyAssimGrowthModel{Float64}}, ::ToyCAllocationModel, ::Status{(:TT_cu,), Tuple{Base.RefValue{…}}})\nThe type `Dict` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Dict(::Pair{K, V}...) where {K, V}\n\noften indicate a likely syntax error somewhere in the mapping definition.","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Empty-status-vectors-in-multi-scale-simulations","page":"Troubleshooting","title":"Empty status vectors in multi-scale simulations","text":"This situation won't trigger an error. Unexpectedly empty vectors can be returned as outputs if you happen to forget to a node at the corresponding scale in the MTG, and no organ creation occurs for that node.\n\nHere's an example taken from the Converting a single-scale simulation to multi-scale page. It was modified by removing the \"Plant\" node in the dummy MTG passed into the run!function. Without that \"Plant\" node, only \"Scene\"-scale models can run initially, and since no nodes are created, \"Plant\"-scale models will never be run.\n\nPlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=-Inf,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n#plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\nout_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)\n\nout_multiscale[\"Plant\"][:LAI]\n\nIn the above code, uncommenting the second line will add a \"Plant\" node to the MTG, and the simulation will then behave as intuitively expected.","category":"section"},{"location":"FAQ/translate_a_model/#I-want-to-use-PlantSimEngine-for-my-model","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If you already have a model, you can easily use PlantSimEngine to couple it with other models with minor adjustments.","category":"section"},{"location":"FAQ/translate_a_model/#Toy-LAI-Model","page":"I want to use PlantSimEngine for my model","title":"Toy LAI Model","text":"","category":"section"},{"location":"FAQ/translate_a_model/#Model-description","page":"I want to use PlantSimEngine for my model","title":"Model description","text":"Let's take an example with a simple LAI model that we define below:\n\n\"\"\"\nSimulate leaf area index (LAI, m² m⁻²) for a crop based on the amount of degree-days since sowing with a simple double-logistic function.\n\n# Arguments\n\n- `TT_cu`: degree-days since sowing\n- `max_lai=8`: Maximum value for LAI\n- `dd_incslope=500`: degree-days at which we get the maximal increase in LAI\n- `inc_slope=5`: slope of the increasing part of the LAI curve\n- `dd_decslope=1000`: degree-days at which we get the maximal decrease in LAI\n- `dec_slope=2`: slope of the decreasing part of the LAI curve\n\"\"\"\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\nThis model takes the number of days since sowing as input and returns the simulated LAI. We can plot the simulated LAI for a year:\n\nusing CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"section"},{"location":"FAQ/translate_a_model/#Changes-for-PlantSimEngine","page":"I want to use PlantSimEngine for my model","title":"Changes for PlantSimEngine","text":"The model can be implemented using PlantSimEngine as follows:","category":"section"},{"location":"FAQ/translate_a_model/#Define-a-process","page":"I want to use PlantSimEngine for my model","title":"Define a process","text":"If the process of LAI dynamic is not implemented yet, we can define it like so:\n\n@process LAI_Dynamic","category":"section"},{"location":"FAQ/translate_a_model/#Define-the-model","page":"I want to use PlantSimEngine for my model","title":"Define the model","text":"We have to define a structure for our model that will contain the parameters of the model:\n\nstruct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend\n\nWe can also define default values for the parameters by defining a method with keyword arguments:\n\nToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)\n\nThis way users can create a model with default parameters just by calling ToyLAIModel(), or they can specify only the parameters they want to change, e.g. ToyLAIModel(inc_slope=80.0)","category":"section"},{"location":"FAQ/translate_a_model/#Define-inputs-/-outputs","page":"I want to use PlantSimEngine for my model","title":"Define inputs / outputs","text":"Then we can define the inputs and outputs of the model, and the default value at initialization:\n\nPlantSimEngine.inputs_(::ToyLAIModel) = (TT_cu=-Inf,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)\n\nnote: Note\nNote that we use -Inf for the default value, it is the recommended value for Float64 (-999 for Int), as it is a valid value for this type, and is easy to catch in the outputs if not properly set because it propagates nicely. You can also use NaN instead.","category":"section"},{"location":"FAQ/translate_a_model/#Define-the-model-function","page":"I want to use PlantSimEngine for my model","title":"Define the model function","text":"Finally, we can define the model function that will be called at each time step:\n\nfunction PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.TT_cu) / model.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.TT_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend\n\nnote: Note\nNote that we don't return the value of the LAI in the definition of the function. This is because we rather update its value in the status directly. The status is a structure that efficiently stores the state of the model at each time step, and it contains all variables either declared as inputs or outputs of the model. This way, we can access the value of the LAI at any time step by calling status.LAI.\n\nnote: Note\nThe function is defined for one time step only, and is called at each time step automatically by PlantSimEngine. This means that we don't have to loop over the time steps in the function.","category":"section"},{"location":"FAQ/translate_a_model/#defining_the_meteo","page":"I want to use PlantSimEngine for my model","title":"Running a simulation","text":"Now that we have everything set up, we can run a simulation. The first step here is to define the weather:\n\n# Import the packages we need:\nusing PlantMeteo, Dates, DataFrames\n\n# Define the period of the simulation:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# Get the weather data for CIRAD's site in Montpellier, France:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# Compute the degree-days with a base temperature of 10°C:\nmeteo.TT = max.(meteo.T .- 10.0, 0.0)\n\n# Aggregate the weather data to daily values:\nmeteo_day = to_daily(meteo, :TT => (x -> sum(x) / 24) => :TT)\n\nThen we can define our list of models, passing the values for TT_cu in the status at initialization:\n\nm = ModelList(\n    ToyLAIModel(),\n    status = (TT_cu = cumsum(meteo_day.TT),),\n)\n\noutputs_sim = run!(m)\n\nlines(outputs_sim[:TT_cu], outputs_sim[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"section"},{"location":"planned_features/#Roadmap","page":"Planned features","title":"Roadmap","text":"","category":"section"},{"location":"planned_features/#Planned-major-features","page":"Planned features","title":"Planned major features","text":"","category":"section"},{"location":"planned_features/#Varying-timesteps","page":"Planned features","title":"Varying timesteps","text":"Currently, all models are required to make use of the same timestep. Some physiological phenomenae within a plant tend to run on an hourly basis, others are slower. Weather data is often provided daily. Enabling different timesteps depending on the model is on the roadmap, and is planned as the next milestone.","category":"section"},{"location":"planned_features/#Multi-plant/Multi-species-simulations","page":"Planned features","title":"Multi-plant/Multi-species simulations","text":"A goal for PlantSimEngine down the line is to be able to simulate complex scenes with data comprising several plants, possibly of different species, for agroforestry purposes.\n\nIts current state doesn't enable practical declaration of several plant species, or multiple plants relying on similar subsets of models with partially different models or parameters.","category":"section"},{"location":"planned_features/#Minor-features","page":"Planned features","title":"Minor features","text":"Implement a trait or a prepass that checks whether weather data is needed, and if so, if it is properly provided to a simulation\nBetter dependency graph visualization and information printing","category":"section"},{"location":"planned_features/#Minor-planned-improvements-and-QOL-features","page":"Planned features","title":"Minor planned improvements and QOL features","text":"A reworked and more consistent mapping API, and multiscale dependency declaration\nImproved user errors\nMore examples\nBetter dependency graph traversal functions\nEnsure cyclic dependency checking and PreviousTimestep is active for ModelLists","category":"section"},{"location":"planned_features/#Improvements-on-the-testing-side","page":"Planned features","title":"Improvements on the testing side","text":"Better tracking of memory usage and type stability\nWorking CI/Downstream tests\nstate machine checker, validating output invariants\ngraph fuzzing for improved corner-case testing","category":"section"},{"location":"planned_features/#Possible-features-(likely-not-a-priority)","page":"Planned features","title":"Possible features (likely not a priority)","text":"API enabling iterative builds and validation of mappings and ModelLists\nBuild step for the models, i.e. a function that would write a mapping or ModelList into a Julia script for validation, improved readability and (maybe) performance (no need to traverse the dependency graph anymore).\nImproved parallelisation\nReintroduce multi-object parallelisation in single-scale","category":"section"},{"location":"planned_features/#Other-minor-points","page":"Planned features","title":"Other minor points","text":"Examples/solutions for floating-point accumulation errors\nMore examples for fitting/type conversion/error propagation\nMTG couple of new features #106\nOther minor bugs\nUnrolling the run! function","category":"section"},{"location":"planned_features/#Other","page":"Planned features","title":"Other","text":"Reproducing another FSPM?\nDiffusion model example?\n\nThe full list of issues can be found here","category":"section"},{"location":"step_by_step/parallelization/#Parallel-execution","page":"Parallelization","title":"Parallel execution","text":"note: Note\nThis page is likely to change and become outdated. In any case, parallel execution only currently applies to single-scale simulations (multi-scale simulations' changing MTGs and extra complexity don't allow for straightforward parallelisation)","category":"section"},{"location":"step_by_step/parallelization/#FLoops","page":"Parallelization","title":"FLoops","text":"PlantSimEngine.jl uses the Floops package to run the simulation in sequential, parallel (multi-threaded) or distributed (multi-process) computations over objects, time-steps and independent processes. \n\nThat means that you can provide any compatible executor to the executor argument of run!. By default, run! uses the ThreadedEx executor, which is a multi-threaded executor. You can also use the SequentialExfor sequential execution (non-parallel), or DistributedEx for distributed computations.","category":"section"},{"location":"step_by_step/parallelization/#Parallel-traits","page":"Parallelization","title":"Parallel traits","text":"PlantSimEngine.jl uses Holy traits to define if a model can be run in parallel.\n\nnote: Note\nA model is executable in parallel over time-steps if it does not uses or set values from other time-steps, and over objects if it does not uses or set values from other objects.\n\nYou can define a model as executable in parallel by defining the traits for time-steps and objects. For example, the ToyLAIModel model from the examples folder can be run in parallel over time-steps and objects, so it defines the following traits:\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsObjectIndependent()\n\nBy default all models are considered not executable in parallel, because it is the safest option to avoid bugs that are difficult to catch, so you only need to define these traits if it is executable in parallel for them.\n\ntip: Tip\nA model that is defined executable in parallel will not necessarily will. First, the user has to pass a parallel executor to run! (e.g. ThreadedEx). Second, if the model is coupled with another model that is not executable in parallel, PlantSimEngine will run all models in sequential.","category":"section"},{"location":"step_by_step/parallelization/#Further-executors","page":"Parallelization","title":"Further executors","text":"You can also take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nFinally, you can take a look into Transducers.jl's documentation for more information, for example if you don't know what is an executor, you can look into this explanation.","category":"section"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF","page":"Reducing DoF","title":"Reducing the DoF","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Introduction","page":"Reducing DoF","title":"Introduction","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Why-reduce-the-degrees-of-freedom","page":"Reducing DoF","title":"Why reduce the degrees of freedom","text":"Reducing the degrees of freedom in a model, by forcing certain variables to measurements, can be useful for several reasons:\n\nIt can prevent overfitting by constraining the model and making it less complex.\nIt can help to better calibrate the other components of the model by reducing the co-variability of the variables (see Parameter degeneracy).\nIt can lead to more interpretable models by identifying the most important variables and relationships.\nIt can improve the computational efficiency of the model by reducing the number of variables that need to be estimated.\nIt can also help to ensure that the model is consistent with known physical or observational constraints and improve the credibility of the model and its predictions.\nIt is important to note that over-constraining a model can also lead to poor fits and false conclusions, so it is essential to carefully consider which variables to constrain and to what measurements.","category":"section"},{"location":"working_with_data/reducing_dof/#Parameter-degeneracy","page":"Reducing DoF","title":"Parameter degeneracy","text":"The concept of \"degeneracy\" or \"parameter degeneracy\" in a model occurs when two or more variables in a model are highly correlated, and small changes in one variable can be compensated by small changes in another variable, so that the overall predictions of the model remain unchanged. Degeneracy can make it difficult to estimate the true values of the variables and to determine the unique solutions of the model. It also makes the model sensitive to the initial conditions (e.g. the parameters) and the optimization algorithm used.\n\nDegeneracy is related to the concept of \"co-variability\" or \"collinearity\", which refers to the degree of linear relationship between two or more variables. In a degenerate model, two or more variables are highly co-variate, meaning that they are highly correlated and can produce similar predictions. By fixing one variable to a measured value, the model will have less flexibility to adjust the other variables, which can help to reduce the co-variability and improve the robustness of the model.\n\nThis is an important topic in plant/crop modelling, as the models are very often degenerate. It is most often referred to as \"multicollinearity\" in the field. In the context of model calibration, it is also known as \"parameter degeneracy\" or \"parameter collinearity\". In the context of model reduction, it is also known as \"redundancy\" or \"redundant variables\".","category":"section"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF-in-PlantSimEngine","page":"Reducing DoF","title":"Reducing the DoF in PlantSimEngine","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Soft-coupled-models","page":"Reducing DoF","title":"Soft-coupled models","text":"PlantSimEngine provides a simple way to reduce the degrees of freedom in a model by constraining the values of some variables to measurements.\n\nLet's define a model list as usual with the seven processes from examples/dummy.jl:\n\nusing PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)\n\nLet's say that m is our complete model, and that we want to reduce the degrees of freedom by constraining the value of var9 to a measurement, which was previously computed by Process7Model, a soft-dependency model. It is very easy to do this in PlantSimEngine: just remove the model from the model list and give the value of the measurement in the status:\n\nm2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nout = run!(m2, meteo)\n\nAnd that's it ! The models that depend on var9 will now use the measured value of var9 instead of the one computed by Process7Model.","category":"section"},{"location":"working_with_data/reducing_dof/#Hard-coupled-models","page":"Reducing DoF","title":"Hard-coupled models","text":"It is a bit more complicated to reduce the degrees of freedom in a model that is hard-coupled to another model, because it calls the run! method of the other model.\n\nIn this case, we need to replace the old model with a new model that forces the value of the variable to the measurement. This is done by giving the measurements as inputs of the new model, and returning nothing so the value is unchanged. \n\nStarting from the model list with the seven processes from above, but this time let's say that we want to reduce the degrees of freedom by constraining the value of var3 to a measurement, which was previously computed by Process1Model, a hard-dependency model. It is very easy to do this in PlantSimEngine: just replace the model by a new model that forces the value of var3 to the measurement:\n\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend\n\nNow we can create a new model list with the new model for process7:\n\nm3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nout = run!(m3, meteo)\n\nnote: Note\nWe could also eventually provide the measured variable using the meteo data, but it is not recommended. The meteo data is meant to be used for the meteo variables only, and not for the model variables. It is better to use the status for that.","category":"section"},{"location":"API/API_public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"API/API_public/#Index","page":"Public API","title":"Index","text":"Pages = [\"API_public.md\"]","category":"section"},{"location":"API/API_public/#API-documentation","page":"Public API","title":"API documentation","text":"","category":"section"},{"location":"API/API_public/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"Public API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.AbstractModel","page":"Public API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.ModelList","page":"Public API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> outputs_sim = run!(models,meteo)\nTimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):\n╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮\n│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │\n╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯\n\njulia> outputs_sim[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.MultiScaleModel","page":"Public API","title":"PlantSimEngine.MultiScaleModel","text":"MultiScaleModel(model, mapped_variables)\n\nA structure to make a model multi-scale. It defines a mapping between the variables of a  model and the nodes symbols from which the values are taken from.\n\nArguments\n\nmodel<:AbstractModel: the model to make multi-scale\nmapped_variables<:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}: a vector of pairs of symbols and strings or vectors of strings\n\nThe mapped_variables argument can be of the form:\n\n[:variable_name => \"Plant\"]: We take one value from the Plant node\n[:variable_name => [\"Leaf\"]]: We take a vector of values from the Leaf nodes\n[:variable_name => [\"Leaf\", \"Internode\"]]: We take a vector of values from the Leaf and Internode nodes\n[:variable_name => \"Plant\" => :variable_name_in_plant_scale]: We take one value from another variable name in the Plant node\n[:variable_name => [\"Leaf\" => :variable_name_1, \"Internode\" => :variable_name_2]]: We take a vector of values from the Leaf and Internode nodes with different names\n[PreviousTimeStep(:variable_name) => ...]: We flag the variable to be initialized with the value from the previous time step, and we do not use it to build the dep graph\n[:variable_name => :variable_name_from_another_model]: We take the value from another model at the same scale but rename it\n[PreviousTimeStep(:variable_name),]: We just flag the variable as a PreviousTimeStep to not use it to build the dep graph\n\nDetails about the different forms:\n\nThe variable variable_name of the model will be taken from the Plant node, assuming only one node has the Plant symbol.\n\nIn this case the value available from the status will be a scalar, and so the user must guaranty that only one node of type Plant is available in the MTG.\n\nThe variable variable_name of the model will be taken from the Leaf nodes. Notice it is given as a vector, indicating that the values will be taken \n\nfrom all the nodes of type Leaf. The model should be able to handle a vector of values. Note that even if there is only one node of type Leaf, the value will be taken as a vector of one element.\n\nThe variable variable_name of the model will be taken from the Leaf and Internode nodes. The values will be taken from all the nodes of type Leaf \n\nand Internode.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_in_plant_scale in the Plant node. This is useful\n\nwhen the variable name in the model is different from the variable name in the scale it is taken from.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_1 in the Leaf node and variable_name_2 in the Internode node.\nThe variable variable_name of the model uses the value computed on the previous time-step. This implies that the variable is not used to build the dependency graph\n\nbecause the dependency graph only applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe variable variable_name of the model will be taken from another model at the same scale, but with another variable name.\nThe variable variable_name of the model is just flagged as a PreviousTimeStep variable, so it is not used to build the dependency graph.\n\nNote that the mapping does not make any copy of the values, it only references them. This means that if the values are updated in the status of one node, they will be updated in the other nodes.\n\nExamples\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\nLet's take a model:\n\njulia> model = ToyCAllocationModel()\nToyCAllocationModel()\n\nWe can make it multi-scale by defining a mapping between the variables of the model and the nodes symbols from which the values are taken from:\n\nFor example, if the carbon_allocation comes from the Leaf and Internode nodes, we can define the mapping as follows:\n\njulia> mapped_variables=[:carbon_allocation => [\"Leaf\", \"Internode\"]]\n1-element Vector{Pair{Symbol, Vector{String}}}:\n :carbon_allocation => [\"Leaf\", \"Internode\"]\n\nThe mappedvariables argument is a vector of pairs of symbols and strings or vectors of strings. In this case, we have only one pair to define the mapping between the `carbonallocationvariable and theLeafandInternode` nodes.\n\nWe can now make the model multi-scale by passing the model and the mapped variables to the MultiScaleModel constructor :\n\njulia> multiscale_model = PlantSimEngine.MultiScaleModel(model, mapped_variables)\nMultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]])\n\nWe can access the mapped variables and the model:\n\njulia> PlantSimEngine.mapped_variables_(multiscale_model)\n1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:\n :carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]\n\njulia> PlantSimEngine.model_(multiscale_model)\nToyCAllocationModel()\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.PreviousTimeStep","page":"Public API","title":"PlantSimEngine.PreviousTimeStep","text":"PreviousTimeStep(variable)\n\nA structure to manually flag a variable in a model to use the value computed on the previous time-step.  This implies that the variable is not used to build the dependency graph because the dependency graph only  applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe process is added when building the MultiScaleModel, to avoid conflicts between processes with the same variable name. For exemple one process can define a variable :carbon_biomass as a PreviousTimeStep, but the othe process would use  the variable as a dependency for the current time-step (and it would be fine because theyr don't share the same issue of cyclic dependency).\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Status","page":"Public API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> using PlantSimEngine\n\njulia> st = PlantSimEngine.Status(Ra_SW_f=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Ra_SW_f]\n13.747\n\njulia> st.Ra_SW_f\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Ra_SW_f] = 20.0\n20.0\n\njulia> st.Ra_SW_f = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.EF-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}","page":"Public API","title":"PlantSimEngine.add_organ!","text":"add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)\n\nAdd an organ to the graph, automatically taking care of initialising the status of the organ (multiscale-)variables.\n\nThis function should be called from a model that implements organ emergence, for example in function of thermal time.\n\nArguments\n\nnode: the node to which the organ is added (the parent organ of the new organ)\nsim_object: the simulation object, e.g. the GraphSimulation object from the extra argument of a model.\nlink: the link type between the new node and the organ:\n\"<\": the new node is following the parent organ\n\"+\": the new node is branching the parent organ\n\"/\": the new node is decomposing the parent organ, i.e. we change scale\nsymbol: the symbol of the organ, e.g. \"Leaf\"\nscale: the scale of the organ, e.g. 2.\nindex: the index of the organ, e.g. 1. The index may be used to easily identify branching order, or growth unit index on the axis. It is different from the node id that is unique.\nid: the unique id of the new node. If not provided, a new id is generated.\nattributes: the attributes of the new node. If not provided, an empty dictionary is used.\ncheck: a boolean indicating if variables initialisation should be checked. Passed to init_node_status!.\n\nReturns\n\nstatus: the status of the new node\n\nExamples\n\nSee the ToyInternodeEmergence example model from the Examples module (also found in the examples folder), or the test-mtg-dynamic.jl test file for an example usage.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.dep","page":"Public API","title":"PlantSimEngine.dep","text":"dep(m::ModelList)\ndep(mapping::Dict{String,T}; verbose=true)\ndep!(m::ModelList, nsteps=1)\n\nGet the model dependency graph given a ModelList or a multiscale model mapping. If one graph is returned,  then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph. It is set to 1 in the case of a  multiscale mapping.\n\nDetails\n\nThe dependency graph is computed by searching the inputs of each process in the outputs of its own scale, or the other scales. There are five cases for every model (one model simulates one process):\n\nThe process has no inputs. It is completely independent, and is placed as one of the roots of the dependency graph.\nThe process needs inputs from models at its own scale. We put it as a child of this other process.\nThe process needs inputs from another scale. We put it as a child of this process at another scale.\nThe process needs inputs from its own scale and another scale. We put it as a child of both.\nThe process is a hard dependency of another process (only possible at the same scale). In this case, the process is set as a hard-dependency of the \n\nother process, and its simulation is handled directly from this process.\n\nFor the 4th case, the process have two parent processes. This is OK because the process will only be computed once during simulation as we check if both  parents were run before running the process. \n\nNote that in the 5th case, we still need to check if a variable is needed from another scale. In this case, the parent node is  used as a child of the process at the other scale. Note there can be several levels of hard dependency graph, so this is done recursively.\n\nHow do we do all that? We identify the hard dependencies first. Then we link the inputs/outputs of the hard dependencies roots  to other scales if needed. Then we transform all these nodes into soft dependencies, that we put into a Dict of Scale => Dict(process => SoftDependencyNode). Then we traverse all these and we set nodes that need outputs from other nodes as inputs as children/parents. If a node has no dependency, it is set as a root node and pushed into a new Dict (independantprocessroot). This Dict is the returned dependency graph. And  it presents root nodes as independent starting points for the sub-graphs, which are the models that are coupled together. We can then traverse each of  these graphs independently to r\n\nNotes\n\nThe difference between dep(m::ModelList) and dep!(m::ModelList, nsteps) is that the first one returns the dependency graph found in the model list, while the  second one returns the dependency graph with the specified number of steps, modifying the simulation IDs of each node in the graph (simulation_id=fill(0, nsteps)).\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nmodels = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;models...)\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.dr-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.fit","page":"Public API","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/Beer.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.aPPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of aPPFD, LAI  and Ri_PAR_f. \n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the aPPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated aPPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"Public API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(mapping::Dict{String,T})\n\nGet the inputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"Public API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(mapping::Dict{String,T})\n\nGet the outputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.run!","page":"Public API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\nrun!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or a plant graph (MTG).\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters, not available for simulation of plant graphs (the simulation object is passed using this).\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nmapping: a mapping between the MTG and the model list.\nnsteps: the number of time-steps to run, only needed if no meteo is given (else it is infered from it).\noutputs: the outputs to get in dynamic for each node type of the MTG.\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nUsers can ask for parallel execution by providing a compatible executor to the executor argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the Examples sub-module:\n\njulia> using PlantSimEngine.Examples;\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> outputs_sim = run!(models, meteo);\n\nGet the results:\n\njulia> (outputs_sim[:var4],outputs_sim[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.status-Tuple{Any}","page":"Public API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including example models and processes:\nusing PlantSimEngine.Examples;\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"Public API","title":"PlantSimEngine.to_initialize","text":"to_initialize(; verbose=true, vars...)\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\nto_initialize(mapping::Dict{String,T}, graph=nothing)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nArguments\n\nverbose: if true, print information messages.\nvars...: the models and processes to consider.\nm::T: a ModelList.\nm::DependencyGraph: a DependencyGraph.\nmapping::Dict{String,T}: a mapping that associates models to organs.\ngraph: a graph representing a plant or a scene, e.g. a multiscale tree graph. The graph is used to check if variables that are not initialized can be found in the graph nodes attributes.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\nto_initialize(m)\n\nOr with a mapping:\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmapping = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"Internode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\nto_initialize(mapping)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Tuple{Module}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.variables","text":"variables(mapping::Dict{String,T})\n\nGet the variables (inputs and outputs) of the models in a mapping, for each  process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"Public API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nNewcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of AbstractModel:\n\nabstract type MyNewProcess <: AbstractModel end\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"multiscale/multiscale_example_4/#Visualizing-a-plant-using-PlantGeom","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing a plant using PlantGeom","text":"We've created our toy plant, part of the fun is to actually visualize it !\n\nLet's see how to do so with the PlantGeom companion package.\n\nWe'll be reusing the mtg from part 3 of the plant tutorial: Fixing bugs in the plant simulation, so you need to run that simulation first, or to include the script file into your current code (which is what we'll do here):\n\nusing PlantSimEngine\nusing MultiScaleTreeGraph\nusing PlantSimEngine.Examples\nusing Pkg\nPkg.add(\"CSV\")\nusing CSV\ninclude(\"ToyPlantSimulation3.jl\")\n\nYou'll need to add PlantGeom and a compatible visualization package to your environment. We'll use Plots:\n\nusing Plots\nusing PlantGeom\n\nThat's enough to get a nicer display of the MTG than the console-based printing. You'll only need to type the following line:\n\nRecipesBase.plot(mtg)\n\nThis provides the following visualization: (Image: MTG Plots visualization)\n\nAnd that's it !\n\nWe can see the root expansion in one direction, and the internodes with their leaves in the other.\n\nOf course, that's good and all, but going beyond that would be nice. \n\nPlantGeom is able to render geometry from what it finds in the MTG. If a node in the tree graph has a :geometry attribute with a mesh and a transformation, it can make use of that to build a plant. That mesh can be unique per node, or based on a reference mesh that is copied and transformed for every node.\n\nnote: Note\nThis page simply aims to illustrate PlantGeom's features and doesn't aim for a particularly realistic or aesthetic look. A little randomness could go a long way to make the plant look a little more life-like, but would also be very ad-hoc and make the code less clear.\n\nOur MTG doesn't have any such attribute, so we'll need to iterate on our nodes, provide them with a mesh and calculate appropriate transformations. We'll use one reference mesh for each plant-related scale, Internode, Root and Leaf. \n\nWe'll make use of some of the Meshes primitives and transformations, as well as some helper functions from the packages TransformsBase and Rotations. For leaves, we'll read a .ply file using the PlyIO package, which contains a very unrealistic leaf + petiole mesh.\n\nWe'll also make our plant opposite decussate: leaves come in pairs, and pairs are rotated by 90 degrees along the stem.\n\nThe function that'll provide the geometry to the node is:\n\nPlantGeom.Geometry(; ref_mesh<:RefMesh, transformation=Identity(), dUp=1.0, dDwn=1.0, mesh::Union{SimpleMesh,Nothing}=nothing)\n\nWe only care about the first two parameters in our case, and we can use a simple cylinder for each node of our single Internode stem and single Root.\n\nusing PlantGeom.Meshes\n\n# Internodes and roots will use a cylinder as a mesh\n\ncylinder() = Meshes.CylinderSurface(1.0) |> Meshes.discretize |> Meshes.simplexify\n\nrefmesh_internode = PlantGeom.RefMesh(\"Internode\", cylinder())\nrefmesh_root = PlantGeom.RefMesh(\"Root\", cylinder())\n\nA simple function to read the vertices and faces from the .ply file for our leaves:\n\nPkg.add(\"PlyIO\")\nusing PlyIO\nfunction read_ply(fname)\n    ply = PlyIO.load_ply(fname)\n    x = ply[\"vertex\"][\"x\"]\n    y = ply[\"vertex\"][\"y\"]\n    z = ply[\"vertex\"][\"z\"]  \n    points = Meshes.Point.(x, y, z)\n    connec = [Meshes.connect(Tuple(c .+ 1)) for c in ply[\"face\"][\"vertex_indices\"]]\n    Meshes.SimpleMesh(points, connec)\nend\n\nleaf_ply = read_ply(\"examples/leaf_with_petiole.ply\")\nrefmesh_leaf = PlantGeom.RefMesh(\"Leaf\", leaf_ply)\n\nPkg.add(\"TransformsBase\")\nPkg.add(\"Rotations\")\nimport TransformsBase: →\nimport Rotations: RotY, RotZ, RotX\n\nnote: Note\nWe'll use X, Y, Z as standard cartersian coordinate axes, with Z pointing upwards. \n\nWe can then write the function that adds the geometry to our MTG.\n\nIt traverses the MTG, starting from the base, and adds a transformation for each encountered node.\n\nThe following just operates on internodes, for clarity:\n\n# Add the geometry to the MTG, with transformations\nfunction add_geometry!(mtg, refmesh_internode) \n    \n    # incremental offset\n    internode_height = 0.0\n\n    # relative scale of the base mesh\n    internode_width = 0.5\n\n    # length of the base mesh\n    internode_length = 1.0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # Set to scale, then translate by the total height\n            mesh_transformation = Meshes.Scale(internode_width, internode_width, internode_length) → Meshes.Translate(0.0, 0.0, internode_height)\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_internode, transformation=mesh_transformation)\n            \n            internode_height += node_length\n        end\n    end\nend\n\nWe simply need to choose a given width for our stem, and increment the height to place our next internode at as we traverse it. \n\nNote that the default cylinder provided by Meshes.jl points upwards, which is why there is no need for rotation. Roots function likewise, but are simply translated down, and need to start below the origin.\n\nWe can visualize this simple stem, using GLMakie as a rendering backend:\n\nadd_geometry!(mtg, refmesh_internode)\n\n# Visualize the mesh\nusing GLMakie\nviz(mtg)\n\n(Image: Toy Plant - stem only)\n\nOn the other hand, the leaf mesh will need to be rotated, but it is aligned along the X axis, so there is no need for an initial reorientation (which would have been required if it was pointing upwards like the cylinders). The petiole starts at the origin, so on top of translating them to leaf height we also need to translate them away from the Z axis by the internode radius. The mesh also needs to be scaled, as it is only 0.1 unit lengths long compared to our 0.5-width internode.\n\nLet's also rotate our leaves so that they point upwards slightly.\n\nIf you make use of other meshes, bear in mind the initial starting translation, orientation and scale. You may need to test and calibrate scales and transformations before you get it right.\n\nThe full code that generates geometry for all the organs of our toy plant is the following:\n\n# Add the geometry to the MTG, with transformations\nfunction add_geometry!(mtg, refmesh_internode, refmesh_root, refmesh_leaf) \n    \n    # incremental offset\n    internode_height = 0.0\n    root_depth = 0.0\n\n    # relative scale of the base mesh (base cylinder is of height 1 and radius 1)\n    internode_width = 0.5\n    root_width = 0.2\n\n    # length of the base mesh\n    internode_length = 1.0\n    root_length = 1.0\n\n    # ad hoc value to adjust the leaf mesh to the scene scale\n    leaf_mesh_scale = 25\n\n    leaf_scale_width = 0.4*leaf_mesh_scale\n    leaf_scale_height = 0.4*leaf_mesh_scale\n    \n    # Helpers to make the leaves opposite decussate\n    leaf_rotation = MathConstants.pi / 2.0\n    i = 0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # Set to scale, then translate by the total height\n            mesh_transformation = Meshes.Scale(internode_width, internode_width, internode_length) → Meshes.Translate(0.0, 0.0, internode_height)\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_internode, transformation=mesh_transformation)\n            \n            internode_height += internode_length\n\n            # Leaves are placed relatively to the parent internode, halfway along it\n            for chnode in children(node)               \n                if symbol(chnode) == \"Leaf\" \n                    mesh_transformation = Meshes.Scale(leaf_scale_width, leaf_scale_width, leaf_scale_height) → Meshes.Rotate(RotX(-MathConstants.pi / 6.0)) → Meshes.Translate(0.0, -internode_width, internode_height - internode_length / 2.0) → Meshes.Rotate(RotZ(leaf_rotation))\n                    chnode.geometry = PlantGeom.Geometry(ref_mesh=refmesh_leaf, transformation=mesh_transformation)\n                    # Set the second leaf in a pair opposite to the first one => add a 180° rotation\n                    leaf_rotation += MathConstants.pi\n                end                \n            end\n\n            # Opposite decussate => 90° rotation between pairs\n            i += 1\n            if i % 2 == 0\n                leaf_rotation = MathConstants.pi / 2.0\n            else\n                leaf_rotation = MathConstants.pi\n            end\n\n        elseif symbol(node) == \"Root\"\n            mesh_transformation = Meshes.Scale(root_width, root_width, root_length) → Meshes.Translate(0.0, 0.0, root_depth) → Meshes.Rotate(RotZ(MathConstants.pi))\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_root, transformation=mesh_transformation)\n            root_depth -= root_length\n        end\n    end\nend\n\nAnd now, let's visualize our fully-grown, fully-featured plant:\n\n# Visualize the mesh\nusing GLMakie\nviz(mtg)    \n\nWhich gives us the following image scene:\n\n(Image: Toy Plant with root and leaves)\n\nFeel free to try and make this plant prettier, more colourful, or more physically realistic, using more realistic models on the PlantSimEngine side, or better geometry on the Plantgeom end.","category":"section"},{"location":"step_by_step/detailed_first_example/#detailed-walkthrough-of-a-simple-simulation","page":"Detailed first simulation","title":"Detailed walkthrough of a simple simulation","text":"This page walks you through the ins and outs of a basic simulation, mostly aimed at people who have less experience programming, to showcase the various concepts presented earlier and requirements for a simulation in context.\n\nA working trimmed-down script can be found further down in the Example simulation, and other subsections in this page will detail setup and helper functions, and querying outputs.\n\nIf you simply wish to copy-paste examples and tinker with them, you can find a few examples on the Quick examples page.\n\nPages = [\"detailed_first_example.md\"]\nDepth = 3","category":"section"},{"location":"step_by_step/detailed_first_example/#Setting-up-your-environment","page":"Detailed first simulation","title":"Setting up your environment","text":"For every script in this documentation, you will always need a working Julia environment with PlantSimengine added to it, and usually several other companion packages. Details for getting to that point are provided on the Installing and running PlantSimEngine page.","category":"section"},{"location":"step_by_step/detailed_first_example/#Definitions","page":"Detailed first simulation","title":"Definitions","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/#Processes","page":"Detailed first simulation","title":"Processes","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.\n\nA process is \"declared\", meaning we define a process, and then implement models for its simulation. In this example, we will make use of a process that was already defined, and for which there already is a model implementation.","category":"section"},{"location":"step_by_step/detailed_first_example/#Models-(ModelList)","page":"Detailed first simulation","title":"Models (ModelList)","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/Beer.jl.\n\nModels can use several types of entries:\n\nParameters\nMeteorological information\nVariables\nConstants\nExtras\n\nParameters are constant values that are used by the model to compute its outputs, and are exclusive to that model. \n\nMeteorological information contains values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. \n\nVariables are either used or computed by the model and can optionally be initialized before the simulation. They can be part of multiple models, computed by one and then used as an input by another. They can also be a global simulation output, or be provided at the start of a simulation by the user. \n\nConstants are constant values, usually common between models, e.g. the universal gas constant. \n\nAnd extras are just extra values that can be used by a model, or serves as a placeholder for internal data.\n\nUsers declare a set of models used for simulation, as well as the necessary parameters for each model, and whatever variables need to be initialized. This is done using a ModelList structure. \n\nFor example let's instantiate a ModelList with a single model : the Beer-Lambert model of light extinction, used to simulate the light interception process. The model is implemented with the Beer structure and only has one parameter: the extinction coefficient (k).\n\nImporting the package:\n\nusing PlantSimEngine\n\nImport the examples defined in the Examples sub-module (light_interception and Beer):\n\nusing PlantSimEngine.Examples\n\nAnd then declare a ModelList with the Beer model:\n\nm = ModelList(Beer(0.5))\n\nWhat happened here? We provided an instance of the Beer model to a ModelList to simulate the light interception process.","category":"section"},{"location":"step_by_step/detailed_first_example/#Parameters","page":"Detailed first simulation","title":"Parameters","text":"A parameter is a value constant for a simulation that is internal to a model and used for its computations. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer structure in the Beer-Lambert model implementation,  only has one field: k. We can see that using fieldnames on the model structure:\n\nfieldnames(Beer)","category":"section"},{"location":"step_by_step/detailed_first_example/#Variables-(inputs,-outputs)","page":"Detailed first simulation","title":"Variables (inputs, outputs)","text":"Variables are either inputs or outputs (i.e. computed) of models. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.\n\nFor example, the Beer model needs the leaf area index (LAI, m² m⁻²) to run.\n\nWe can see which variables are passed in as inputs using inputs:\n\ninputs(Beer(0.5))\n\nand which are computed outputs of the model using outputs:\n\noutputs(Beer(0.5))\n\nThe ModelList structure will keep track of every variable's current state when running the simulation, storing them in a field called status. We can inspect that field with the status function and see that in our example it has two variables: LAI and PPFD. The first is an input, the second an output (i.e. it is computed by the model).\n\nm = ModelList(Beer(0.5))\nkeys(status(m))\n\nTo know which variables should be initialized, we can use to_initialize:\n\nm = ModelList(Beer(0.5))\nto_initialize(m)\n\nTheir values are uninitialized though (hence the warnings):\n\n(m[:LAI], m[:aPPFD])\n\nUninitialized variables are initialized to the value given in the inputs or outputs methods in the model's implementation code, which is usually equal to typemin(), e.g. -Inf for Float64.\n\ntip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns every variable that is needed by the model to run, but in multi-model simulations, some of them may already be computed by other models and not require initialization. to_initialize returns only the variables that are needed by the model to run and that are not initialized in the ModelList.\n\nWe can initialize the required variables by providing their starting values to the status when declaring the ModelList:\n\nm = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\nOr after instantiation using init_status!:\n\nm = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)\n\nWe can check if a component is correctly initialized using is_initialized:\n\nis_initialized(m)\n\nSome variables are inputs of models, but outputs of other models. When we couple models, to_initialize only requests the variables that are not computed by other models.","category":"section"},{"location":"step_by_step/detailed_first_example/#Climate-forcing","page":"Detailed first simulation","title":"Climate forcing","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.\n\nUsers are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.\n\nThe mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). In our example, we also need the incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nThis meteo variable will therefore provide a single weather timeframe that can be used in a simulation.\n\nMore details are available from the package documentation.","category":"section"},{"location":"step_by_step/detailed_first_example/#Simulation","page":"Detailed first simulation","title":"Simulation","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/#Simulation-of-processes","page":"Detailed first simulation","title":"Simulation of processes","text":"To run a simulation, you can call the run! method on the ModelList. If some meteorological data is required for models to be simulated over several timesteps, that can be passed in as an optional argument as well.\n\nYour call to the function would then look like this:\n\nrun!(model_list, meteo)\n\nThe first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.\n\nThe ModelList should already be initialized for the given process before calling the function. Refer to the earlier subsection Variables (inputs, outputs) for more details.","category":"section"},{"location":"step_by_step/detailed_first_example/#Example-simulation","page":"Detailed first simulation","title":"Example simulation","text":"For example we can simulate the light_interception of a leaf like so:\n\nusing PlantSimEngine, PlantMeteo\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\noutputs_example = run!(leaf, meteo)\n\noutputs_example[:aPPFD]","category":"section"},{"location":"step_by_step/detailed_first_example/#Outputs","page":"Detailed first simulation","title":"Outputs","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract outputs of the very last timestep of a simulation using the status function.\n\nThe actual full output data is returned by the run! function. Data is usually stored in a TimeStepTable structure from PlantMeteo.jl, which is a fast DataFrame-like structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.\n\nIn our example, the simulation was only provided one weather timestep, so the outputs returned by run! and the ModelList's status field are identical.\n\nLet's look at the outputs structure of our previous simulated leaf:\n\nWe can extract the value of one variable by indexing into it, e.g. for the intercepted light:\n\noutputs_example[:aPPFD]\n\nOr similarly using the dot syntax:\n\noutputs_example.aPPFD\n\nYou can then print the outputs, convert them to another format, or visualize them, using other Julia packages. You can read more on how to do that in the Visualizing outputs and data page.\n\nAnother convenient way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:\n\nusing DataFrames\nconvert_outputs(outputs_example, DataFrame)","category":"section"},{"location":"step_by_step/detailed_first_example/#Model-coupling","page":"Detailed first simulation","title":"Model coupling","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.\n\nPlantSimEngine.jl is designed to make model coupling painless for modelers and users. Please see Standard model coupling and Coupling more complex models for more details, or Handling dependencies in a multiscale context for multi-scale specific coupling considerations.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This page summarizes some of the assumptions, coupling constraints and inner workings of PlantSimEngine which may be particular relevant when implementing new models.\n\nIf you are unsure of an implementation subtlety, check this page out to see whether it answers your question.\n\nPages = [\"implicit_contracts.md\"]\nDepth = 2","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-provides-the-simulation-timestep,-but-models-can-veer-away-from-it","page":"Implicit contracts","title":"Weather data provides the simulation timestep, but models can veer away from it","text":"The weather data timesteps, whether hourly or daily, provide the pace at which most other models run.\n\nIn XPalm, weather data for most models is provided daily, meaning biomass calculations are also provided daily. \n\nMany models are considered to be steady-state over that timeframe, but not all : the leaf pruning model pertubes the plant in a non-steady state fashion, for example. Models that require computations over several iterations to stabilise (often part of hard dependencies) might also have a timestep unrelated to the weather data.\n\n!!! Note     Implicitely, this means any vector variables given as input to the simulation must be consistent with the number of weather timesteps. Providing one weather value but a larger vector variable is an exception : the weather data is replicated over each timestep. (This may be subject to change in the future when support for different timesteps in a single simulation is implemented)","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-must-be-interpolated-prior-to-simulation","page":"Implicit contracts","title":"Weather data must be interpolated prior to simulation","text":"If your weather data isn't adjusted to conform to a regular timestep, you will need to adjust it to fit that constraint. PlantSimEngine does no interpolation prior to simulation and expects regular weather timesteps.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-cyclic-dependencies-in-the-simplified-dependency-graph","page":"Implicit contracts","title":"No cyclic dependencies in the simplified dependency graph","text":"The model dependency graph used for running the simulation is comprised of soft and hard dependency nodes, and the final version only links soft dependency nodes together, and is expected to contain no cycles.\n\nAny user model coupling which causes a cyclic dependency to occur will require some extra tinkering to run : either design models differently, create a hard dependency with some of the problematic models, or break the cycle by having a variable take the previous timestep's value as input.\n\nSee Dependency graphs and the following subsections for more discussion related to dependency graph constraints.\n\nNote : Only the previous timestep is accessible in PlantSimEngine without any kind of dedicated model. How to create a model to store more past timesteps of a specific variable is described in the Tips and workarounds page: Making use of past states in multi-scale simulations","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-need-to-be-declared-in-the-model-definition","page":"Implicit contracts","title":"Hard dependencies need to be declared in the model definition","text":"Hard dependencies are handled internally by their owning soft dependency model, ie the hard dep's run! function is directly called by the soft dependency's run!.\n\nThe current way in which PlantSimEngine creates its dependency graph requires users to declare what process is required in the hard dependency and which scale it pulls the model and its variables from.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Parallelisation-opportunities-must-be-part-of-the-model-definition","page":"Implicit contracts","title":"Parallelisation opportunities must be part of the model definition","text":"Traits that indicate that a model is independent or objects need to be part of the model definition. Modelers need to keep this in mind when implementing new models.\n\nThis is currently mostly a concern for single-scale simulations, as multi-scale simulations are not currently parallelised ; a more involved scheduler would need to be implemented when MTGs are modified by models, and to handle more interesting parallelisation opportunities at specific scales. \n\nThere may be new parallelisation features for multi-plant simulations further down the road.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-can-only-have-one-parent-in-the-dependency-graph","page":"Implicit contracts","title":"Hard dependencies can only have one parent in the dependency graph","text":"The final dependency graph is comprised only of soft dependency nodes, and is guaranteed to contain no cycles. Hard dependencies are handled internally by their soft dependency ancestor. To avoid any ambiguity in terms of processing order, only one soft dependency node can 'own' a hard dependency And similarly, nested hard dependencies only have a single soft dependency ancestor.\n\nThis is not solely an implementation detail of PlantSimEngine's internal mechanisms ; if your simulation requires complex coupling, you might need to carefully consider how to manage your hard dependencies, or insert an extra intermediate model to simplify things.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#A-model-can-only-be-used-once-per-scale","page":"Implicit contracts","title":"A model can only be used once per scale","text":"Similarly, to avoid depedency graph ambiguity (and for simulation cohesion), PlantSimEngine currently assumes a model describing a process only occurs once per scale.\n\nModel renaming and duplicating works around this assumption. It may change once multi-plant/multi-species features are implemented.","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-two-variables-with-the-same-name-at-the-same-scale","page":"Implicit contracts","title":"No two variables with the same name at the same scale","text":"This rule avoids potential ambiguity which could then cause both problems in terms of model ordering during the simulation, as well as incorrectly coupling models with the wrong variable.\n\nA workaround for some of the situations where this occurs is described here : Having a variable simultaneously as input and output of a model","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Simulation-order-instability-when-adding-models","page":"Implicit contracts","title":"Simulation order instability when adding models","text":"An important aspect to bear in mind is that PlantSimEngine automatically determines an order in which models are run from the dependency graph it generates by coupling models together. \n\nThis order of simulation depends on the way the models link together. If you replace a model by a new set of models, or pass in new variables that create new links between models, you may change the simulation order.\n\nWhen iterating and slowly making a simulation more physiologically realistic and complex, it is therefore fully possible that the order in which two models are run is flipped by a user change. \n\nThis design choice implementation -a concession made for ease of use and flexibility when developing a simulation- means that until your set of models is fully stabilized and you know which variables are PreviousTimestep and what order models run in, as you expand and change the set you might see differences of execution of one timestep for some models. It isn't a conceptual problem as most models are steady-state, and simulation order is stable for a given set of models, but it does mean PlantSimEngine will be less conveient for some types of simulation.","category":"section"},{"location":"multiscale/single_to_multiscale/#Converting-a-single-scale-simulation-to-multi-scale","page":"Converting a simulation to multi-scale","title":"Converting a single-scale simulation to multi-scale","text":"A single-scale simulation can be turned into a 'pseudo-multi-scale' simulation by providing a simple multi-scale tree graph, and declaring a mapping linking all models to a unique scale level.\n\nThis page showcases how to do the conversion, and then adds a model at a new scale to make the simulation genuinely multi-scale.\n\nThe full script for the example can be found in the examples folder, here\n\nPages = [\"single_to_multiscale.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/single_to_multiscale/#Converting-the-ModelList-to-a-multi-scale-mapping","page":"Converting a simulation to multi-scale","title":"Converting the ModelList to a multi-scale mapping","text":"For example, let's return to the ModelList coupling a light interception model, a Leaf Area Index model, and a carbon biomass increment model that was discussed in the Model switching subsection: \n\nusing PlantMeteo\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)\n\nThose models all operate on a simplified model of a single plant, without any organ-local information. We can therefore consider them to be working at the 'whole plant' scale. Their variables also operate at that \"plant\" scale, so there is no need to map any variable to other scales.\n\nWe can therefore convert this into the following mapping : \n\nmapping = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)\n\nNote the slight difference in syntax for the Status. This is due to an implementation quirk (sorry).","category":"section"},{"location":"multiscale/single_to_multiscale/#Adding-a-new-package-for-our-plant-graph","page":"Converting a simulation to multi-scale","title":"Adding a new package for our plant graph","text":"None of these models operate on a multi-scale tree graph, either. There is no concept of organ creation or growth. We still need to provide a multi-scale tree graph to a multi-scale simulation, so we can -for now- declare a very simple MTG, with a single node:\n\nusing MultiScaleTreeGraph\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n\nnote: Note\nYou will need to add the MultiScaleTreeGraph package to your environment. See Installing and running PlantSimEngine if you are not yet comfortable with Julia or need a refresher.","category":"section"},{"location":"multiscale/single_to_multiscale/#Running-the-multi-scale-simulation-?","page":"Converting a simulation to multi-scale","title":"Running the multi-scale simulation ?","text":"We now have almost everything we need to run the multiscale simulation.\n\nThis first conversion step can be a starting point for a more elaborate multi-scale simulation. \n\nThe signature of the run! function in multi-scale differs slightly from the ModelList version : \n\nout_multiscale = run!(mtg, mapping, meteo_day)\n\n(Some of the optional arguments also change slightly)\n\nUnfortunately, there is one caveat. Passing in a vector through the Status field is still possible in multi-scale mode, but requires a little more advanced tinkering with the mapping, as it generates a custom model under the hood and the implementation is experimental and less user-friendly.\n\nIf you are keen on going down that path, you can find a detailed example here, but we don't recommend it for beginners.\n\nWhat we'll do instead, is write our own model provide the thermal time per timestep as a variable, instead of as a single vector in the Status.\n\nOur 'pseudo-multiscale' first approach will therefore turn into a genuine multi-scale simulation.","category":"section"},{"location":"multiscale/single_to_multiscale/#Adding-a-second-scale","page":"Converting a simulation to multi-scale","title":"Adding a second scale","text":"Let's have a model provide the Cumulated Thermal Time to our Leaf Area Index model, instead of initializing it through the Status. \n\nLet's instead implement our own ToyTT_cuModel.","category":"section"},{"location":"multiscale/single_to_multiscale/#TT_cu-model-implementation","page":"Converting a simulation to multi-scale","title":"TT_cu model implementation","text":"This model doesn't require any outside data or input variables, it only operates on the weather data and outputs our desired TT_cu. The implementation doesn't require any advanced coupling and is very straightforward.\n\nPlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel\nend\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend\n\nnote: Note\nThe only accessible variables in the run! function via the status are the ones that are local to the \"Scene\" scale. This isn't explicit at first glance, but very important to keep in mind when developing models, or using them at different scales. If variables from other scales are required, then they need to be mapped via a MultiScaleModel, or sometimes a more complex coupling is necessary.","category":"section"},{"location":"multiscale/single_to_multiscale/#Linking-the-new-TT_cu-model-to-a-scale-in-the-mapping","page":"Converting a simulation to multi-scale","title":"Linking the new TT_cu model to a scale in the mapping","text":"We now have our model implementation. How does it fit into our mapping ?\n\nOur new model doesn't really relate to a specific organ of our plant. In fact, this model doesn't represent a physiological process of the plant, but rather an environmental process affecting its physiology. We could therefore have it operate at a different scale unrelated to the plant, which we'll call \"Scene\". This makes sense.\n\nNote that we now need to add a \"Scene\" node to our Multi-scale Tree Graph, otherwise our model will not run, since no other model calls it and \"Plant\" nodes will only call models at the \"Plant\" scale. See Empty status vectors in multi-scale simulations for more details.\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))","category":"section"},{"location":"multiscale/single_to_multiscale/#Mapping-between-scales-:-the-MultiScaleModel-wrapper","page":"Converting a simulation to multi-scale","title":"Mapping between scales : the MultiScaleModel wrapper","text":"The cumulated thermal time (:TT_cu) which was previously provided to the LAI model as a simulation parameter now needs to be mapped from the \"Scene\" scale level. \n\nThis is done by wrapping our ToyLAIModel in a dedicated structure called a MultiScaleModel. A MultiScaleModel requires two keyword arguments : model, indicating the model for which some variables are mapped, and mapped_variables, indicating which scale link to which variables, and potentially renaming them.\n\nThere can be different kinds of variable mapping with slightly different syntax, but in our case, only a single scalar value of the TT_cu is passed from the \"Scene\" to the \"Plant\" scale.\n\nThis gives us the following declaration with the MultiScaleModel wrapper for our LAI model: \n\nMultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        )\n\nand the new mapping with two scales:\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)","category":"section"},{"location":"multiscale/single_to_multiscale/#Running-the-multi-scale-simulation","page":"Converting a simulation to multi-scale","title":"Running the multi-scale simulation","text":"We can then run the multiscale simulation, with our two-node MTG :\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)","category":"section"},{"location":"multiscale/single_to_multiscale/#Comparing-outputs-between-single-and-multi-scale","page":"Converting a simulation to multi-scale","title":"Comparing outputs between single- and multi-scale","text":"The outputs structures are slightly different : multi-scale outputs are indexed by scale, and a variable has a value for every node of the scale it operates at (for instance, there would be a \"leaf_surface\" value for every leaf in a plant), stored in an array.\n\nIn our simple example, we only have one MTG scene node and one plant node, so the arrays for each variable in the multi-scale output only contain one value.\n\nWe can access the output variables at the \"Scene\" scale by indexing our outputs:\n\noutputs_multiscale[\"Scene\"]\n\nWe have a Vector{NamedTuple}structure. Our single-scale output is a Vector{T}:\n\noutputs_singlescale.TT_cu\n\nLet's extract the multi-scale :TT_cu:\n\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\n\nWe can now compare them value-by-value and do a piecewise approximate equality test :\n\nfor i in 1:length(computed_TT_cu_multiscale)\n    if !(computed_TT_cu_multiscale[i] ≈ outputs_singlescale.TT_cu[i])\n        println(i)\n    end\nend\n\nor equivalently, with broadcasting, we can write :\n\nis_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1\n\nnote: Note\nYou may be wondering why we check for approximate equality rather than strict equality. The reason for that is due to floating-point accumulation errors, which are discussed in more detail in Floating-point considerations.","category":"section"},{"location":"multiscale/single_to_multiscale/#ToyDegreeDaysCumulModel","page":"Converting a simulation to multi-scale","title":"ToyDegreeDaysCumulModel","text":"There is a model able to provide Thermal Time based on weather temperature data, ToyDegreeDaysCumulModel, which can also be found in the examples folder. \n\nWe didn't make use of it here for learning purposes. It also computes a thermal time based on default parameters that don't correspond to the thermal time in the example weather data, so results differ from the thermal time already present in the weather data without tinkering with the parameters. ","category":"section"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"(Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: Aqua QA) (Image: DOI) (Image: JOSS)\n\nPages = [\"index.md\"]\nDepth = 5","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"PlantSimEngine is a comprehensive framework for building models of the soil-plant-atmosphere continuum. It includes everything you need to prototype, evaluate, test, and deploy plant/crop models at any scale, with a strong emphasis on performance and efficiency, so you can focus on building and refining your models.\n\nWhy choose PlantSimEngine?\n\nSimplicity: Write less code, focus on your model's logic, and let the framework handle the rest.\nModularity: Each model component can be developed, tested, and improved independently. Assemble complex simulations by reusing pre-built, high-quality modules.\nStandardisation: Clear, enforceable guidelines ensure that all models adhere to best practices. This built-in consistency means that once you implement a model, it works seamlessly with others in the ecosystem.\nOptimised Performance: Don't re-invent the wheel. Delegating low-level tasks to PlantSimEngine guarantees that your model will benefit from every improvement in the framework. Enjoy faster prototyping, robust simulations, and efficient execution using Julia's high-performance capabilities.","category":"section"},{"location":"#Unique-Features","page":"Home","title":"Unique Features","text":"","category":"section"},{"location":"#Automatic-Model-Coupling","page":"Home","title":"Automatic Model Coupling","text":"Seamless Integration: PlantSimEngine leverages Julia's multiple-dispatch capabilities to automatically compute the dependency graph between models. This allows researchers to effortlessly couple models without writing complex connection code or manually managing dependencies.\n\nIntuitive Multi-Scale Support: The framework naturally handles models operating at different scales—from organelle to ecosystem—connecting them with minimal effort and maintaining consistency across scales.","category":"section"},{"location":"#Flexibility-with-Precision-Control","page":"Home","title":"Flexibility with Precision Control","text":"Effortless Model Switching: Researchers can switch between different component models using a simple syntax without rewriting the underlying model code. This enables rapid comparison between different hypotheses and model versions, accelerating the scientific discovery process.","category":"section"},{"location":"#Batteries-included","page":"Home","title":"Batteries included","text":"Automated Management: Seamlessly handle inputs, outputs, time-steps, objects, and dependency resolution.\nIterative Development: Fast and interactive prototyping of models with built-in constraints to avoid errors and sensible defaults to streamline the model writing process.\nControl Your Degrees of Freedom: Fix variables to constant values or force to observations, use simpler models for specific processes to reduce complexity.\nHigh-Speed Computations: Achieve impressive performance with benchmarks showing operations in the 100th of nanoseconds range for complex models (see this benchmark script).\nParallelize and Distribute Computing: Out-of-the-box support for sequential, multi-threaded, or distributed computations over objects, time-steps, and independent processes, thanks to Floops.jl.\nScale Effortlessly: Methods for computing over objects, time-steps, and Multi-Scale Tree Graphs.\nCompose Freely: Use any types as inputs, including Unitful for unit propagation and MonteCarloMeasurements.jl for measurement error propagation.","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"PlantSimEngine delivers impressive performance for plant modeling tasks. On an M1 MacBook Pro:\n\nA toy model for leaf area over a year at daily time-scale took only 260 μs (about 688 ns per day)\nThe same model coupled to a light interception model took 275 μs (756 ns per day)\n\nThese benchmarks demonstrate performance on par with compiled languages like Fortran or C, far outpacing typical interpreted language implementations. For example, PlantBiophysics.jl, which implements ecophysiological models using PlantSimEngine, has been measured to run up to 38,000 times faster than equivalent implementations in other scientific computing languages.","category":"section"},{"location":"#Ask-Questions","page":"Home","title":"Ask Questions","text":"If you have any questions or feedback, open an issue or ask on discourse.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:\n\nadd PlantSimEngine\n\nTo use the package, execute this command from the Julia REPL:\n\nusing PlantSimEngine","category":"section"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"The package is designed to be easy to use, and to help users avoid errors when implementing, coupling and simulating models.","category":"section"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"Here's a simple example of a model that simulates the growth of a plant, using a simple exponential growth model:\n\n# ] add PlantSimEngine\nusing PlantSimEngine\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nout = run!(model) # run the model and extract its outputs\n\nNote   The ToyLAIModel is available from the examples folder, and is a simple exponential growth model. It is used here for the sake of simplicity, but you can use any model you want, as long as it follows PlantSimEngine interface.\n\nOf course you can plot the outputs quite easily:\n\n# ] add CairoMakie\nusing CairoMakie\n\nlines(out[:TT_cu], out[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Cumulated growing degree days since sowing (°C)\"))","category":"section"},{"location":"#Model-coupling","page":"Home","title":"Model coupling","text":"Model coupling is done automatically by the package, and is based on the dependency graph between the models. To couple models, we just have to add them to the ModelList. For example, let's couple the ToyLAIModel with a model for light interception based on Beer's law:\n\n# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nout2 = run!(model2, meteo_day)\n\nThe ModelList couples the models by automatically computing the dependency graph of the models. The resulting dependency graph is:\n\n╭──── Dependency graph ──────────────────────────────────────────╮\n│  ╭──── LAI_Dynamic ─────────────────────────────────────────╮  │\n│  │  ╭──── Main model ────────╮                              │  │\n│  │  │  Process: LAI_Dynamic  │                              │  │\n│  │  │  Model: ToyLAIModel    │                              │  │\n│  │  │  Dep: nothing          │                              │  │\n│  │  ╰────────────────────────╯                              │  │\n│  │                  │  ╭──── Soft-coupled model ─────────╮  │  │\n│  │                  │  │  Process: light_interception    │  │  │\n│  │                  └──│  Model: Beer                    │  │  │\n│  │                     │  Dep: (LAI_Dynamic = (:LAI,),)  │  │  │\n│  │                     ╰─────────────────────────────────╯  │  │\n│  ╰──────────────────────────────────────────────────────────╯  │\n╰────────────────────────────────────────────────────────────────╯\n\nWe can plot the results by indexing the outputs with the variable name (e.g. out2[:LAI]):\n\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, out2[:TT_cu], out2[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, out2[:TT_cu], out2[:aPPFD], color=:firebrick1)\n\nfig","category":"section"},{"location":"#Multi-scale-modeling","page":"Home","title":"Multi-scale modeling","text":"See the Multi-scale modeling section for more details.\n\nThe package is designed to be easily scalable, and can be used to simulate models at different scales. For example, you can simulate a model at the leaf scale, and then couple it with models at any other scale, e.g. internode, plant, soil, scene scales. Here's an example of a simple model that simulates plant growth using sub-models operating at different scales:\n\nmapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\"],\n        ),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        MultiScaleModel(\n            model=ToyInternodeEmergence(TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\"],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide\n\nWe can import an example plant from the package:\n\nmtg = import_mtg_example()\n\nMake a fake meteorological data:\n\nmeteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=300.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f=500.0)\n]\n);\nnothing # hide\n\nAnd run the simulation:\n\nout_vars = Dict(\n    \"Scene\" => (:TT_cu,),\n    \"Plant\" => (:carbon_allocation, :carbon_assimilation, :soil_water_content, :aPPFD, :TT_cu, :LAI),\n    \"Leaf\" => (:carbon_demand, :carbon_allocation),\n    \"Internode\" => (:carbon_demand, :carbon_allocation),\n    \"Soil\" => (:soil_water_content,),\n)\n\nout = run!(mtg, mapping, meteo, tracked_outputs=out_vars, executor=SequentialEx());\nnothing # hide\n\nWe can then extract the outputs and convert them to a DataFrame for each scale and sort them:\n\nusing DataFrames\ndf_dict = convert_outputs(out, DataFrame)\nsort!(df_dict[\"Leaf\"], [:timestep, :node])\n\nAn example output of a multiscale simulation is shown in the documentation of PlantBiophysics.jl:\n\n(Image: Plant growth simulation)","category":"section"},{"location":"#State-of-the-field","page":"Home","title":"State of the field","text":"PlantSimEngine is a state-of-the-art plant simulation software that offers significant advantages over existing tools such as OpenAlea, STICS, APSIM, or DSSAT.\n\nThe use of Julia programming language in PlantSimEngine allows for:\n\nQuick and easy prototyping compared to compiled languages\nSignificantly better performance than typical interpreted languages\nNo need for translation into another compiled language\n\nJulia's features enable PlantSimEngine to provide:\n\nMultiple-dispatch for automatic computation of model dependency graphs\nType stability for optimized performance\nSeamless compatibility with powerful tools like MultiScaleTreeGraph.jl for multi-scale computations\n\nPlantSimEngine's approach streamlines the process of model development by automatically managing:\n\nModel coupling with automated dependency graph computation\nTime-steps and parallelization\nInput and output variables\nVarious types of objects used for simulations (vectors, dictionaries, multi-scale tree graphs)","category":"section"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"Take a look at these projects that use PlantSimEngine:\n\nPlantBiophysics.jl\nXPalm","category":"section"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license.\n\nIf you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! 😃","category":"section"},{"location":"introduction/why_julia/#The-choice-of-using-Julia","page":"Why Julia ?","title":"The choice of using Julia","text":"PlantSimEngine is implemented in Julia. It arose from a particular combination of needs and requirements that Julia addresses effectively.\n\nOther modelling frameworks, FSPMs and crop models are -often- written in combinations of Java, C++, Python, or Fortran. Given that Julia isn't the language many researchers (and developers!) are most familiar with yet, this page provides a short explanation of the reasoning behind that language choice. Another nice resource is this discourse post by Alejandro Morales Sierra, the creator and maintainer of Virtual Plant Lab.","category":"section"},{"location":"introduction/why_julia/#From-research-to-real-world-applications","page":"Why Julia ?","title":"From research to real-world applications","text":"PlantSimEngine was originally a goal-oriented framework. Its features arose -and continue to evolve- out of necessity for more and more complex simulation setups.\n\nWhile PlantSimEngine primarily helps researchers prototype and test their models efficiently, we consistently work with the vision of making it suitable for real-world applications. Our goal is to build a bridge between academic plant modeling and practical field applications. Ideally, researchers should be able to develop and refine their models in a comfortable environment, and these models could eventually be deployed in production environments.\n\nThis vision of dual-purpose functionality drives our focus on performance optimization. We aspire for the models you develop to be useful beyond academic papers, potentially serving reliably in production environments where efficiency and accuracy are crucial. Julia's strong performance characteristics support this vision in ways other languages would struggle to match.\n\nPlantSimEngine aims to balance scientific rigor with developer productivity, with the long-term goal of ensuring that models can be deployed at scale. Julia provides an environment where researchers can express complex mathematical concepts directly in code with good performance potential, creating a pathway for these models to potentially reach practical implementation.","category":"section"},{"location":"introduction/why_julia/#PlantSimEngine's-constraints","page":"Why Julia ?","title":"PlantSimEngine's constraints","text":"","category":"section"},{"location":"introduction/why_julia/#Performance","page":"Why Julia ?","title":"Performance","text":"While computers have gained several orders of magnitude of power and memory over the past few decades, to the point where many prior performance bottlenecks have vanished, performance can still be a limiting factor.\n\nSimulating multiple processes with user-provided variables over many plants with tens of thousands of leaves requires a lot of computation. Using a higher-level language such as Python or R would not lead to adequate simulation times.\n\nIn fact, part of the initial motivation to commit to Julia happened after porting a model from R to Julia and getting several orders of magnitude difference in performance 'out-of-the-box'. Seeing computations that previously took minutes suddenly completing in seconds was quite convincing (see also this benchmark showing a difference of 5 orders of magnitude).\n\nJulia, with its well-designed 'Just-ahead-of-time' compilation model and its flexibility allowing to do some lower-level optimisation, doesn't suffer from the limitations one would encounter by using only Python or R.","category":"section"},{"location":"introduction/why_julia/#Flexibility,-ease-of-use","page":"Why Julia ?","title":"Flexibility, ease of use","text":"PlantSimEngine was also developed with a few goals in mind, one of them being to make hypothesis testing quite easy. It is currently difficult to validate FSPM, crop model or ecophysiological hypotheses in many existing frameworks due to their rigid structure or steep learning curve.\n\nSimilarly, when developing a full-featured FSPM, there might be a need to test different models for a specific process, or to switch a model for a more complex one. API and language ease of use is as much of a factor as automated model coupling in keeping these changes smooth.","category":"section"},{"location":"introduction/why_julia/#Packages-destined-to-be-used-by-a-wider-community","page":"Why Julia ?","title":"Packages destined to be used by a wider community","text":"As mentioned earlier, PlantSimEngine is intended for a wide audience. Only few of them are expected to have a strong development background. Many other potential users might be researchers more well-versed in ecophysiology or plant architecture and only know a little bit of Python, Matlab or R. Reducing friction for these users is paramount.\n\nOpen-source libraries/packages, ease of installation and low entry barrier also factor in the decision.","category":"section"},{"location":"introduction/why_julia/#Modularity-and-flexibility-while-retaining-performance","page":"Why Julia ?","title":"Modularity and flexibility while retaining performance","text":"One approach could be to combine, say, Python, with a more performant language such as C++ or Fortran. The slower but flexible language being used for prototyping, and when performance is required, some chunks are reimplmented in the other language.\n\nThis fits the performance constraint, but has a few caveats.","category":"section"},{"location":"introduction/why_julia/#Low-developer-bandwidth","page":"Why Julia ?","title":"Low developer bandwidth","text":"And of course, budget, time and resources are a concern. The more autonomous researchers and modelers are, and the less specialist developer/engineering resources are required, the easier it is for the project to keep evolving.","category":"section"},{"location":"introduction/why_julia/#Comparison","page":"Why Julia ?","title":"Comparison","text":"","category":"section"},{"location":"introduction/why_julia/#The-Two-Language-Problem","page":"Why Julia ?","title":"The Two-Language Problem","text":"Combining two different languages requires a lot of language expertise, with constant knowledge refreshing, as one might only occasionally work with and debug with the lower-level language. Or more engineering resources.\n\nSpeed of iteration is also lost whenever performance is a concern, which happens often in our context. However modular and easy-to-use a language like Python might be, whenever it's time to switch to a low-level language, development speed will slow down.\n\nJulia effectively solves this problem. While it might be a little harder to learn than Python, and require extra knowledge to properly make use of its flexibility and performance capabilities, it leads to a smoother development experience.\n\nEverything can be done using Julia exclusively, so there is no need to learn two languages. No need to interface between them. Iteration speed doesn't suddenly grind to a halt if a low-level implementation is needed. A competent researcher-developer can move seamlessly from prototype to production, while still being able to focus on modeling and the actual plant side of things.\n\n(Image: Language usage comparison for different ML packages (source: https://pde-on-gpu.vaw.ethz.ch/lecture1/)) (Language usage comparison for different ML packages; source: https://pde-on-gpu.vaw.ethz.ch/lecture1/)\n\nIt seems we aren't the only ones to find Julia a good tool for our job. Other niches where Julia is gaining traction tend to be other computationally heavy areas with much active research, such as machine learning and climate modeling - areas where this balance of expressivity and performance is equally valuable.","category":"section"},{"location":"introduction/why_julia/#A-good-balance-in-terms-of-accessibility","page":"Why Julia ?","title":"A good balance in terms of accessibility","text":"Another argument in favour of Julia is that one of the aims for PlantSimEngine is to be easy-to-use for researchers wishing to test hypothesis, or reproduce results from other papers. Scientific reproducibility is greatly enhanced when the barrier to running and modifying simulations is lowered.\n\nMany researchers are not developers by trade or heart, and a Java-only or C++-only implementation, on top of the earlier points, would not be accessible enough and would not gain much traction.\n\nJulia, while less ubiquitous than other languages in research circles, resembles Python and R and is more beginner-friendly than Java or C++. It is easier for a Python user to learn to use a simple Julia package than a C++ one.\n\nUsers will also find it easier to quickly implement new models without the potential hurdle of a low-level implementation, or some language interfacing also being required. The prototyping phase doesn't require a subsequent performance tuning phase.","category":"section"},{"location":"introduction/why_julia/#Ease-of-environment-setup","page":"Why Julia ?","title":"Ease of environment setup","text":"Similarly, Julia's language and package installation is -mostly- fairly straightforward and requires little additional knowledge.\n\nThe package manager is built directly into the language, making dependency management straightforward. This is particularly important for reproducible scientific workflows, where consistent environments are crucial.","category":"section"},{"location":"introduction/why_julia/#Downsides-acceptable","page":"Why Julia ?","title":"Downsides acceptable","text":"While very practical for a 'researcher-developer', Julia is of course far from being the perfect language in every discipline. It is massive in terms of features, has a heavy runtime, is more involved to learn and master quickly compared to Python, has a few hurdles for beginners, some quirks that can be awkward for developers, tools that aren't fully mature, no clear 'recommended' workflow, and so on. \n\nThe cost for switching may not be worth it in many other circumstances. However, several of these downsides, while very relevant for embedded systems, or game development, are much less relevant regarding PlantSimEngine. And others can be mitigated with, hopefully, adequate learning resources and documentation.","category":"section"},{"location":"introduction/why_julia/#Conclusion","page":"Why Julia ?","title":"Conclusion","text":"For PlantSimEngine's specific requirements—balancing performance with flexibility, enabling rapid iteration while maintaining computational efficiency, and providing an accessible interface for both researchers and field practitioners—Julia represents a suitable choice. The language allows us to build an ecosystem where plant modeling can advance through collaborative, efficient, and scientifically rigorous development while delivering real-world value through production deployments.\n\nWhile no language solution is perfect, Julia's combination of features makes it well-suited to the challenges of modern plant modeling and simulation, both in research and practical applications. We're optimistic about the possibilities it offers for the future of plant modeling.","category":"section"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Model coupling for users","title":"Model coupling for users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls again run! inside its implementation at some point. Note that it does not force any kind of conductance model over another, just that there is one to simulate the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.\n\nWe provide an example script that implements seven dummy processes in examples/dummy. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model... ","category":"section"},{"location":"model_coupling/model_coupling_user/#Hard-coupled-models","page":"Model coupling for users","title":"Hard coupled models","text":"The Process3Model calls Process2Model, and Process2Model calls Process1Model. This explicit call is called a hard-dependency in PlantSimEngine.\n\nThe other models for the other processes are called Process4Model, Process5Model... and they do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.\n\ntip: Tip\nHard-coupling of models is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is hard-coupled to a photosynthesis model.\n\nBack to our example, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. \n\nLet's use the Examples sub-module so we can play around:\n\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\ntip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).\n\nHere is how we can make the model coupling:\n\nm = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide\n\nWe can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).\n\nNote that the user only declares the models, not the way the models are coupled because PlantSimEngine.jl deals with that automatically.\n\nNow the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their hard or soft-coupling.\n\nFor example, Process1Model requires the following variables as inputs:\n\ninputs(Process1Model(2.0))\n\nAnd Process2Model requires the following variables:\n\ninputs(Process2Model())\n\nWe see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:\n\noutputs(Process2Model())\n\nSo considering those two models, we only need var1 and var2 to be initialized, as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)\n\nThe most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide\n\nOur component models structure is now fully parameterized and initialized for a simulation!\n\nLet's simulate it:\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"section"},{"location":"model_coupling/model_coupling_user/#Soft-coupled-models","page":"Model coupling for users","title":"Soft coupled models","text":"All following models (Process4Model to Process7Model) do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.\n\nLet's make a new model list including the soft-coupled models:\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide\n\nWith this list of models, we only need to initialize var0, that is an input of Process4Model and Process7Model:\n\nto_initialize(m)\n\nWe can initialize it like so:\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide\n\nLet's simulate it:\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"section"},{"location":"model_coupling/model_coupling_user/#Simulation-order","page":"Model coupling for users","title":"Simulation order","text":"When calling run!, the models are run in the right order using a dependency graph that is computed automatically based on the hard and soft dependencies of the models following a simple set of rules:\n\nIndependent models are run first. A model is independent if it can be run alone, or only using initializations. It is not dependent on any other model.\nFrom their children dependencies:\nHard dependencies are always run before soft dependencies. Inner hard dependency graphs are considered as a whole, i.e. as a single soft dependency.\nSoft dependencies are then run sequentially. If a soft dependency has several parent nodes (i.e. its inputs are computed by several models), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"section"}]
}
