<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A rudimentary plant simulation · PlantSimEngine.jl</title><meta name="title" content="A rudimentary plant simulation · PlantSimEngine.jl"/><meta property="og:title" content="A rudimentary plant simulation · PlantSimEngine.jl"/><meta property="twitter:title" content="A rudimentary plant simulation · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_1/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_1/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_1/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox" checked/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>A rudimentary plant simulation</a><ul class="internal"><li><a class="tocitem" href="#Disclaimer"><span>Disclaimer</span></a></li><li><a class="tocitem" href="#Initial-setup"><span>Initial setup</span></a></li><li><a class="tocitem" href="#A-basic-growing-plant"><span>A basic growing plant</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li></ul></li><li><a class="tocitem" href="../multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li><li><a class="tocitem" href="../multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/API_public/">Public API</a></li><li><a class="tocitem" href="../../API/API_examples/">Example models</a></li><li><a class="tocitem" href="../../API/API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../credits/">Credits</a></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Moving to multiscale</a></li><li><a class="is-disabled">Building a simple plant</a></li><li class="is-active"><a href>A rudimentary plant simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A rudimentary plant simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/multiscale/multiscale_example_1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Writing-a-multiscale-simulation"><a class="docs-heading-anchor" href="#Writing-a-multiscale-simulation">Writing a multiscale simulation</a><a id="Writing-a-multiscale-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-a-multiscale-simulation" title="Permalink"></a></h1><p>This three-part subsection walks you through building a multi-scale simulation from scratch. It is meant as an illustration of the iterative process you might go through when building and slowly tuning a Functional-Structural Plant Model, where previous multi-scale examples focused more on the API syntax.</p><p>You can find the full script for the first part&#39;s toy simulation in the <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyMultiScalePlantModel/ToyPlantSimulation1.jl">ToyMultiScalePlantModel</a> subfolder of the examples folder.</p><ul><li><a href="#Writing-a-multiscale-simulation">Writing a multiscale simulation</a></li><li class="no-marker"><ul><li><a href="#Disclaimer">Disclaimer</a></li><li><a href="#Initial-setup">Initial setup</a></li><li><a href="#A-basic-growing-plant">A basic growing plant</a></li><li><a href="#Implementation">Implementation</a></li><li class="no-marker"><ul><li><a href="#Carbon-Capture">Carbon Capture</a></li><li><a href="#Resource-storage">Resource storage</a></li><li><a href="#Organ-creation">Organ creation</a></li><li><a href="#Updated-mapping">Updated mapping</a></li><li><a href="#Running-a-simulation">Running a simulation</a></li></ul></li></ul></li></ul><h2 id="Disclaimer"><a class="docs-heading-anchor" href="#Disclaimer">Disclaimer</a><a id="Disclaimer-1"></a><a class="docs-heading-anchor-permalink" href="#Disclaimer" title="Permalink"></a></h2><p>The actual plant being created, as well as some of the custom models, have no real physical meaning and are very much ad hoc (which is why most of them aren&#39;t standalone in the examples folder). Similarly, some of the parameter values are pulled out of thin air, and have no ties to research papers or data.</p><p>The main purpose here is to showcase PlantSimEngine&#39;s multi-scale features and how to structure your models, not accuracy, realism or performance.</p><h2 id="Initial-setup"><a class="docs-heading-anchor" href="#Initial-setup">Initial setup</a><a id="Initial-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-setup" title="Permalink"></a></h2><p>We&#39;ll need to make use of a few packages, as usual, after adding them to our Julia environment:</p><pre><code class="language-julia hljs">using PlantSimEngine
using PlantSimEngine.Examples # to import the ToyDegreeDaysCumulModel model
using PlantMeteo
using MultiScaleTreeGraph # multi-scale
using CSV, DataFrames # used to import the example weather data</code></pre><h2 id="A-basic-growing-plant"><a class="docs-heading-anchor" href="#A-basic-growing-plant">A basic growing plant</a><a id="A-basic-growing-plant-1"></a><a class="docs-heading-anchor-permalink" href="#A-basic-growing-plant" title="Permalink"></a></h2><p>At minimum, to simulate some kind of fake growth, we need :</p><ul><li>A Multi-scale Tree Graph representing the plant</li><li>Some way of adding organs to the plant</li><li>Some kind of temporality to spread this growth over multiple timesteps</li></ul><p>Let&#39;s have some concept of &#39;leaves&#39; that capture the (carbon) resource necessary for organ growth, and let&#39;s have the organ emergence happen at the &#39;internode&#39; level, to illustrate multiple organs with different behavior.</p><p>We&#39;ll make the assumption that the internodes make use of carbon from a common pool. We&#39;ll also make use of thermal time as a growth delay factor.</p><p>To sum up, we have: </p><ul><li>a MTG with growing internodes and leaves</li><li>Individual leaves that capture carbon fed into a common pool</li><li>Internodes which take from that pool to create new organs, with a thermal time constraint.</li></ul><p>One way of modeling this approach translates into several scales and models: </p><ul><li>a Scene scale, for thermal time. The <a href="../single_to_multiscale/#ToyDegreeDaysCumulModel"><code>ToyDegreeDaysCumulModel</code></a> from the <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyDegreeDays.jl">examples folder</a> provides thermal time from temperature data </li><li>a Plant scale, where we&#39;ll define the carbon pool</li><li>an Internode scale, which draws from the pool to create new organs</li><li>a Leaf scale, which captures carbon</li></ul><p>Let&#39;s also add a very artificial limiting factor: if the total leaf surface area is above a threshold no new organs are created.</p><p>We can expect the simulation mapping to look like a more complex version of the following: </p><pre><code class="language-julia hljs">mapping = Dict(
&quot;Scene&quot; =&gt; ToyDegreeDaysCumulModel(),
&quot;Plant&quot; =&gt; ToyStockComputationModel(),
&quot;Internode&quot; =&gt; ToyCustomInternodeEmergence(),
&quot;Leaf&quot; =&gt; ToyLeafCarbonCaptureModel(),
)</code></pre><p>Some of the models will need to gather variables from scales other than their own, meaning they will need to be converted into MultiScaleModels.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><h3 id="Carbon-Capture"><a class="docs-heading-anchor" href="#Carbon-Capture">Carbon Capture</a><a id="Carbon-Capture-1"></a><a class="docs-heading-anchor-permalink" href="#Carbon-Capture" title="Permalink"></a></h3><p>Let&#39;s start with the simplest model. Our fake leaves will continuously capture some constant amount of carbon every timestep. No inputs or parameters are required.</p><pre><code class="language-julia hljs">PlantSimEngine.@process &quot;leaf_carbon_capture&quot; verbose = false

struct ToyLeafCarbonCaptureModel&lt;: AbstractLeaf_Carbon_CaptureModel end

function PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)
    NamedTuple() # No inputs
end

function PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)
    (carbon_captured=0.0,)
end

function PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)
    status.carbon_captured = 40
end</code></pre><h3 id="Resource-storage"><a class="docs-heading-anchor" href="#Resource-storage">Resource storage</a><a id="Resource-storage-1"></a><a class="docs-heading-anchor-permalink" href="#Resource-storage" title="Permalink"></a></h3><p>The model storing resources for the whole plant needs a couple of inputs: the amount of carbon captured by the leaves, as well as the amount consumed by the creation of new organs. It outputs the current stock.</p><pre><code class="language-julia hljs">PlantSimEngine.@process &quot;resource_stock_computation&quot; verbose = false

struct ToyStockComputationModel &lt;: AbstractResource_Stock_ComputationModel
end

PlantSimEngine.inputs_(::ToyStockComputationModel) =
(carbon_captured=0.0,carbon_organ_creation_consumed=0.0)

PlantSimEngine.outputs_(::ToyStockComputationModel) = (carbon_stock=-Inf,)

function PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)
    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed)
end</code></pre><h3 id="Organ-creation"><a class="docs-heading-anchor" href="#Organ-creation">Organ creation</a><a id="Organ-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Organ-creation" title="Permalink"></a></h3><p>This model is a modified version of the ToyInternodeEmergence model found <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyInternodeEmergence.jl">in the examples folder</a>. An internode produces two leaves and a new internode.</p><p>Let&#39;s first define a helper function that iterates across a Multiscale Tree Graph and returns the number of leaves :</p><pre><code class="language-julia hljs">function get_n_leaves(node::MultiScaleTreeGraph.Node)
    root = MultiScaleTreeGraph.get_root(node)
    nleaves = length(MultiScaleTreeGraph.traverse(root, x-&gt;1, symbol=&quot;Leaf&quot;))
    return nleaves
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_n_leaves (generic function with 1 method)</code></pre><p>Now that we have that, let&#39;s define a few parameters to the model. It requires :</p><ul><li>a thermal time emergence threshold</li><li>a carbon cost for organ creation</li></ul><p>We&#39;ll also add a couple of other parameters, which could go elsewhere :</p><ul><li>the surface area of a leaf (no variation, no growth stages)</li><li>the max leaf surface area beyond which organ creation stops</li></ul><pre><code class="language-julia hljs">PlantSimEngine.@process &quot;organ_emergence&quot; verbose = false

struct ToyCustomInternodeEmergence{T} &lt;: AbstractOrgan_EmergenceModel
    TT_emergence::T
    carbon_internode_creation_cost::T
    leaf_surface_area::T
    leaves_max_surface_area::T
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We make use of parametric types instead of the intuitive Float64 for flexibility. See <a href="../../step_by_step/implement_a_model_additional/#Parametric-types">Parametric types</a> for a more in-depth explanation</p></div></div><p>And give them some default values : </p><pre><code class="language-julia hljs">ToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0, leaves_max_surface_area=100.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.ToyCustomInternodeEmergence</code></pre><p>Our internode model requires thermal time, and the amount of available carbon, and outputs the amount of carbon consumed, as well as the last thermal time where emergence happened (this is useful when new organs can be produced multiple times, which won&#39;t be the case here).</p><pre><code class="language-julia hljs">PlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0, carbon_stock=0.0)
PlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)</code></pre><p>Finally, the <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function checks that conditions are met for new organ creation :</p><ul><li>thermal time threshold exceeded</li><li>total leaf surface area not above limit</li><li>carbon available</li><li>no organs already created by that internode</li></ul><p>and then updates the MTG.</p><pre><code class="language-julia hljs">function PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)

    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)
    status.carbon_organ_creation_consumed = 0.0

    if leaves_surface_area &gt; m.leaves_max_surface_area
        return nothing
    end

    # if not enough carbon, no organ creation
    if status.carbon_stock &lt; m.carbon_internode_creation_cost
        return nothing
    end

    if length(MultiScaleTreeGraph.children(status.node)) == 2 &amp;&amp;
        status.TT_cu - status.TT_cu_emergence &gt;= m.TT_emergence
        status_new_internode = add_organ!(status.node, sim_object, &quot;&lt;&quot;, &quot;Internode&quot;, 2, index=1)
        add_organ!(status_new_internode.node, sim_object, &quot;+&quot;, &quot;Leaf&quot;, 2, index=1)
        add_organ!(status_new_internode.node, sim_object, &quot;+&quot;, &quot;Leaf&quot;, 2, index=1)

        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu
        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost
    end

    return nothing
end</code></pre><h3 id="Updated-mapping"><a class="docs-heading-anchor" href="#Updated-mapping">Updated mapping</a><a id="Updated-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Updated-mapping" title="Permalink"></a></h3><p>We can now define the final mapping for this simulation. </p><p>The carbon capture and thermal time models don&#39;t need to be changed from the earlier version.  The organ creation model at the &quot;Internode&quot; scale needs the carbon stock from the &quot;Plant&quot; scale, as well as thermal time from the &quot;Scene&quot; scale. The resource storing model at the &quot;Plant&quot; scale needs the carbon captured by <strong>every</strong> leaf, and the carbon consumed by <strong>every</strong> internode that created new organs this timestep. This requires mapping vector variables :</p><pre><code class="language-julia hljs"> mapped_variables=[
            :carbon_captured=&gt;[&quot;Leaf&quot;],
            :carbon_organ_creation_consumed=&gt;[&quot;Internode&quot;]
        ],</code></pre><p>as opposed to the single-valued carbon stock mapped variable : </p><pre><code class="language-julia hljs"> mapped_variables=[:TT_cu =&gt; &quot;Scene&quot;,
            PreviousTimeStep(:carbon_stock)=&gt;&quot;Plant&quot;],</code></pre><p>And of course, some variables need to be initialized in the status:</p><pre><code class="language-julia hljs">mapping = Dict(
&quot;Scene&quot; =&gt; ToyDegreeDaysCumulModel(),
&quot;Plant&quot; =&gt; (
    MultiScaleModel(
        model=ToyStockComputationModel(),
        mapped_variables=[
            :carbon_captured=&gt;[&quot;Leaf&quot;],
            :carbon_organ_creation_consumed=&gt;[&quot;Internode&quot;]
        ],
        ),
        Status(carbon_stock = 0.0)
    ),
&quot;Internode&quot; =&gt; (
        MultiScaleModel(
            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),
            mapped_variables=[:TT_cu =&gt; &quot;Scene&quot;,
            PreviousTimeStep(:carbon_stock)=&gt;&quot;Plant&quot;],
        ),
        Status(carbon_organ_creation_consumed=0.0),
    ),
&quot;Leaf&quot; =&gt; ToyLeafCarbonCaptureModel(),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 4 entries:
  &quot;Internode&quot; =&gt; (MultiScaleModel{ToyCustomInternodeEmergence{Float64}, Vector{…
  &quot;Scene&quot;     =&gt; ToyDegreeDaysCumulModel(0.0, 10.0, 43.0)
  &quot;Plant&quot;     =&gt; (MultiScaleModel{ToyStockComputationModel, Vector{Pair{Union{S…
  &quot;Leaf&quot;      =&gt; ToyLeafCarbonCaptureModel()</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This excerpt (and the complete script file) showcase the final properly initialized mapping, but when developing, you are encouraged to make liberal use of the helper function <a href="../../API/API_public/#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a> and check the PlantSimEngine user errors.</p></div></div><h3 id="Running-a-simulation"><a class="docs-heading-anchor" href="#Running-a-simulation">Running a simulation</a><a id="Running-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-simulation" title="Permalink"></a></h3><p>We only need an MTG, and some weather data, and then we&#39;ll be set. Let&#39;s create a simple MTG : </p><pre><code class="language-julia hljs"> mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(&quot;/&quot;, &quot;Scene&quot;, 1, 0))
    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(&quot;+&quot;, &quot;Plant&quot;, 1, 1))

    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(&quot;/&quot;, &quot;Internode&quot;, 1, 2))
    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 1, 2))
    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 1, 2))

    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(&quot;&lt;&quot;, &quot;Internode&quot;, 1, 2))
    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 1, 2))
    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 1, 2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">+ 8: Leaf
</code></pre><p>Import some weather data : </p><pre><code class="language-julia hljs">meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), &quot;examples/meteo_day.csv&quot;), DataFrame, header=18)</code></pre><p>And we&#39;re good to go ! </p><pre><code class="language-julia hljs">outs = run!(mtg, mapping, meteo_day)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Dict{Symbol, Vector}} with 4 entries:
  &quot;Internode&quot; =&gt; Dict(:TT_cu=&gt;[[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], …
  &quot;Scene&quot;     =&gt; Dict(:TT_cu=&gt;[[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0],…
  &quot;Plant&quot;     =&gt; Dict(:carbon_organ_creation_consumed=&gt;Vector{RefVector{Float64…
  &quot;Leaf&quot;      =&gt; Dict(:node=&gt;Vector{Node{NodeMTG, Dict{Symbol, Any}}}[[+ 4: Lea…</code></pre><p>If you query or display the MTG after simulation, you&#39;ll see it expanded and grew multiple internodes and leaves :</p><pre><code class="language-julia hljs">mtg
#get_n_leaves(mtg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Scene
└─ + 2: Plant
   └─ / 3: Internode
      ├─ + 4: Leaf
      ├─ + 5: Leaf
      └─ &lt; 6: Internode
         ├─ + 7: Leaf
         ├─ + 8: Leaf
         └─ &lt; 9: Internode
            ├─ + 10: Leaf
            ├─ + 11: Leaf
            └─ &lt; 12: Internode
               ├─ + 13: Leaf
               ├─ + 14: Leaf
               └─ &lt; 15: Internode
                  ├─ + 16: Leaf
                  ├─ + 17: Leaf
                  └─ &lt; 18: Internode
                     ├─ + 19: Leaf
                     ├─ + 20: Leaf
                     └─ &lt; 21: Internode
                        ├─ + 22: Leaf
                        ├─ + 23: Leaf
                        └─ &lt; 24: Internode
…</code></pre><p>And that&#39;s it ! Feel free to tinker with the parameters and see when things break down, to get a feel for the simulation.</p><p>Of course, this is a very crude and unrealistic simulation, with many dubious assumptions and parameters. But significantly more complex modelling is possible using the same approach : XPalm runs using a few dozen models spread out over nine scales.</p><p>This is a three-part tutorial and continues in the <a href="../multiscale_example_2/#Expanding-on-the-multiscale-simulation">Expanding on the multiscale simulation</a> page.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multiscale_coupling/">« Multiscale coupling considerations</a><a class="docs-footer-nextpage" href="../multiscale_example_2/">Expanding the plant simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Thursday 20 March 2025 16:05">Thursday 20 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
