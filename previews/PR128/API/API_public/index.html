<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · PlantSimEngine.jl</title><meta name="title" content="Public API · PlantSimEngine.jl"/><meta property="og:title" content="Public API · PlantSimEngine.jl"/><meta property="twitter:title" content="Public API · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_public/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_public/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_public/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../../multiscale/multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../../multiscale/single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../../multiscale/multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../../multiscale/multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../../multiscale/multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../multiscale/multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li><li><a class="tocitem" href="../../multiscale/multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API-documentation"><span>API documentation</span></a></li></ul></li><li><a class="tocitem" href="../API_examples/">Example models</a></li><li><a class="tocitem" href="../API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../credits/">Credits</a></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/API/API_public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><code>PlantMeteo.TimeStepTable</code></a></li><li><a href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a></li><li><a href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a></li><li><a href="#PlantSimEngine.MultiScaleModel"><code>PlantSimEngine.MultiScaleModel</code></a></li><li><a href="#PlantSimEngine.PreviousTimeStep"><code>PlantSimEngine.PreviousTimeStep</code></a></li><li><a href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a></li><li><a href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a></li><li><a href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a></li><li><a href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a></li><li><a href="#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}"><code>PlantSimEngine.add_organ!</code></a></li><li><a href="#PlantSimEngine.convert_outputs-Tuple{Dict{String}, Any}"><code>PlantSimEngine.convert_outputs</code></a></li><li><a href="#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a></li><li><a href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a></li><li><a href="#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a></li><li><a href="#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a></li><li><a href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a></li><li><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a></li><li><a href="#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.inputs</code></a></li><li><a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a></li><li><a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a></li><li><a href="#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.outputs</code></a></li><li><a href="#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a></li><li><a href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a></li><li><a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a></li><li><a href="#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a></li></ul><h2 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status" href="#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><code>PlantMeteo.TimeStepTable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeStepTable{Status}(df::DataFrame)</code></pre><p>Method to build a <code>TimeStepTable</code> (from <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/">PlantMeteo.jl</a>)  from a <code>DataFrame</code>, but with each row being a <code>Status</code>.</p><p><strong>Note</strong></p><p><a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a> uses <code>TimeStepTable{Status}</code> by default (see examples below).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, DataFrames

# A TimeStepTable from a DataFrame:
df = DataFrame(
    Tₗ=[25.0, 26.0],
    aPPFD=[1000.0, 1200.0],
    Cₛ=[400.0, 400.0],
    Dₗ=[1.0, 1.2],
)
TimeStepTable{Status}(df)

# A leaf with several values for at least one of its variable will automatically use 
# TimeStepTable{Status} with the time steps:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# The status of the leaf is a TimeStepTable:
status(models)

# Of course we can also create a TimeStepTable with Status manually:
TimeStepTable(
    [
        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),
        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/component_models/TimeStepTable.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.AbstractModel" href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract model type. All models are subtypes of this one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/Abstract_model_structs.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.ModelList" href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModelList(models::M, status::S)
ModelList(;
    status=nothing,
    type_promotion=nothing,
    variables_check=true,
    kwargs...
)</code></pre><p>List the models for a simulation (<code>models</code>), and does all boilerplate for variable initialization,  type promotion, time steps handling.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The status field depends on the input models. You can get the variables needed by a model using <a href="#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a> on the instantiation of a model. You can also use <a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> instead.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>models</code>: a list of models. Usually given as a <code>NamedTuple</code>, but can be any other structure that </li></ul><p>implements <code>getproperty</code>.</p><ul><li><code>status</code>: a structure containing the initializations for the variables of the models. Usually a NamedTuple</li></ul><p>when given as a kwarg, or any structure that implements the Tables interface from <code>Tables.jl</code> (<em>e.g.</em> DataFrame, see details).</p><ul><li><code>type_promotion</code>: optional type conversion for the variables with default values.</li></ul><p><code>nothing</code> by default, <em>i.e.</em> no conversion. Note that conversion is not applied to the variables input by the user as <code>kwargs</code> (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.</p><ul><li><code>variables_check=true</code>: check that all needed variables are initialized by the user.</li><li><code>kwargs</code>: the models, named after the process they simulate.</li></ul><p><strong>Details</strong></p><p>If you need to input a custom Type for the status and make your users able to only partially initialize  the <code>status</code> field in the input, you&#39;ll have to implement a method for <code>add_model_vars!</code>, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the <code>Tables.jl</code> interface (<em>e.g.</em> DataFrame), and <code>NamedTuples</code>.</p><p>Note that <code>ModelList</code>makes a copy of the input <code>status</code> if it does not list all needed variables.</p><p><strong>Examples</strong></p><p>We&#39;ll use the dummy models from the <code>dummy.jl</code> in the examples folder of the package. It  implements three dummy processes: <code>Process1Model</code>, <code>Process2Model</code> and <code>Process3Model</code>, with one model implementation each: <code>Process1Model</code>, <code>Process2Model</code> and <code>Process3Model</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>Including example processes and models:</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());
[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; typeof(models)
ModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}</code></pre><p>No variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually <code>typemin(Type)</code>, <em>i.e.</em> <code>-Inf</code> for floating point numbers). This component cannot be simulated yet.</p><p>To know which variables we need to initialize for a simulation, we use <a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; to_initialize(models)
(process1 = (:var1, :var2), process2 = (:var1,))</code></pre><p>We can now provide values for these variables in the <code>status</code> field, and simulate the <code>ModelList</code>,  <em>e.g.</em> for <code>process3</code> (coupled with <code>process1</code> and <code>process2</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim = run!(models,meteo)
TimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):
╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮
│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │
│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │
├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │
╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯</code></pre><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim[:var6]
1-element Vector{Float64}:
 58.0138985</code></pre><p>If we want to use special types for the variables, we can use the <code>type_promotion</code> argument:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>We used <code>type_promotion</code> to force the status into Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float64
 Float64
 Float32</code></pre><p>But we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>We used <code>type_promotion</code> to force the status into Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float32
 Float32
 Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/component_models/ModelList.jl#L2-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.MultiScaleModel" href="#PlantSimEngine.MultiScaleModel"><code>PlantSimEngine.MultiScaleModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiScaleModel(model, mapped_variables)</code></pre><p>A structure to make a model multi-scale. It defines a mapping between the variables of a  model and the nodes symbols from which the values are taken from.</p><p><strong>Arguments</strong></p><ul><li><code>model&lt;:AbstractModel</code>: the model to make multi-scale</li><li><code>mapped_variables&lt;:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}</code>: a vector of pairs of symbols and strings or vectors of strings</li></ul><p>The mapped_variables argument can be of the form:</p><ol><li><code>[:variable_name =&gt; &quot;Plant&quot;]</code>: We take one value from the Plant node</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot;]]</code>: We take a vector of values from the Leaf nodes</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]]</code>: We take a vector of values from the Leaf and Internode nodes</li><li><code>[:variable_name =&gt; &quot;Plant&quot; =&gt; :variable_name_in_plant_scale]</code>: We take one value from another variable name in the Plant node</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot; =&gt; :variable_name_1, &quot;Internode&quot; =&gt; :variable_name_2]]</code>: We take a vector of values from the Leaf and Internode nodes with different names</li><li><code>[PreviousTimeStep(:variable_name) =&gt; ...]</code>: We flag the variable to be initialized with the value from the previous time step, and we do not use it to build the dep graph</li><li><code>[:variable_name =&gt; :variable_name_from_another_model]</code>: We take the value from another model at the same scale but rename it</li><li><code>[PreviousTimeStep(:variable_name),]</code>: We just flag the variable as a PreviousTimeStep to not use it to build the dep graph</li></ol><p>Details about the different forms:</p><ol><li>The variable <code>variable_name</code> of the model will be taken from the <code>Plant</code> node, assuming only one node has the <code>Plant</code> symbol.</li></ol><p>In this case the value available from the status will be a scalar, and so the user must guaranty that only one node of type <code>Plant</code> is available in the MTG.</p><ol><li>The variable <code>variable_name</code> of the model will be taken from the <code>Leaf</code> nodes. Notice it is given as a vector, indicating that the values will be taken </li></ol><p>from all the nodes of type <code>Leaf</code>. The model should be able to handle a vector of values. Note that even if there is only one node of type <code>Leaf</code>, the value will be taken as a vector of one element.</p><ol><li>The variable <code>variable_name</code> of the model will be taken from the <code>Leaf</code> and <code>Internode</code> nodes. The values will be taken from all the nodes of type <code>Leaf</code> </li></ol><p>and <code>Internode</code>.</p><ol><li>The variable <code>variable_name</code> of the model will be taken from the variable called <code>variable_name_in_plant_scale</code> in the <code>Plant</code> node. This is useful</li></ol><p>when the variable name in the model is different from the variable name in the scale it is taken from.</p><ol><li><p>The variable <code>variable_name</code> of the model will be taken from the variable called <code>variable_name_1</code> in the <code>Leaf</code> node and <code>variable_name_2</code> in the <code>Internode</code> node.</p></li><li><p>The variable <code>variable_name</code> of the model uses the value computed on the previous time-step. This implies that the variable is not used to build the dependency graph</p></li></ol><p>because the dependency graph only applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.</p><ol><li><p>The variable <code>variable_name</code> of the model will be taken from another model at the same scale, but with another variable name.</p></li><li><p>The variable <code>variable_name</code> of the model is just flagged as a PreviousTimeStep variable, so it is not used to build the dependency graph.</p></li></ol><p>Note that the mapping does not make any copy of the values, it only references them. This means that if the values are updated in the status of one node, they will be updated in the other nodes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>Including example processes and models:</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>Let&#39;s take a model:</p><pre><code class="language-julia-repl hljs">julia&gt; model = ToyCAllocationModel()
ToyCAllocationModel()</code></pre><p>We can make it multi-scale by defining a mapping between the variables of the model and the nodes symbols from which the values are taken from:</p><p>For example, if the <code>carbon_allocation</code> comes from the <code>Leaf</code> and <code>Internode</code> nodes, we can define the mapping as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; mapped_variables=[:carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]]
1-element Vector{Pair{Symbol, Vector{String}}}:
 :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]</code></pre><p>The mapped<em>variables argument is a vector of pairs of symbols and strings or vectors of strings. In this case, we have only one pair to define the mapping between the `carbon</em>allocation<code>variable and the</code>Leaf<code>and</code>Internode` nodes.</p><p>We can now make the model multi-scale by passing the model and the mapped variables to the <code>MultiScaleModel</code> constructor :</p><pre><code class="language-julia-repl hljs">julia&gt; multiscale_model = PlantSimEngine.MultiScaleModel(model, mapped_variables)
MultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation =&gt; [&quot;Leaf&quot; =&gt; :carbon_allocation, &quot;Internode&quot; =&gt; :carbon_allocation]])</code></pre><p>We can access the mapped variables and the model:</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.mapped_variables_(multiscale_model)
1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:
 :carbon_allocation =&gt; [&quot;Leaf&quot; =&gt; :carbon_allocation, &quot;Internode&quot; =&gt; :carbon_allocation]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.model_(multiscale_model)
ToyCAllocationModel()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/mtg/MultiScaleModel.jl#L1-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.PreviousTimeStep" href="#PlantSimEngine.PreviousTimeStep"><code>PlantSimEngine.PreviousTimeStep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PreviousTimeStep(variable)</code></pre><p>A structure to manually flag a variable in a model to use the value computed on the previous time-step.  This implies that the variable is not used to build the dependency graph because the dependency graph only  applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.</p><p>The process is added when building the MultiScaleModel, to avoid conflicts between processes with the same variable name. For exemple one process can define a variable <code>:carbon_biomass</code> as a <code>PreviousTimeStep</code>, but the othe process would use  the variable as a dependency for the current time-step (and it would be fine because theyr don&#39;t share the same issue of cyclic dependency).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/variables_wrappers.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.Status" href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Status(vars)</code></pre><p>Status type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the <code>TimeStepRow</code> of a <code>TimeStepTable</code> (see  <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/"><code>PlantMeteo.jl</code> docs</a>) of a <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a>.</p><p>Most of the code is taken from MasonProtter/MutableNamedTuples.jl, so <code>Status</code> is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a <code>NamedTuple</code> of the references to the values of the variables, which makes it mutable.</p><p><strong>Examples</strong></p><p>A leaf with one value for all variables will make a status with one time step:</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);</code></pre><p>All these indexing methods are valid:</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Rₛ]
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Rₛ
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1]
13.747</code></pre><p>Setting a Status variable is very easy:</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Rₛ] = 20.0
20.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Rₛ = 21.0
21.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1] = 22.0
22.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/component_models/Status.jl#L1-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.EF-Tuple{Any, Any}" href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EF(obs,sim)</code></pre><p>Returns the Efficiency Factor between observations <code>obs</code> and simulations <code>sim</code> using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe<em>model</em>efficiency_coefficient.</p><p>The closer to 1 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

EF(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/evaluation/statistics.jl#L45-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.NRMSE-Tuple{Any, Any}" href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NRMSE(obs,sim)</code></pre><p>Returns the Normalized Root Mean Squared Error between observations <code>obs</code> and simulations <code>sim</code>. Normalization is performed using division by observations range (max-min).</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

NRMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/evaluation/statistics.jl#L24-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.RMSE-Tuple{Any, Any}" href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RMSE(obs,sim)</code></pre><p>Returns the Root Mean Squared Error between observations <code>obs</code> and simulations <code>sim</code>.</p><p>The closer to 0 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

RMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/evaluation/statistics.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}" href="#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}"><code>PlantSimEngine.add_organ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)</code></pre><p>Add an organ to the graph, automatically taking care of initialising the status of the organ (multiscale-)variables.</p><p>This function should be called from a model that implements organ emergence, for example in function of thermal time.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the node to which the organ is added (the parent organ of the new organ)</li><li><code>sim_object</code>: the simulation object, e.g. the <code>GraphSimulation</code> object from the <code>extra</code> argument of a model.</li><li><code>link</code>: the link type between the new node and the organ:<ul><li><code>&quot;&lt;&quot;</code>: the new node is following the parent organ</li><li><code>&quot;+&quot;</code>: the new node is branching the parent organ</li><li><code>&quot;/&quot;</code>: the new node is decomposing the parent organ, <em>i.e.</em> we change scale</li></ul></li><li><code>symbol</code>: the symbol of the organ, <em>e.g.</em> <code>&quot;Leaf&quot;</code></li><li><code>scale</code>: the scale of the organ, <em>e.g.</em> <code>2</code>.</li><li><code>index</code>: the index of the organ, <em>e.g.</em> <code>1</code>. The index may be used to easily identify branching order, or growth unit index on the axis. It is different from the node <code>id</code> that is unique.</li><li><code>id</code>: the unique id of the new node. If not provided, a new id is generated.</li><li><code>attributes</code>: the attributes of the new node. If not provided, an empty dictionary is used.</li><li><code>check</code>: a boolean indicating if variables initialisation should be checked. Passed to <code>init_node_status!</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>status</code>: the status of the new node</li></ul><p><strong>Examples</strong></p><p>See the <code>ToyInternodeEmergence</code> example model from the <code>Examples</code> module (also found in the <code>examples</code> folder), or the <code>test-mtg-dynamic.jl</code> test file for an example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/mtg/add_organ.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.convert_outputs-Tuple{Dict{String}, Any}" href="#PlantSimEngine.convert_outputs-Tuple{Dict{String}, Any}"><code>PlantSimEngine.convert_outputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_outputs(sim_outputs::Dict{String,O} where O, sink; refvectors=false, no_value=nothing)
convert_outputs(sim_outputs::TimeStepTable{T} where T, sink)</code></pre><p>Convert the outputs returned by a simulation made on a plant graph into another format.</p><p><strong>Details</strong></p><p>The first method operates on the outputs of a multiscale simulation, the second one on those of a typical single-scale simulation.  The sink function determines the format used, for exemple a <code>DataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim_outputs : the outputs of a prior simulation, typically returned by</code>run!`.</li><li><code>sink</code>: a sink compatible with the Tables.jl interface (<em>e.g.</em> a <code>DataFrame</code>)</li><li><code>refvectors</code>: if <code>false</code> (default), the function will remove the RefVector values, otherwise it will keep them</li><li><code>no_value</code>: the value to replace <code>nothing</code> values. Default is <code>nothing</code>. Usually used to replace <code>nothing</code> values </li></ul><p>by <code>missing</code> in DataFrames.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine, MultiScaleTreeGraph, DataFrames, PlantSimEngine.Examples</code></pre><p>Import example models (can be found in the <code>examples</code> folder of the package, or in the <code>Examples</code> sub-modules): </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><pre><code class="language- hljs">mapping = Dict( &quot;Plant&quot; =&gt;  ( MultiScaleModel(  model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], ), 
        MultiScaleModel(  model=ToyPlantRmModel(), mapped_variables=[:Rm_organs =&gt; [&quot;Leaf&quot; =&gt; :Rm, &quot;Internode&quot; =&gt; :Rm],] ), ),&quot;Internode&quot; =&gt; ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0) ), &quot;Leaf&quot; =&gt; ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0), ), &quot;Soil&quot; =&gt; ( ToySoilWaterModel(), ), )</code></pre><pre><code class="language- hljs">mtg = import_mtg_example();</code></pre><pre><code class="language- hljs">out = run!(mtg, mapping, meteo, tracked_outputs = Dict(
    &quot;Leaf&quot; =&gt; (:carbon_assimilation, :carbon_demand, :soil_water_content, :carbon_allocation),
    &quot;Internode&quot; =&gt; (:carbon_allocation,),
    &quot;Plant&quot; =&gt; (:carbon_allocation,),
    &quot;Soil&quot; =&gt; (:soil_water_content,),
));</code></pre><pre><code class="language- hljs">convert_outputs(out, DataFrames)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/mtg/GraphSimulation.jl#L42-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.dep" href="#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dep(m::ModelList, nsteps=1; verbose::Bool=true)
dep(mapping::Dict{String,T}; verbose=true)</code></pre><p>Get the model dependency graph given a ModelList or a multiscale model mapping. If one graph is returned,  then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. <code>nsteps</code> is the number of steps the dependency graph will be used over. It is used to determine the length of the <code>simulation_id</code> argument for each soft dependencies in the graph. It is set to <code>1</code> in the case of a  multiscale mapping.</p><p><strong>Details</strong></p><p>The dependency graph is computed by searching the inputs of each process in the outputs of its own scale, or the other scales. There are five cases for every model (one model simulates one process):</p><ol><li>The process has no inputs. It is completely independent, and is placed as one of the roots of the dependency graph.</li><li>The process needs inputs from models at its own scale. We put it as a child of this other process.</li><li>The process needs inputs from another scale. We put it as a child of this process at another scale.</li><li>The process needs inputs from its own scale and another scale. We put it as a child of both.</li><li>The process is a hard dependency of another process (only possible at the same scale). In this case, the process is set as a hard-dependency of the </li></ol><p>other process, and its simulation is handled directly from this process.</p><p>For the 4th case, the process have two parent processes. This is OK because the process will only be computed once during simulation as we check if both  parents were run before running the process. </p><p>Note that in the 5th case, we still need to check if a variable is needed from another scale. In this case, the parent node is  used as a child of the process at the other scale. Note there can be several levels of hard dependency graph, so this is done recursively.</p><p>How do we do all that? We identify the hard dependencies first. Then we link the inputs/outputs of the hard dependencies roots  to other scales if needed. Then we transform all these nodes into soft dependencies, that we put into a Dict of Scale =&gt; Dict(process =&gt; SoftDependencyNode). Then we traverse all these and we set nodes that need outputs from other nodes as inputs as children/parents. If a node has no dependency, it is set as a root node and pushed into a new Dict (independant<em>process</em>root). This Dict is the returned dependency graph. And  it presents root nodes as independent starting points for the sub-graphs, which are the models that are coupled together. We can then traverse each of  these graphs independently to retrieve the models that are coupled together, in the right order of execution.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including example processes and models:
using PlantSimEngine.Examples;

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

dep(models)

# or directly with the processes:
models = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

dep(;models...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/dependencies/dependencies.jl#L3-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.dr-Tuple{Any, Any}" href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dr(obs,sim)</code></pre><p>Returns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419</p><p>The closer to 1 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

dr(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/evaluation/statistics.jl#L70-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.fit" href="#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit()</code></pre><p>Optimize the parameters of a model using measurements and (potentially) initialisation values. </p><p>Modellers should implement a method to <code>fit</code> for their model, with the following design pattern:</p><p>The call to the function should take the model type as the first argument (T::Type{&lt;:AbstractModel}),  the data as the second argument (as a <code>Table.jl</code> compatible type, such as <code>DataFrame</code>), and the  parameters initializations as keyword arguments (with default values when necessary).</p><p>For example the method for fitting the <code>Beer</code> model from the example script (see <code>src/examples/Beer.jl</code>) looks like  this:</p><pre><code class="language-julia hljs">function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)
    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)
    return (k=k,)
end</code></pre><p>The function should return the optimized parameters as a <code>NamedTuple</code> of the form <code>(parameter_name=parameter_value,)</code>.</p><p>Here is an example usage with the <code>Beer</code> model, where we fit the <code>k</code> parameter from &quot;measurements&quot; of <code>PPFD</code>, <code>LAI</code>  and <code>Ri_PAR_f</code>. </p><pre><code class="language-julia hljs"># Including example processes and models:
using PlantSimEngine.Examples;

m = ModelList(Beer(0.6), status=(LAI=2.0,))
meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)
run!(m, meteo)
df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])
fit(Beer, df)</code></pre><p>Note that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of <code>k=0.6</code>, and then use the simulated PPFD to fit the <code>k</code> parameter again, which gives the same value as the one used on the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/evaluation/fit.jl#L2-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}" href="#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_status!(object::Dict{String,ModelList};vars...)
init_status!(component::ModelList;vars...)</code></pre><p>Initialise model variables for components with user input.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
    )
)

init_status!(models, var1=1.0 , var2=2.0)
status(models[&quot;Leaf&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/model_initialisation.jl#L165-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_variables(models...)</code></pre><p>Initialized model variables with their default values. The variables are taken from the inputs and outputs of the models.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

init_variables(Process1Model(2.0))
init_variables(process1=Process1Model(2.0), process2=Process2Model())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/model_initialisation.jl#L219-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inputs(model::AbstractModel)
inputs(...)</code></pre><p>Get the inputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no inputs) or <code>Missing</code> models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

inputs(Process1Model(1.0))

# output
(:var1, :var2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T" href="#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inputs(mapping::Dict{String,T})</code></pre><p>Get the inputs of the models in a mapping, for each process and organ type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList" href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_initialized(m::T) where T &lt;: ModelList
is_initialized(m::T, models...) where T &lt;: ModelList</code></pre><p>Check if the variables that must be initialized are, and return <code>true</code> if so, and <code>false</code> and an information message if not.</p><p><strong>Note</strong></p><p>There is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

is_initialized(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/model_initialisation.jl#L271-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outputs(model::AbstractModel)
outputs(...)</code></pre><p>Get the outputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no outputs) or <code>Missing</code> models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

outputs(Process1Model(1.0))

# output
(:var3,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L54-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T" href="#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outputs(mapping::Dict{String,T})</code></pre><p>Get the outputs of the models in a mapping, for each process and organ type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.run!" href="#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())
run!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)</code></pre><p>Run the simulation for each model in the model list in the correct order, <em>i.e.</em> respecting the dependency graph.</p><p>If several time-steps are given, the models are run sequentially for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>object</code>: a <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a>, an array or dict of <code>ModelList</code>, or a plant graph (MTG).</li><li><code>meteo</code>: a <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.TimeStepTable"><code>PlantMeteo.TimeStepTable</code></a> of </li></ul><p><a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Atmosphere"><code>PlantMeteo.Atmosphere</code></a> or a single <code>PlantMeteo.Atmosphere</code>.</p><ul><li><code>constants</code>: a <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Constants"><code>PlantMeteo.Constants</code></a> object, or a <code>NamedTuple</code> of constant keys and values.</li><li><code>extra</code>: extra parameters, not available for simulation of plant graphs (the simulation object is passed using this).</li><li><code>check</code>: if <code>true</code>, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.</li><li><code>executor</code>: the <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> executor used to run the simulation either in sequential (<code>executor=SequentialEx()</code>), in a </li></ul><p>multi-threaded way (<code>executor=ThreadedEx()</code>, the default), or in a distributed way (<code>executor=DistributedEx()</code>).</p><ul><li><code>mapping</code>: a mapping between the MTG and the model list.</li><li><code>nsteps</code>: the number of time-steps to run, only needed if no meteo is given (else it is infered from it).</li><li><code>outputs</code>: the outputs to get in dynamic for each node type of the MTG.</li></ul><p><strong>Returns</strong></p><p>Modifies the status of the object in-place. Users may retrieve the results from the object using  the <a href="https://virtualplantlab.github.io/PlantSimEngine.jl/stable/API/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a>  function (see examples).</p><p><strong>Details</strong></p><p><strong>Model execution</strong></p><p>The models are run according to the dependency graph. If a model has a soft dependency on another model (<em>i.e.</em> its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.</p><p><strong>Parallel execution</strong></p><p>Users can ask for parallel execution by providing a compatible executor to the <code>executor</code> argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> package to run the simulation in parallel. That means that you can provide any compatible executor to the <code>executor</code> argument. You can take a look at <a href="https://github.com/JuliaFolds/FoldsThreads.jl">FoldsThreads.jl</a> for extra thread-based executors, <a href="https://github.com/JuliaFolds/FoldsDagger.jl">FoldsDagger.jl</a> for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon <a href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a> for GPU computations  (see <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/issues/22">this issue</a>) and <a href="https://github.com/JuliaFolds/FoldsKernelAbstractions.jl">FoldsKernelAbstractions.jl</a>. You can also take a look at  <a href="https://github.com/JuliaFolds/ParallelMagics.jl">ParallelMagics.jl</a> to check if automatic parallelization is possible.</p><p><strong>Example</strong></p><p>Import the packages: </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo;</code></pre><p>Load the dummy models given as example in the <code>Examples</code> sub-module:</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>Create a model list:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));</code></pre><p>Create meteo data:</p><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);</code></pre><p>Run the simulation:</p><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim = run!(models, meteo);</code></pre><p>Get the results:</p><pre><code class="language-julia-repl hljs">julia&gt; (outputs_sim[:var4],outputs_sim[:var6])
([12.0], [41.95])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/run.jl#L1-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.status-Tuple{Any}" href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">status(m)
status(m::AbstractArray{&lt;:ModelList})
status(m::AbstractDict{T,&lt;:ModelList})</code></pre><p>Get a ModelList status, <em>i.e.</em> the state of the input (and output) variables.</p><p>See also <a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>is_initialized</code></a> and <a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Including example models and processes:
using PlantSimEngine.Examples;

# Create a ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

status(models)

# Or just one variable:
status(models,:var1)


# Or the status at the ith time-step:
status(models, 2)

# Or even more simply:
models[:var1]
# output
2-element Vector{Float64}:
 15.0
 16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/component_models/get_status.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.to_initialize-Tuple{ModelList}" href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_initialize(; verbose=true, vars...)
to_initialize(m::T)  where T &lt;: ModelList
to_initialize(m::DependencyGraph)
to_initialize(mapping::Dict{String,T}, graph=nothing)</code></pre><p>Return the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.</p><p><strong>Arguments</strong></p><ul><li><code>verbose</code>: if <code>true</code>, print information messages.</li><li><code>vars...</code>: the models and processes to consider.</li><li><code>m::T</code>: a <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a>.</li><li><code>m::DependencyGraph</code>: a <a href="../API_private/#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a>.</li><li><code>mapping::Dict{String,T}</code>: a mapping that associates models to organs.</li><li><code>graph</code>: a graph representing a plant or a scene, <em>e.g.</em> a multiscale tree graph. The graph is used to check if variables that are not initialized can be found in the graph nodes attributes.</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

to_initialize(process1=Process1Model(1.0), process2=Process2Model())

# Or using a component directly:
models = ModelList(process1=Process1Model(1.0), process2=Process2Model())
to_initialize(models)

m = ModelList(
    (
        process1=Process1Model(1.0),
        process2=Process2Model()
    ),
    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)
)

to_initialize(m)</code></pre><p>Or with a mapping:</p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

mapping = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;Internode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
    )
)

to_initialize(mapping)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/model_initialisation.jl#L1-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables-Tuple{Module}" href="#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables(pkg::Module)</code></pre><p>Returns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).</p><p><strong>Note to developers</strong></p><p>Developers of a package that depends on PlantSimEngine should  put a csv file in &quot;data/variables.csv&quot;, then this file will be  returned by the function.</p><p><strong>Examples</strong></p><p>Here is an example with the PlantBiophysics package:</p><pre><code class="language-julia hljs">#] add PlantBiophysics
using PlantBiophysics
variables(PlantBiophysics)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L153-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T" href="#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables(mapping::Dict{String,T})</code></pre><p>Get the variables (inputs and outputs) of the models in a mapping, for each  process and organ type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}" href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables(model)
variables(model, models...)</code></pre><p>Returns a tuple with the name of the variables needed by a model, or a union of those variables for several models.</p><p><strong>Note</strong></p><p>Each model can (and should) have a method for this function.</p><pre><code class="language-julia hljs">
using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

variables(Process1Model(1.0))

variables(Process1Model(1.0), Process2Model())

# output

(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)</code></pre><p><strong>See also</strong></p><p><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="../API_private/#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>variables_typed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/models_inputs_outputs.jl#L108-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.@process-Tuple{Any, Vararg{Any}}" href="#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@process(process::String, doc::String=&quot;&quot;; verbose::Bool=true)</code></pre><p>This macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if <code>verbose=true</code>.</p><p>The abstract process type is then used as a supertype of all models implementations for the  process, and is named &quot;Abstract&lt;ProcessName&gt;Model&quot;, <em>e.g.</em> <code>AbstractGrowthModel</code> for a process called growth.</p><p>The first argument to <code>@process</code> is the new process name,  the second is any additional documentation that should be added  to the <code>Abstract&lt;ProcessName&gt;Model</code> type, and the third determines whether  the short tutorial should be printed or not.</p><p>Newcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of <code>AbstractModel</code>:</p><pre><code class="language-julia hljs">abstract type MyNewProcess &lt;: AbstractModel end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@process &quot;dummy_process&quot; &quot;This is a dummy process that shall not be used&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/8d9c47c53be6c80799a0a911d6dc576965e6112e/src/processes/process_generation.jl#L1-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../troubleshooting_and_testing/implicit_contracts/">« Implicit contracts</a><a class="docs-footer-nextpage" href="../API_examples/">Example models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 21 March 2025 07:49">Friday 21 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
