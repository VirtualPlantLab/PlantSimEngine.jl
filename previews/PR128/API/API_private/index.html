<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API · PlantSimEngine.jl</title><meta name="title" content="Internal API · PlantSimEngine.jl"/><meta property="og:title" content="Internal API · PlantSimEngine.jl"/><meta property="twitter:title" content="Internal API · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_private/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_private/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API/API_private/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../../multiscale/multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../../multiscale/single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../../multiscale/multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../../multiscale/multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../../multiscale/multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../multiscale/multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API_public/">Public API</a></li><li class="is-active"><a class="tocitem" href>Internal API</a><ul class="internal"><li><a class="tocitem" href="#Un-exported"><span>Un-exported</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API-documentation"><span>API documentation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../credits/">Credits</a></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Internal API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/API/API_private.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-internal-functions"><a class="docs-heading-anchor" href="#API-internal-functions">API - internal functions</a><a id="API-internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#API-internal-functions" title="Permalink"></a></h1><h2 id="Un-exported"><a class="docs-heading-anchor" href="#Un-exported">Un-exported</a><a id="Un-exported-1"></a><a class="docs-heading-anchor-permalink" href="#Un-exported" title="Permalink"></a></h2><p>Private functions, types or constants from <code>PlantSimEngine</code>. These are not exported, so you need to use <code>PlantSimEngine.</code> to access them (<em>e.g.</em> <code>PlantSimEngine.DataFormat</code>). Most of them are developer code, but some may be useful for tinkerers, or to have greater control over some simulation parameters (future versions of this documentation might break those categories into separate pages for clarity).</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>DataFrames.DataFrame</code></a></li><li><a href="#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><code>DataFrames.DataFrame</code></a></li><li><a href="#PlantSimEngine.AbstractBasic_Current_TimestepModel"><code>PlantSimEngine.AbstractBasic_Current_TimestepModel</code></a></li><li><a href="#PlantSimEngine.AbstractBasic_Next_TimestepModel"><code>PlantSimEngine.AbstractBasic_Next_TimestepModel</code></a></li><li><a href="#PlantSimEngine.AbstractNodeMapping"><code>PlantSimEngine.AbstractNodeMapping</code></a></li><li><a href="#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a></li><li><a href="#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a></li><li><a href="#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a></li><li><a href="#PlantSimEngine.GraphSimulation"><code>PlantSimEngine.GraphSimulation</code></a></li><li><a href="#PlantSimEngine.MappedVar"><code>PlantSimEngine.MappedVar</code></a></li><li><a href="#PlantSimEngine.MultiNodeMapping"><code>PlantSimEngine.MultiNodeMapping</code></a></li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a></li><li><a href="#PlantSimEngine.RefVariable"><code>PlantSimEngine.RefVariable</code></a></li><li><a href="#PlantSimEngine.RefVector"><code>PlantSimEngine.RefVector</code></a></li><li><a href="#PlantSimEngine.SelfNodeMapping"><code>PlantSimEngine.SelfNodeMapping</code></a></li><li><a href="#PlantSimEngine.SingleNodeMapping"><code>PlantSimEngine.SingleNodeMapping</code></a></li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a></li><li><a href="#PlantSimEngine.UninitializedVar"><code>PlantSimEngine.UninitializedVar</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><code>Base.copy</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>Base.copy</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:ModelList"><code>Base.copy</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><code>Base.getindex</code></a></li><li><a href="#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}"><code>PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!</code></a></li><li><a href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a></li><li><a href="#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a></li><li><a href="#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}"><code>PlantSimEngine.convert_reference_values!</code></a></li><li><a href="#PlantSimEngine.convert_vars"><code>PlantSimEngine.convert_vars</code></a></li><li><a href="#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}"><code>PlantSimEngine.convert_vars!</code></a></li><li><a href="#PlantSimEngine.convert_vars!"><code>PlantSimEngine.convert_vars!</code></a></li><li><a href="#PlantSimEngine.default_variables_from_mapping"><code>PlantSimEngine.default_variables_from_mapping</code></a></li><li><a href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a></li><li><a href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a></li><li><a href="#PlantSimEngine.draw_panel-NTuple{5, Any}"><code>PlantSimEngine.draw_panel</code></a></li><li><a href="#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a></li><li><a href="#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a></li><li><a href="#PlantSimEngine.get_mapped_variables-Tuple{Any}"><code>PlantSimEngine.get_mapped_variables</code></a></li><li><a href="#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}"><code>PlantSimEngine.get_model_nodes</code></a></li><li><a href="#PlantSimEngine.get_models-Tuple{Any}"><code>PlantSimEngine.get_models</code></a></li><li><a href="#PlantSimEngine.get_multiscale_default_value"><code>PlantSimEngine.get_multiscale_default_value</code></a></li><li><a href="#PlantSimEngine.get_nsteps-Tuple{Any}"><code>PlantSimEngine.get_nsteps</code></a></li><li><a href="#PlantSimEngine.get_status-Tuple{Any}"><code>PlantSimEngine.get_status</code></a></li><li><a href="#PlantSimEngine.hard_dependencies-Tuple{Any}"><code>PlantSimEngine.hard_dependencies</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.init_node_status!"><code>PlantSimEngine.init_node_status!</code></a></li><li><a href="#PlantSimEngine.init_simulation-Tuple{Any, Any}"><code>PlantSimEngine.init_simulation</code></a></li><li><a href="#PlantSimEngine.init_statuses"><code>PlantSimEngine.init_statuses</code></a></li><li><a href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a></li><li><a href="#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}"><code>PlantSimEngine.initialise_all_as_hard_dependency_node</code></a></li><li><a href="#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}"><code>PlantSimEngine.is_graph_cyclic</code></a></li><li><a href="#PlantSimEngine.mapped_variables"><code>PlantSimEngine.mapped_variables</code></a></li><li><a href="#PlantSimEngine.mapped_variables_no_outputs_from_other_scale"><code>PlantSimEngine.mapped_variables_no_outputs_from_other_scale</code></a></li><li><a href="#PlantSimEngine.model_-Tuple{AbstractModel}"><code>PlantSimEngine.model_</code></a></li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a></li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a></li><li><a href="#PlantSimEngine.pre_allocate_outputs-NTuple{6, Any}"><code>PlantSimEngine.pre_allocate_outputs</code></a></li><li><a href="#PlantSimEngine.ref_var-Tuple{Any}"><code>PlantSimEngine.ref_var</code></a></li><li><a href="#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.reverse_mapping</code></a></li><li><a href="#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>PlantSimEngine.save_results!</code></a></li><li><a href="#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}"><code>PlantSimEngine.search_inputs_in_multiscale_output</code></a></li><li><a href="#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a></li><li><a href="#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a></li><li><a href="#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}"><code>PlantSimEngine.status_from_template</code></a></li><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a></li><li><a href="#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}"><code>PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="#PlantSimEngine.variables_multiscale"><code>PlantSimEngine.variables_multiscale</code></a></li><li><a href="#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}"><code>PlantSimEngine.variables_outputs_from_other_scale</code></a></li><li><a href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a></li><li><a href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a></li></ul><h2 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})" href="#DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataFrame(components &lt;: AbstractArray{&lt;:ModelList})
DataFrame(components &lt;: AbstractDict{N,&lt;:ModelList})</code></pre><p>Fetch the data from a <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a> (or an Array/Dict of) status into a DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine
using DataFrames

# Creating a ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# Converting to a DataFrame
df = DataFrame(models)

# Converting to a Dict of ModelLists
models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    )
)

# Converting to a DataFrame
df = DataFrame(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dataframe.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}" href="#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,S}) where {T,S&lt;:Status}</code></pre><p>Implementation of <code>DataFrame</code> for a <code>ModelList</code> model with one time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dataframe.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.AbstractBasic_Current_TimestepModel" href="#PlantSimEngine.AbstractBasic_Current_TimestepModel"><code>PlantSimEngine.AbstractBasic_Current_TimestepModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>basic_current_timestep</code> process abstract model. </p><p>All models implemented to simulate the <code>basic_current_timestep</code> process must be a subtype of this type, <em>e.g.</em>  <code>struct MyBasic_Current_TimestepModel &lt;: AbstractBasic_Current_TimestepModel end</code>.</p><p>You can list all models implementing this process using <code>subtypes</code>:</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">subtypes(AbstractBasic_Current_TimestepModel)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/process_generation.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.AbstractBasic_Next_TimestepModel" href="#PlantSimEngine.AbstractBasic_Next_TimestepModel"><code>PlantSimEngine.AbstractBasic_Next_TimestepModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>basic_next_timestep</code> process abstract model. </p><p>All models implemented to simulate the <code>basic_next_timestep</code> process must be a subtype of this type, <em>e.g.</em>  <code>struct MyBasic_Next_TimestepModel &lt;: AbstractBasic_Next_TimestepModel end</code>.</p><p>You can list all models implementing this process using <code>subtypes</code>:</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">subtypes(AbstractBasic_Next_TimestepModel)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/process_generation.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.AbstractNodeMapping" href="#PlantSimEngine.AbstractNodeMapping"><code>PlantSimEngine.AbstractNodeMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractNodeMapping</code></pre><p>Abstract type for the type of node mapping, <em>e.g.</em> single node mapping or multiple node mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/mapping.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}" href="#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataFormat(T::Type)</code></pre><p>Returns the data format of the type <code>T</code>. The data format is used to determine how to iterate over the data. The following data formats are supported:</p><ul><li><code>TableAlike</code>: The data is a table-like object, e.g. a <code>DataFrame</code> or a <code>TimeStepTable</code>. The data is iterated over by rows using the <code>Tables.jl</code> interface.</li><li><code>SingletonAlike</code>: The data is a singleton-like object, e.g. a <code>NamedTuple</code>   or a <code>TimeStepRow</code>. The data is iterated over by columns.</li><li><code>TreeAlike</code>: The data is a tree-like object, e.g. a <code>Node</code>.</li></ul><p>The default implementation returns <code>TableAlike</code> for <code>AbstractDataFrame</code>, <code>TimeStepTable</code>, <code>AbstractVector</code> and <code>Dict</code>, <code>TreeAlike</code> for <code>GraphSimulation</code>,  <code>SingletonAlike</code> for <code>Status</code>, <code>ModelList</code>, <code>NamedTuple</code> and <code>TimeStepRow</code>.</p><p>The default implementation for <code>Any</code> throws an error. Users that want to use another input should define this trait for the new data format, e.g.:</p><pre><code class="language-julia hljs">PlantSimEngine.DataFormat(::Type{&lt;:MyType}) = TableAlike()</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo, DataFrames

julia&gt; PlantSimEngine.DataFormat(DataFrame)
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat([1, 2, 3])
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Dict(:a =&gt; 1, :b =&gt; 2))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))
PlantSimEngine.SingletonAlike()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/table_traits.jl#L6-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.DependencyGraph" href="#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})</code></pre><p>A graph of dependencies between models.</p><p><strong>Arguments</strong></p><ul><li><code>roots::T</code>: the root nodes of the graph.</li><li><code>not_found::Dict{Symbol,DataType}</code>: the models that were not found in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/dependency_graph.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.DependencyTrait" href="#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DependencyTrait(T::Type)</code></pre><p>Returns information about the eventual dependence of a model <code>T</code> to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.</p><p>The following dependence traits are supported:</p><ul><li><code>TimeStepDependencyTrait</code>: Trait that defines whether a model can be parallelizable over time-steps for its computation.</li><li><code>ObjectDependencyTrait</code>: Trait that defines whether a model can be parallelizable over objects for its computation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.GraphSimulation" href="#PlantSimEngine.GraphSimulation"><code>PlantSimEngine.GraphSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GraphSimulation(graph, mapping)
GraphSimulation(graph, statuses, dependency_graph, models, outputs)</code></pre><p>A type that holds all information for a simulation over a graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph</code>: an graph, such as an MTG</li><li><code>mapping</code>: a dictionary of model mapping</li><li><code>statuses</code>: a structure that defines the status of each node in the graph</li><li><code>status_templates</code>: a dictionary of status templates</li><li><code>reverse_multiscale_mapping</code>: a dictionary of mapping for other scales</li><li><code>var_need_init</code>: a dictionary indicating if a variable needs to be initialized</li><li><code>dependency_graph</code>: the dependency graph of the models applied to the graph</li><li><code>models</code>: a dictionary of models</li><li><code>outputs</code>: a dictionary of outputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/GraphSimulation.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.MappedVar" href="#PlantSimEngine.MappedVar"><code>PlantSimEngine.MappedVar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MappedVar(source_organ, variable, source_variable, source_default)</code></pre><p>A variable mapped to another scale.</p><p><strong>Arguments</strong></p><ul><li><code>source_organ</code>: the organ(s) that are targeted by the mapping</li><li><code>variable</code>: the name of the variable that is mapped</li><li><code>source_variable</code>: the name of the variable from the source organ (the one that computes the variable)</li><li><code>source_default</code>: the default value of the variable</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(&quot;Leaf&quot;), :carbon_assimilation, :carbon_assimilation, 1.0)
PlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(&quot;Leaf&quot;), :carbon_assimilation, :carbon_assimilation, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/mapping.jl#L41-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.MultiNodeMapping" href="#PlantSimEngine.MultiNodeMapping"><code>PlantSimEngine.MultiNodeMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiNodeMapping(scale)</code></pre><p>Type for the multiple node mapping, <em>e.g.</em> <code>[:carbon_assimilation =&gt; [&quot;Leaf&quot;],]</code>. Note that &quot;Leaf&quot; is given as a vector, which means <code>:carbon_assimilation</code> will be a vector of values taken from each &quot;Leaf&quot; in the plant graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/mapping.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.ObjectDependencyTrait" href="#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ObjectDependencyTrait(::Type{T})</code></pre><p>Defines the trait about the eventual dependence of a model <code>T</code> to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.</p><p>The following dependency traits are supported:</p><ul><li><code>IsObjectDependent</code>: The model depends on other objects for its computation, it cannot be run in parallel.</li><li><code>IsObjectIndependent</code>: The model does not depend on other objects for its computation, it can be run in parallel.</li></ul><p>All models are object dependent by default (<em>i.e.</em> <code>IsObjectDependent</code>). This is probably not right for the majority of models, but:</p><ol><li>It is the safest default, as it will not lead to incorrect results if the user forgets to override this trait</li></ol><p>which is not the case for the opposite (i.e. <code>IsObjectIndependent</code>)</p><ol><li>It is easy to override this trait for models that are object independent</li></ol><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is object independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # false</code></pre><p>Define a model that is object dependent:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L135-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.RefVariable" href="#PlantSimEngine.RefVariable"><code>PlantSimEngine.RefVariable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefVariable(reference_variable)</code></pre><p>A structure to manually flag a variable in a model to use the value of another variable <strong>at the same scale</strong>. This is used for variable renaming, when a variable is computed by a model but is used by another model with a different name.</p><p>Note: we don&#39;t really rename the variable in the status (we need it for the other models), but we create a new one that is a reference to the first one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/variables_wrappers.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.RefVector" href="#PlantSimEngine.RefVector"><code>PlantSimEngine.RefVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefVector(field::Symbol, sts...)
RefVector(field::Symbol, sts::Vector{&lt;:Status})
RefVector(v::Vector{Base.RefValue{T}})</code></pre><p>A vector of references to a field of a vector of structs. This is used to efficiently pass the values between scales.</p><p><strong>Arguments</strong></p><ul><li><code>field</code>: the field of the struct to reference</li><li><code>sts...</code>: the structs to reference</li><li><code>sts::Vector{&lt;:Status}</code>: a vector of structs to reference</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><p>Let&#39;s take two Status structs:</p><pre><code class="language-julia-repl hljs">julia&gt; status1 = Status(a = 1.0, b = 2.0, c = 3.0);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; status2 = Status(a = 2.0, b = 3.0, c = 4.0);</code></pre><p>We can make a RefVector of the field <code>a</code> of the structs <code>st1</code> and <code>st2</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(:a, status1, status2)
2-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0</code></pre><p>Which is equivalent to:</p><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(:a, [status1, status2])
2-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0</code></pre><p>We can access the values of the RefVector:</p><pre><code class="language-julia-repl hljs">julia&gt; rv[1]
1.0</code></pre><p>Updating the value in the RefVector will update the value in the original struct:</p><pre><code class="language-julia-repl hljs">julia&gt; rv[1] = 10.0
10.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; status1.a
10.0</code></pre><p>We can also make a RefVector from a vector of references:</p><pre><code class="language-julia-repl hljs">julia&gt; vec = [Ref(1.0), Ref(2.0), Ref(3.0)]
3-element Vector{Base.RefValue{Float64}}:
 Base.RefValue{Float64}(1.0)
 Base.RefValue{Float64}(2.0)
 Base.RefValue{Float64}(3.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(vec)
3-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0
 3.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rv[1]
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/RefVector.jl#L1-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.SelfNodeMapping" href="#PlantSimEngine.SelfNodeMapping"><code>PlantSimEngine.SelfNodeMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SelfNodeMapping()</code></pre><p>Type for the self node mapping, <em>i.e.</em> a node that maps onto itself. This is used to flag variables that will be referenced as a scalar value by other models. It can happen in two conditions:     - the variable is computed by another scale, so we need this variable to exist as an input to this scale (it is not      computed at this scale otherwise)     - the variable is used as input to another scale but as a single value (scalar), so we need to reference it as a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/mapping.jl#L18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.SingleNodeMapping" href="#PlantSimEngine.SingleNodeMapping"><code>PlantSimEngine.SingleNodeMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleNodeMapping(scale)</code></pre><p>Type for the single node mapping, <em>e.g.</em> <code>[:soil_water_content =&gt; &quot;Soil&quot;,]</code>. Note that &quot;Soil&quot; is given as a scalar, which means that <code>:soil_water_content</code> will be a scalar value taken from the unique &quot;Soil&quot; node in the plant graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/mapping.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}" href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeStepDependencyTrait(::Type{T})</code></pre><p>Defines the trait about the eventual dependence of a model <code>T</code> to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.</p><p>The following dependency traits are supported:</p><ul><li><code>IsTimeStepDependent</code>: The model depends on other time-steps for its computation, it cannot be run in parallel.</li><li><code>IsTimeStepIndependent</code>: The model does not depend on other time-steps for its computation, it can be run in parallel.</li></ul><p>All models are time-step dependent by default (<em>i.e.</em> <code>IsTimeStepDependent</code>). This is probably not right for the  majority of models, but:</p><ol><li>It is the safest default, as it will not lead to incorrect results if the user forgets to override this trait</li></ol><p>which is not the case for the opposite (i.e. <code>IsTimeStepIndependent</code>)</p><ol><li>It is easy to override this trait for models that are time-step independent</li></ol><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other objects for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is time-step independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>Check if the model is parallelizable over time-steps:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # false</code></pre><p>Define a model that is time-step dependent:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()</code></pre><p>Check if the model is parallelizable over time-steps:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L19-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.UninitializedVar" href="#PlantSimEngine.UninitializedVar"><code>PlantSimEngine.UninitializedVar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UninitializedVar(variable, value)</code></pre><p>A variable that is not initialized yet, it is given a name and a default value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/variables_wrappers.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})" href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractArray{&lt;:ModelList})</code></pre><p>Copy an array-alike of <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L328-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)" href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractDict{N,&lt;:ModelList} where N)</code></pre><p>Copy a Dict-alike <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:ModelList" href="#Base.copy-Tuple{T} where T&lt;:ModelList"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::ModelList)
Base.copy(l::ModelList, status)</code></pre><p>Copy a <a href="../../step_by_step/simple_model_coupling/#ModelList"><code>ModelList</code></a>, eventually with new values for the status.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including example processes and models:
using PlantSimEngine.Examples;

# Create a model list:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# Copy the model list:
ml2 = copy(models)

# Copy the model list with new status:
ml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L283-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(component&lt;:ModelList, key::Symbol)
getindex(component&lt;:ModelList, key)</code></pre><p>Indexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

lm = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

lm[:var1] # Returns the value of the Tₗ variable
lm[2]  # Returns the status at the second time-step
lm[2][:var1] # Returns the value of Tₗ at the second time-step
lm[:var1][2] # Equivalent of the above

# output
16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/get_status.jl#L65-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}" href="#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}"><code>PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_mapped_variables_with_outputs_as_inputs!(mapped_vars)</code></pre><p>Add the variables that are computed at a scale and written to another scale into the mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}" href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_model_vars(x, models, type_promotion)</code></pre><p>Check which variables in <code>x</code> are not initialized considering a set of <code>models</code> and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.</p><p>This function needs to be implemented for each type of <code>x</code>. The default method works for  any Tables.jl-compatible <code>x</code> and for NamedTuples.</p><p>Careful, the function makes a copy of the input <code>x</code> if it does not list all needed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.check_dimensions-Tuple{Any, Any}" href="#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_dimensions(component,weather)
check_dimensions(status,weather)</code></pre><p>Checks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, PlantMeteo

# Including an example script that implements dummy processes and models:
using PlantSimEngine.Examples

# Creating a dummy weather:
w = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)

# Creating a dummy component:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=[15.0, 16.0], var2=0.3)
)

# Checking that the number of time-steps are compatible (here, they are, it returns nothing):
PlantSimEngine.check_dimensions(models, w) 

# Creating a dummy weather with 3 time-steps:
w = Weather([
    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)
])

# Checking that the number of time-steps are compatible (here, they are not, it throws an error):
PlantSimEngine.check_dimensions(models, w)

# output
ERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/checks/dimensions.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}" href="#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}"><code>PlantSimEngine.convert_reference_values!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})</code></pre><p>Convert the variables that are <code>MappedVar{SelfNodeMapping}</code> or <code>MappedVar{SingleNodeMapping}</code> to RefValues that reference a  common value for the variable; and convert <code>MappedVar{MultiNodeMapping}</code> to RefVectors that reference the values for the variable in the source organs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L282-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.convert_vars" href="#PlantSimEngine.convert_vars"><code>PlantSimEngine.convert_vars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})
convert_vars(ref_vars, type_promotion::Nothing)
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)</code></pre><p>Convert the status variables to the type specified in the type promotion dictionary. <em>Note: the mutating version only works with a dictionary of variables.</em></p><p><strong>Examples</strong></p><p>If we want all the variables that are Reals to be Float32, we can use:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Including example processes and models:
using PlantSimEngine.Examples;

ref_vars = init_variables(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
)
type_promotion = Dict(Real =&gt; Float32)

PlantSimEngine.convert_vars(type_promotion, ref_vars.process3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L347-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.convert_vars!" href="#PlantSimEngine.convert_vars!"><code>PlantSimEngine.convert_vars!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})
convert_vars(ref_vars, type_promotion::Nothing)
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)</code></pre><p>Convert the status variables to the type specified in the type promotion dictionary. <em>Note: the mutating version only works with a dictionary of variables.</em></p><p><strong>Examples</strong></p><p>If we want all the variables that are Reals to be Float32, we can use:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Including example processes and models:
using PlantSimEngine.Examples;

ref_vars = init_variables(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
)
type_promotion = Dict(Real =&gt; Float32)

PlantSimEngine.convert_vars(type_promotion, ref_vars.process3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L347-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}" href="#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}"><code>PlantSimEngine.convert_vars!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)</code></pre><p>Converts the types of the variables in a mapping (<code>mapped_vars</code>) using the <code>type_promotion</code> dictionary.</p><p>The mapping should be a dictionary with organ name as keys and a dictionary of variables as values, with variable names as symbols and variable value as value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L441-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.default_variables_from_mapping" href="#PlantSimEngine.default_variables_from_mapping"><code>PlantSimEngine.default_variables_from_mapping</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_variables_from_mapping(mapped_vars, verbose=true)</code></pre><p>Get the default values for the mapped variables by recursively searching from the mapping to find the original mapped value.</p><p><strong>Arguments</strong></p><ul><li><code>mapped_vars::Dict{String,Dict{Symbol,Any}}</code>: the variables mapped to each organ.</li><li><code>verbose::Bool</code>: whether to print the stacktrace of the search for the default value in the mapping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L246-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.diff_vars-Tuple{Any, Any}" href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_vars(x, y)</code></pre><p>Returns the names of variables that have different values in x and y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/models_inputs_outputs.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.draw_guide-NTuple{5, Any}" href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_guide(h, w, prefix, isleaf, guides)</code></pre><p>Draw the line guide for one node of the dependency graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/printing.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.draw_panel-NTuple{5, Any}" href="#PlantSimEngine.draw_panel-NTuple{5, Any}"><code>PlantSimEngine.draw_panel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_panel(node, graph, prefix, dep_graph_guides, parent; title=&quot;Soft-coupled model&quot;)</code></pre><p>Draw the panels for all dependencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/printing.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.drop_process-Tuple{Any, Symbol}" href="#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">drop_process(proc_vars, process)</code></pre><p>Return a new <code>NamedTuple</code> with the process <code>process</code> removed from the <code>NamedTuple</code> <code>proc_vars</code>.</p><p><strong>Arguments</strong></p><ul><li><code>proc_vars::NamedTuple</code>: the <code>NamedTuple</code> from which we want to remove the process <code>process</code>.</li><li><code>process::Symbol</code>: the process we want to remove from the <code>NamedTuple</code> <code>proc_vars</code>.</li></ul><p><strong>Returns</strong></p><p>A new <code>NamedTuple</code> with the process <code>process</code> removed from the <code>NamedTuple</code> <code>proc_vars</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; drop_process((a = 1, b = 2, c = 3), :b)
(a = 1, c = 3)

julia&gt; drop_process((a = 1, b = 2, c = 3), (:a, :c))
(b = 2,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/soft_dependencies.jl#L330-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.flatten_vars-Tuple{Any}" href="#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten_vars(vars)</code></pre><p>Return a set of the variables in the <code>vars</code> dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>vars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: a dict of process =&gt; namedtuple of variables =&gt; value.</li></ul><p><strong>Returns</strong></p><p>A set of the variables in the <code>vars</code> dictionary.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; flatten_vars(Dict(:process1 =&gt; (:var1, :var2), :process2 =&gt; (:var3, :var4)))
Set{Symbol} with 4 elements:
  :var4
  :var3
  :var2
  :var1</code></pre><pre><code class="language-julia hljs">julia&gt; flatten_vars([:process1 =&gt; (var1 = -Inf, var2 = -Inf), :process2 =&gt; (var3 = -Inf, var4 = -Inf)])
(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/soft_dependencies.jl#L533-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_mapped_variables-Tuple{Any}" href="#PlantSimEngine.get_mapped_variables-Tuple{Any}"><code>PlantSimEngine.get_mapped_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_mapped_variables(m)</code></pre><p>Get the mapping of a dictionary of model mapping.</p><p><strong>Arguments</strong></p><ul><li><code>m::Dict{String,Any}</code>: a dictionary of model mapping</li></ul><p>Returns a vector of pairs of symbols and strings or vectors of strings</p><p><strong>Examples</strong></p><p>See <a href="#PlantSimEngine.get_models-Tuple{Any}"><code>get_models</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/getters.jl#L92-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}" href="#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}"><code>PlantSimEngine.get_model_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_model_nodes(dep_graph::DependencyGraph, model)</code></pre><p>Get the nodes in the dependency graph implementing a type of model.</p><p><strong>Arguments</strong></p><ul><li><code>dep_graph::DependencyGraph</code>: the dependency graph.</li><li><code>model</code>: the model type to look for.</li></ul><p><strong>Returns</strong></p><ul><li>An array of nodes implementing the model type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">PlantSimEngine.get_model_nodes(dependency_graph, Beer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/get_model_in_dependency_graph.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_models-Tuple{Any}" href="#PlantSimEngine.get_models-Tuple{Any}"><code>PlantSimEngine.get_models</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_models(m)</code></pre><p>Get the models of a dictionary of model mapping.</p><p><strong>Arguments</strong></p><ul><li><code>m::Dict{String,Any}</code>: a dictionary of model mapping</li></ul><p>Returns a vector of models</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>Import example models (can be found in the <code>examples</code> folder of the package, or in the <code>Examples</code> sub-modules): </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>If we just give a MultiScaleModel, we get its model as a one-element vector:</p><pre><code class="language-julia-repl hljs">julia&gt; models = MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], );</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.get_models(models)
1-element Vector{ToyCAllocationModel}:
 ToyCAllocationModel()</code></pre><p>If we give a tuple of models, we get each model in a vector:</p><pre><code class="language-julia-repl hljs">julia&gt; models2 = (  MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );</code></pre><p>Notice that we provide &quot;Soil&quot;, not [&quot;Soil&quot;] in the mapping because a single value is expected for the mapping here.</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.get_models(models2)
2-element Vector{AbstractModel}:
 ToyAssimModel{Float64}(0.2)
 ToyCDemandModel{Float64}(10.0, 200.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/getters.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_multiscale_default_value" href="#PlantSimEngine.get_multiscale_default_value"><code>PlantSimEngine.get_multiscale_default_value</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])</code></pre><p>Get the default value of a variable from a mapping.</p><p><strong>Arguments</strong></p><ul><li><code>mapped_vars::Dict{String,Dict{Symbol,Any}}</code>: the variables mapped to each organ.</li><li><code>val::Any</code>: the variable to get the default value of.</li><li><code>mapping_stacktrace::Vector{Any}</code>: the stacktrace of the search for the value in ascendind the mapping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L198-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_nsteps-Tuple{Any}" href="#PlantSimEngine.get_nsteps-Tuple{Any}"><code>PlantSimEngine.get_nsteps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nsteps(t)</code></pre><p>Get the number of steps in the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/checks/dimensions.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.get_status-Tuple{Any}" href="#PlantSimEngine.get_status-Tuple{Any}"><code>PlantSimEngine.get_status</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_status(m)</code></pre><p>Get the status of a dictionary of model mapping.</p><p><strong>Arguments</strong></p><ul><li><code>m::Dict{String,Any}</code>: a dictionary of model mapping</li></ul><p>Returns a <a href="../API_public/#PlantSimEngine.Status"><code>Status</code></a> or <code>nothing</code>.</p><p><strong>Examples</strong></p><p>See <a href="#PlantSimEngine.get_models-Tuple{Any}"><code>get_models</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/getters.jl#L70-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.hard_dependencies-Tuple{Any}" href="#PlantSimEngine.hard_dependencies-Tuple{Any}"><code>PlantSimEngine.hard_dependencies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hard_dependencies(models; verbose::Bool=true)
hard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)</code></pre><p>Compute the hard dependencies between models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/hard_dependencies.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}" href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">homogeneous_ts_kwargs(kwargs)</code></pre><p>By default, the function returns its argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}</code></pre><p>Takes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to <em>e.g.</em> give constant values for all time-steps for one variable.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">PlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/component_models/ModelList.jl#L261-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_node_status!" href="#PlantSimEngine.init_node_status!"><code>PlantSimEngine.init_node_status!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_node_status!(
    node, 
    statuses, 
    mapped_vars, 
    reverse_multiscale_mapping,
    vars_need_init=Dict{String,Any}(),
    type_promotion=nothing;
    check=true,
    attribute_name=:plantsimengine_status)
)</code></pre><p>Initialise the status of a plant graph node, taking into account the multiscale mapping, and add it to the statuses dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the node to initialise</li><li><code>statuses</code>: the dictionary of statuses by node type</li><li><code>mapped_vars</code>: the template of status for each node type</li><li><code>reverse_multiscale_mapping</code>: the variables that are mapped to other scales</li><li><code>var_need_init</code>: the variables that are not initialised or computed by other models</li><li><code>nodes_with_models</code>: the nodes that have a model defined for their symbol</li><li><code>type_promotion</code>: the type promotion to use for the variables</li><li><code>check</code>: whether to check the mapping for errors (see details)</li><li><code>attribute_name</code>: the name of the attribute to store the status in the node, by default: <code>:plantsimengine_status</code></li></ul><p><strong>Details</strong></p><p>Most arguments can be computed from the graph and the mapping:</p><ul><li><code>statuses</code> is given by the first initialisation: <code>statuses = Dict(i =&gt; Status[] for i in nodes_with_models)</code></li><li><code>mapped_vars</code> is computed using <code>mapped_variables()</code>, see code in <code>init_statuses</code></li><li><code>vars_need_init</code> is computed using `vars<em>need</em>init = Dict(org =&gt; filter(x -&gt; isa(last(x), UninitializedVar), vars) |&gt; keys for (org, vars) in mapped_vars) |&gt;</li></ul><p>filter(x -&gt; length(last(x)) &gt; 0)`</p><p>The <code>check</code> argument is a boolean indicating if variables initialisation should be checked. In the case that some variables need initialisation (partially initialized mapping), we check if the value can be found  in the node attributes (using the variable name). If <code>true</code>, the function returns an error if the attribute is missing, otherwise it uses the default value from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/initialisation.jl#L56-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_simulation-Tuple{Any, Any}" href="#PlantSimEngine.init_simulation-Tuple{Any, Any}"><code>PlantSimEngine.init_simulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)</code></pre><p>Initialise the simulation. Returns:</p><ul><li>the mtg</li><li>a status for each node by organ type, considering multi-scale variables</li><li>the dependency graph of the models</li><li>the models parsed as a Dict of organ type =&gt; NamedTuple of process =&gt; model mapping</li><li>the pre-allocated outputs</li></ul><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the MTG</li><li><code>mapping::Dict{String,Any}</code>: a dictionary of model mapping</li><li><code>nsteps</code>: the number of steps of the simulation</li><li><code>outputs</code>: the dynamic outputs needed for the simulation</li><li><code>type_promotion</code>: the type promotion to use for the variables</li><li><code>check</code>: whether to check the mapping for errors. Passed to <code>init_node_status!</code>.</li><li><code>verbose</code>: print information about errors in the mapping</li></ul><p><strong>Details</strong></p><p>The function first computes a template of status for each organ type that has a model in the mapping. This template is used to initialise the status of each node of the MTG, taking into account the user-defined  initialisation, and the (multiscale) mapping. The mapping is used to make references to the variables that are defined at another scale, so that the values are automatically updated when the variable is changed at the other scale. Two types of multiscale variables are available: <code>RefVector</code> and <code>MappedVar</code>. The first one is used when the variable is mapped to a vector of nodes, and the second one when it is mapped to a single node. This  is given by the user through the mapping, using a string for a single node (<em>e.g.</em> <code>=&gt; &quot;Leaf&quot;</code>), and a vector of strings for a vector of nodes (<em>e.g.</em> <code>=&gt; [&quot;Leaf&quot;]</code> for one type of node or <code>=&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]</code> for several). </p><p>The function also computes the dependency graph of the models, i.e. the order in which the models should be called, considering the dependencies between them. The dependency graph is used to call the models in the right order when the simulation is run.</p><p>Note that if a variable is not computed by models or initialised from the mapping, it is searched in the MTG attributes.  The value is not a reference to the one in the attribute of the MTG, but a copy of it. This is because we can&#39;t reference  a value in a Dict. If you need a reference, you can use a <code>Ref</code> for your variable in the MTG directly, and it will be  automatically passed as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/initialisation.jl#L267-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_statuses" href="#PlantSimEngine.init_statuses"><code>PlantSimEngine.init_statuses</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)</code></pre><p>Get the status of each node in the MTG by node type, pre-initialised considering multi-scale variables.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the plant graph</li><li><code>mapping</code>: a dictionary of model mapping</li><li><code>dependency_graph::DependencyGraph</code>: the first-order dependency graph where each model in the mapping is assigned a node. </li></ul><p>However, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.</p><ul><li><code>type_promotion</code>: the type promotion to use for the variables</li><li><code>verbose</code>: print information when compiling the mapping</li><li><code>check</code>: whether to check the mapping for errors. Passed to <code>init_node_status!</code>.</li></ul><p><strong>Return</strong></p><p>A NamedTuple of status by node type, a dictionary of status templates by node type, a dictionary of variables mapped to other scales, a dictionary of variables that need to be initialised or computed by other models, and a vector of nodes that have a model defined for their symbol:</p><p><code>(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/initialisation.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.init_variables_manual-Tuple{Any, Any}" href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_variables_manual(models...;vars...)</code></pre><p>Return an initialisation of the model variables with given values.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

PlantSimEngine.init_variables_manual(status(models), (var1=20.0,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/model_initialisation.jl#L358-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}" href="#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}"><code>PlantSimEngine.initialise_all_as_hard_dependency_node</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_all_as_hard_dependency_node(models)</code></pre><p>Take a set of models and initialise them all as a hard dependency node, and  return a dictionary of <code>:process =&gt; HardDependencyNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/hard_dependencies.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}" href="#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}"><code>PlantSimEngine.is_graph_cyclic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)</code></pre><p>Check if the dependency graph is cyclic.</p><p><strong>Arguments</strong></p><ul><li><code>dependency_graph::DependencyGraph</code>: the dependency graph to check.</li><li><code>full_stack::Bool=false</code>: if <code>true</code>, return the full stack of nodes that makes the cycle, otherwise return only the cycle.</li><li><code>warn::Bool=true</code>: if <code>true</code>, print a stylised warning message when a cycle is detected.</li></ul><p>Return a boolean indicating if the graph is cyclic, and the stack of nodes as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/is_graph_cyclic.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.mapped_variables" href="#PlantSimEngine.mapped_variables"><code>PlantSimEngine.mapped_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)</code></pre><p>Get the variables for each organ type from a dependency graph, with <code>MappedVar</code>s for the multiscale mapping.</p><p><strong>Arguments</strong></p><ul><li><code>mapping::Dict{String,T}</code>: the mapping between models and scales.</li><li><code>dependency_graph::DependencyGraph</code>: the first-order dependency graph where each model in the mapping is assigned a node. </li></ul><p>However, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.</p><ul><li><code>verbose::Bool</code>: whether to print the stacktrace of the search for the default value in the mapping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.mapped_variables_no_outputs_from_other_scale" href="#PlantSimEngine.mapped_variables_no_outputs_from_other_scale"><code>PlantSimEngine.mapped_variables_no_outputs_from_other_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))</code></pre><p>Get the variables for each organ type from a dependency graph, without the variables that are outputs from another scale.</p><p><strong>Arguments</strong></p><ul><li><code>mapping::Dict{String,T}</code>: the mapping between models and scales.</li><li><code>dependency_graph::DependencyGraph</code>: the first-order dependency graph where each model in the mapping is assigned a node. </li></ul><p>However, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.</p><p><strong>Details</strong></p><p>This function returns a dictionary with the (multiscale-) inputs and outputs variables for each organ type. </p><p>Note that this function does not include the variables that are outputs from another scale and not computed by this scale, see <code>mapped_variables_with_outputs_as_inputs</code> for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L38-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.model_-Tuple{AbstractModel}" href="#PlantSimEngine.model_-Tuple{AbstractModel}"><code>PlantSimEngine.model_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">model_(m::AbstractModel)</code></pre><p>Get the model of an AbstractModel (it is the model itself if it is not a MultiScaleModel).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/Abstract_model_structs.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.object_parallelizable-Tuple{T} where T" href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">object_parallelizable(x::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>x</code> is parallelizable, i.e. if the model can be computed in parallel for different objects, or <code>false</code> otherwise. </p><p>The default implementation returns <code>false</code> for all models. If you develop a model that is parallelizable over objects, you should add a method to <a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> for your model.</p><p>Note that this method can also be applied on a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> directly, in which case it returns <code>true</code> if all models in the graph are parallelizable, and <code>false</code> otherwise.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other objects for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is object independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L205-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.parallelizable-Tuple{T} where T" href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallelizable(::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>T</code> or the whole dependency graph is parallelizable, <em>i.e.</em> if the model can be computed in parallel for different time-steps or objects. The default implementation returns <code>false</code> for all models.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is parallelizable:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable:</p><pre><code class="language-julia hljs">parallelizable(MyModel()) # true</code></pre><p>Or if we want to be more explicit:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel())
object_parallelizable(MyModel())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L254-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.pre_allocate_outputs-NTuple{6, Any}" href="#PlantSimEngine.pre_allocate_outputs-NTuple{6, Any}"><code>PlantSimEngine.pre_allocate_outputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pre_allocate_outputs(statuses, outs, nsteps; check=true)</code></pre><p>Pre-allocate the outputs of needed variable for each node type in vectors of vectors. The first level vectors have length nsteps, and the second level vectors have length n_nodes of this type.</p><p>Note that we pre-allocate the vectors for the time-steps, but not for each organ, because we don&#39;t  know how many nodes will be in each organ in the future (organs can appear or disapear).</p><p><strong>Arguments</strong></p><ul><li><code>statuses</code>: a dictionary of status by node type</li><li><code>outs</code>: a dictionary of outputs by node type</li><li><code>nsteps</code>: the number of time-steps</li><li><code>check</code>: whether to check the mapping for errors. Default (<code>true</code>) returns an error if some variables do not exist.</li></ul><p>If false and some variables are missing, return an info, remove the unknown variables and continue.</p><p><strong>Returns</strong></p><ul><li>A dictionary of pre-allocated output of vector of time-step and vector of node of that type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, MultiScaleTreeGraph, PlantSimEngine.Examples</code></pre><p>Import example models (can be found in the <code>examples</code> folder of the package, or in the <code>Examples</code> sub-modules): </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>Define the models mapping:</p><pre><code class="language-julia-repl hljs">julia&gt; mapping = Dict( &quot;Plant&quot; =&gt;  ( MultiScaleModel(  model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], ), 
        MultiScaleModel(  model=ToyPlantRmModel(), mapped_variables=[:Rm_organs =&gt; [&quot;Leaf&quot; =&gt; :Rm, &quot;Internode&quot; =&gt; :Rm],] ), ),&quot;Internode&quot; =&gt; ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0, carbon_biomass=1.0) ), &quot;Leaf&quot; =&gt; ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0, carbon_biomass=1.0), ), &quot;Soil&quot; =&gt; ( ToySoilWaterModel(), ), );</code></pre><p>Importing an example MTG provided by the package:</p><pre><code class="language-julia-repl hljs">julia&gt; mtg = import_mtg_example();</code></pre><pre><code class="language-julia-repl hljs">julia&gt; statuses, status_templates, reverse_multiscale_mapping, vars_need_init = PlantSimEngine.init_statuses(mtg, mapping);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; outs = Dict(&quot;Leaf&quot; =&gt; (:carbon_assimilation, :carbon_demand), &quot;Soil&quot; =&gt; (:soil_water_content,));</code></pre><p>Pre-allocate the outputs as a dictionary:</p><pre><code class="language-julia-repl hljs">julia&gt; preallocated_vars = PlantSimEngine.pre_allocate_outputs(statuses, status_templates, reverse_multiscale_mapping, vars_need_init, outs, 2);</code></pre><p>The dictionary has a key for each organ from which we want outputs:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(keys(preallocated_vars))
2-element Vector{String}:
 &quot;Soil&quot;
 &quot;Leaf&quot;</code></pre><p>Each organ has a dictionary of variables for which we want outputs from,  with the pre-allocated empty vectors (one per time-step that will be filled with one value per node):</p><pre><code class="language-julia-repl hljs">julia&gt; collect(keys(preallocated_vars[&quot;Leaf&quot;]))
3-element Vector{Symbol}:
 :carbon_assimilation
 :node
 :carbon_demand</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/save_results.jl#L1-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.ref_var-Tuple{Any}" href="#PlantSimEngine.ref_var-Tuple{Any}"><code>PlantSimEngine.ref_var</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ref_var(v)</code></pre><p>Create a reference to a variable. If the variable is already a <code>Base.RefValue</code>, it is returned as is, else it is returned as a Ref to the copy of the value, or a Ref to the <code>RefVector</code> (in case <code>v</code> is a <code>RefVector</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(1.0)
Base.RefValue{Float64}(1.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var([1.0])
Base.RefValue{Vector{Float64}}([1.0])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(Base.RefValue(1.0))
Base.RefValue{Float64}(1.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(Base.RefValue([1.0]))
Base.RefValue{Vector{Float64}}([1.0])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))
Base.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/initialisation.jl#L222-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T" href="#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.reverse_mapping</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)
reverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})</code></pre><p>Get the reverse mapping of a dictionary of model mapping, <em>i.e.</em> the variables that are mapped to other scales, or in other words, what variables are given to other scales from a given scale. This is used for <em>e.g.</em> knowing which scales are needed to add values to others.</p><p><strong>Arguments</strong></p><ul><li><code>mapping::Dict{String,Any}</code>: A dictionary of model mapping.</li><li><code>all::Bool</code>: Whether to get all the variables that are mapped to other scales, including the ones that are mapped as single values.</li></ul><p><strong>Returns</strong></p><p>A dictionary of organs (keys) with a dictionary of organs =&gt; vector of pair of variables. You can read the output as: &quot;for each organ (source organ), to which other organ (target organ) it is giving values for its own variables. Then for each of these source organs, which variable it is giving to the target organ (first symbol in the pair), and to which variable it is mapping the value into the target organ (second symbol in the pair)&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><p>Import example models (can be found in the <code>examples</code> folder of the package, or in the <code>Examples</code> sub-modules): </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mapping = Dict( &quot;Plant&quot; =&gt; MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], ), &quot;Internode&quot; =&gt; ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), &quot;Leaf&quot; =&gt; ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), &quot;Soil&quot; =&gt; ( ToySoilWaterModel(), ), );</code></pre><p>Notice we provide &quot;Soil&quot;, not [&quot;Soil&quot;] in the mapping of the <code>ToyAssimModel</code> for the <code>Leaf</code>. This is because we expect a single value for the <code>soil_water_content</code> to be mapped here (there is only one soil). This allows  to get the value as a singleton instead of a vector of values.</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.reverse_mapping(mapping)
Dict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:
  &quot;Soil&quot;      =&gt; Dict(&quot;Leaf&quot;=&gt;Dict(:soil_water_content=&gt;:soil_water_content))
  &quot;Internode&quot; =&gt; Dict(&quot;Plant&quot;=&gt;Dict(:carbon_allocation=&gt;:carbon_allocation, :ca…
  &quot;Leaf&quot;      =&gt; Dict(&quot;Plant&quot;=&gt;Dict(:carbon_allocation=&gt;:carbon_allocation, :ca…</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/reverse_mapping.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}" href="#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>PlantSimEngine.save_results!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_results!(object::GraphSimulation, i)</code></pre><p>Save the results of the simulation for time-step <code>i</code> into the  object. For a <code>GraphSimulation</code> object, this will save the results from the <code>status(object)</code> in the <code>outputs(object)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/save_results.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}" href="#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}"><code>PlantSimEngine.search_inputs_in_multiscale_output</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>process::Symbol</code>: the process for which we want to find the soft dependencies at other scales.</li><li><code>organ::String</code>: the organ for which we want to find the soft dependencies.</li><li><code>inputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}</code>: a dict of process =&gt; [:subprocess =&gt; (:var1, :var2)].</li><li><code>soft_dep_graphs::Dict{String, ...}</code>: a dict of organ =&gt; (soft<em>dep</em>graph, inputs, outputs).</li><li><code>rev_mapping::Dict{Symbol, Symbol}</code>: a dict of mapped variable =&gt; source variable (this is the reverse mapping).</li><li>&#39;hard<em>dependencies</em>from<em>other</em>scale&#39; : a vector of HardDependencyNode to provide access to the hard dependencies without traversing the whole graph</li></ul><p><strong>Details</strong></p><p>The inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can come from itself (its own inputs), or from another process that is a hard-dependency.</p><p><strong>Returns</strong></p><p>A dictionary with the soft dependencies variables found in outputs of other scales for each process, e.g.:</p><pre><code class="language-julia hljs">Dict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:
    &quot;Internode&quot; =&gt; Dict(:carbon_demand=&gt;[:carbon_demand])
    &quot;Leaf&quot;      =&gt; Dict(:carbon_assimilation=&gt;[:carbon_assimilation], :carbon_demand=&gt;[:carbon_demand])</code></pre><p>This means that the variable <code>:carbon_demand</code> is computed by the process <code>:carbon_demand</code> at the scale &quot;Internode&quot;, and the variable <code>:carbon_assimilation</code>  is computed by the process <code>:carbon_assimilation</code> at the scale &quot;Leaf&quot;. Those variables are used as inputs for the process that we just passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/soft_dependencies.jl#L436-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}" href="#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">search_inputs_in_output(process, inputs, outputs)</code></pre><p>Return a dictionary with the soft dependencies of the processes in the dependency graph <code>d</code>. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.</p><p><strong>Arguments</strong></p><ul><li><code>process::Symbol</code>: the process for which we want to find the soft dependencies.</li><li><code>inputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}</code>: a dict of process =&gt; symbols of inputs per process.</li><li><code>outputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: a dict of process =&gt; symbols of outputs per process.</li></ul><p><strong>Details</strong></p><p>The inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.</p><p><strong>Returns</strong></p><p>A dictionary with the soft dependencies for the processes.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">in_ = Dict(
    :process3 =&gt; [:process3=&gt;(:var4, :var5), :process2=&gt;(:var1, :var3), :process1=&gt;(:var1, :var2)],
    :process4 =&gt; [:process4=&gt;(:var0,)],
    :process6 =&gt; [:process6=&gt;(:var7, :var9)],
    :process5 =&gt; [:process5=&gt;(:var5, :var6)],
)

out_ = Dict(
    :process3 =&gt; Pair{Symbol}[:process3=&gt;(:var4, :var6), :process2=&gt;(:var4, :var5), :process1=&gt;(:var3,)],
    :process4 =&gt; [:process4=&gt;(:var1, :var2)],
    :process6 =&gt; [:process6=&gt;(:var8,)],
    :process5 =&gt; [:process5=&gt;(:var7,)],
)

search_inputs_in_output(:process3, in_, out_)
(process4 = (:var1, :var2),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/soft_dependencies.jl#L357-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.soft_dependencies" href="#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">soft_dependencies(d::DependencyGraph)</code></pre><p>Return a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> with the soft dependencies of the processes in the dependency graph <code>d</code>. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.</p><p><strong>Arguments</strong></p><ul><li><code>d::DependencyGraph</code>: the hard-dependency graph.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples

# Create a model list:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
)

# Create the hard-dependency graph:
hard_dep = hard_dependencies(models.models, verbose=true)

# Get the soft dependencies graph:
soft_dep = soft_dependencies(hard_dep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/soft_dependencies.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}" href="#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}"><code>PlantSimEngine.status_from_template</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">status_from_template(d::Dict{Symbol,Any})</code></pre><p>Create a status from a template dictionary of variables and values. If the values  are already RefValues or RefVectors, they are used as is, else they are converted to Refs.</p><p><strong>Arguments</strong></p><ul><li><code>d::Dict{Symbol,Any}</code>: A dictionary of variables and values.</li></ul><p><strong>Returns</strong></p><ul><li>A <a href="../API_public/#PlantSimEngine.Status"><code>Status</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a, b = PlantSimEngine.status_from_template(Dict(:a =&gt; 1.0, :b =&gt; 2.0));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a
1.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/initialisation.jl#L171-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.timestep_parallelizable-Tuple{T} where T" href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestep_parallelizable(x::T)
timestep_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>x</code> is parallelizable, i.e. if the model can be computed in parallel over time-steps, or <code>false</code> otherwise.</p><p>The default implementation returns <code>false</code> for all models. If you develop a model that is parallelizable over time-steps, you should add a method to <a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> for your model.</p><p>Note that this method can also be applied on a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> directly, in which case it returns <code>true</code> if all models in the graph are parallelizable, and <code>false</code> otherwise.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is time-step independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/traits/parallel_traits.jl#L86-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}" href="#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}"><code>PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)</code></pre><p>Find variables that are inputs to other scales as a <code>SingleNodeMapping</code> and declare them as MappedVar from themselves in the source scale. This helps us declare it as a reference when we create the template status objects.</p><p>These node are found in the mapping as <code>[:variable_name =&gt; &quot;Plant&quot;]</code> (notice that &quot;Plant&quot; is a scalar value).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)</code></pre><p>Apply function <code>f</code> to <code>node</code>, and then its children (hard-dependency nodes).</p><p>Mutate the vector <code>var</code> by pushing a pair of the node process name and the result of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/traversal.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)</code></pre><p>Apply function <code>f</code> to <code>node</code>, visit its hard dependency nodes (if <code>visit_hard_dep=true</code>), and  then its soft dependency children.</p><p>Mutate the vector <code>var</code> by pushing a pair of the node process name and the result of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/traversal.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}" href="#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)</code></pre><p>Traverse the dependency <code>graph</code> and apply the function <code>f</code> to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if <code>visit_hard_dep=true</code>), and then the children of the soft-dependencies.</p><p>Return a vector of pairs of the node and the result of the function <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Including example processes and models:
using PlantSimEngine.Examples;

function f(node)
    node.value
end

vars = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

graph = dep(vars)
traverse_dependency_graph(graph, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/traversal.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables_multiscale" href="#PlantSimEngine.variables_multiscale"><code>PlantSimEngine.variables_multiscale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables_multiscale(node, organ, mapping, st=NamedTuple())</code></pre><p>Get the variables of a HardDependencyNode, taking into account the multiscale mapping, <em>i.e.</em> defining variables as <code>MappedVar</code> if they are mapped to another scale. The default values are  taken from the model if not given by the user (<code>st</code>), and are marked as <code>UninitializedVar</code> if  they are inputs of the node.</p><p>Return a NamedTuple with the variables and their default values.</p><p><strong>Arguments</strong></p><ul><li><code>node::HardDependencyNode</code>: the node to get the variables from.</li><li><code>organ::String</code>: the organ type, <em>e.g.</em> &quot;Leaf&quot;.</li><li><code>vars_mapping::Dict{String,T}</code>: the mapping of the models (see details below).</li><li><code>st::NamedTuple</code>: an optional named tuple with default values for the variables.</li></ul><p><strong>Details</strong></p><p>The <code>vars_mapping</code> is a dictionary with the organ type as key and a dictionary as value. It is  computed from the user mapping like so:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/dependencies/dependency_graph.jl#L80-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}" href="#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}"><code>PlantSimEngine.variables_outputs_from_other_scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables_outputs_from_other_scale(mapped_vars)</code></pre><p>For each organ in the <code>mapped_vars</code>, find the variables that are outputs from another scale and not computed at this scale otherwise. This function is used with mapped_variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/mtg/mapping/compute_mapping.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables_typed(model)
variables_typed(model, models...)</code></pre><p>Returns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

PlantSimEngine.variables_typed(Process1Model(1.0))
(var1 = Float64, var2 = Float64, var3 = Float64)

PlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())

# output
(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)</code></pre><p><strong>See also</strong></p><p><a href="../API_public/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="../API_public/#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="../API_public/#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/models_inputs_outputs.jl#L200-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status" href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vars_not_init_(st&lt;:Status, var_names)</code></pre><p>Get which variable is not properly initialized in the status struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/de0256db6ba52b82a21da59fc4d95f5b74dbdbd3/src/processes/model_initialisation.jl#L326-L330">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API_public/">« Public API</a><a class="docs-footer-nextpage" href="../../credits/">Credits »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 6 March 2025 16:28">Thursday 6 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
