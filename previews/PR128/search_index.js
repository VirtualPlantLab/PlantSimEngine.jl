var documenterSearchIndex = {"docs":
[{"location":"working_with_data/fitting/#Parameter-fitting","page":"Fitting","title":"Parameter fitting","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"working_with_data/fitting/#The-fit-method","page":"Fitting","title":"The fit method","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Models are often calibrated using data, but the calibration process is not always the same depending on the model, and the data available to the user.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"PlantSimEngine defines a generic fit function that allows modelers provide a fitting algorithm for their model, and for users to use this method to calibrate the model using data.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The function does nothing in this package, it is only defined to provide a common interface for all the models. It is up to the modeler to implement the method for their model. ","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The method is implemented as a function with the following design pattern: the call to the function should take the model type as the first argument (T::Type{<:AbstractModel}), the data as the second argument (as a Table.jl compatible type, such as DataFrame), and any more information as keyword arguments, e.g. constants or parameters initializations with default values when necessary.","category":"page"},{"location":"working_with_data/fitting/#Example-with-Beer","page":"Fitting","title":"Example with Beer","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The example script (see src/examples/Beer.jl) that implements the Beer model provides an example of how to implement the fit method for a model:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The function takes a Beer type as the first argument, the data as a Tables.jl compatible type, such as a DataFrame as the second argument, and the J_to_umol constant as a keyword argument, which is used to convert between μ mol m⁻² s⁻¹ and J m⁻² s⁻¹.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"df should contain the columns PPFD (μ mol m⁻² s⁻¹), LAI (m² m⁻²) and Ri_PAR_f (W m⁻²). The function then computes k based on these values, and returns it as a NamedTuple of the form (parameter_name=parameter_value,).","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Here's an example of how to use the fit method:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Importing the script first: ","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Defining the meteo data:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Computing the PPFD values from the Ri_PAR_f values using the Beer model (with k=0.6):","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"m = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Now we can define the \"data\" to fit the model using the simulated PPFD values:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"And finally we can fit the model using the fit method:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"fit(Beer, df)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"note: Note\nThis is a dummy example to show that the fitting method works. A real application would fit the parameter values on the data directly.","category":"page"},{"location":"API/API_private/#API-internal-functions","page":"Internal API","title":"API - internal functions","text":"","category":"section"},{"location":"API/API_private/#Un-exported","page":"Internal API","title":"Un-exported","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat). Most of them are developer code, but some may be useful for tinkerers, or to have greater control over some simulation parameters (future versions of this documentation might break those categories into separate pages for clarity).","category":"page"},{"location":"API/API_private/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Pages = [\"API_private.md\"]","category":"page"},{"location":"API/API_private/#API-documentation","page":"Internal API","title":"API documentation","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"API/API_private/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:Status}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Current_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Current_TimestepModel","text":"basic_current_timestep process abstract model. \n\nAll models implemented to simulate the basic_current_timestep process must be a subtype of this type, e.g.  struct MyBasic_Current_TimestepModel <: AbstractBasic_Current_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Current_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Next_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Next_TimestepModel","text":"basic_next_timestep process abstract model. \n\nAll models implemented to simulate the basic_next_timestep process must be a subtype of this type, e.g.  struct MyBasic_Next_TimestepModel <: AbstractBasic_Next_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Next_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractNodeMapping","page":"Internal API","title":"PlantSimEngine.AbstractNodeMapping","text":"AbstractNodeMapping\n\nAbstract type for the type of node mapping, e.g. single node mapping or multiple node mapping.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"Internal API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\nTreeAlike: The data is a tree-like object, e.g. a Node.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for GraphSimulation,  SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.DependencyGraph","page":"Internal API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DependencyTrait","page":"Internal API","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\nReturns information about the eventual dependence of a model T to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.\n\nThe following dependence traits are supported:\n\nTimeStepDependencyTrait: Trait that defines whether a model can be parallelizable over time-steps for its computation.\nObjectDependencyTrait: Trait that defines whether a model can be parallelizable over objects for its computation.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.GraphSimulation","page":"Internal API","title":"PlantSimEngine.GraphSimulation","text":"GraphSimulation(graph, mapping)\nGraphSimulation(graph, statuses, dependency_graph, models, outputs)\n\nA type that holds all information for a simulation over a graph.\n\nArguments\n\ngraph: an graph, such as an MTG\nmapping: a dictionary of model mapping\nstatuses: a structure that defines the status of each node in the graph\nstatus_templates: a dictionary of status templates\nreverse_multiscale_mapping: a dictionary of mapping for other scales\nvar_need_init: a dictionary indicating if a variable needs to be initialized\ndependency_graph: the dependency graph of the models applied to the graph\nmodels: a dictionary of models\noutputs: a dictionary of outputs\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MappedVar","page":"Internal API","title":"PlantSimEngine.MappedVar","text":"MappedVar(source_organ, variable, source_variable, source_default)\n\nA variable mapped to another scale.\n\nArguments\n\nsource_organ: the organ(s) that are targeted by the mapping\nvariable: the name of the variable that is mapped\nsource_variable: the name of the variable from the source organ (the one that computes the variable)\nsource_default: the default value of the variable\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\nPlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MultiNodeMapping","page":"Internal API","title":"PlantSimEngine.MultiNodeMapping","text":"MultiNodeMapping(scale)\n\nType for the multiple node mapping, e.g. [:carbon_assimilation => [\"Leaf\"],]. Note that \"Leaf\" is given as a vector, which means :carbon_assimilation will be a vector of values taken from each \"Leaf\" in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.ObjectDependencyTrait","page":"Internal API","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.\n\nThe following dependency traits are supported:\n\nIsObjectDependent: The model depends on other objects for its computation, it cannot be run in parallel.\nIsObjectIndependent: The model does not depend on other objects for its computation, it can be run in parallel.\n\nAll models are object dependent by default (i.e. IsObjectDependent). This is probably not right for the majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsObjectIndependent)\n\nIt is easy to override this trait for models that are object independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # false\n\nDefine a model that is object dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVariable","page":"Internal API","title":"PlantSimEngine.RefVariable","text":"RefVariable(reference_variable)\n\nA structure to manually flag a variable in a model to use the value of another variable at the same scale. This is used for variable renaming, when a variable is computed by a model but is used by another model with a different name.\n\nNote: we don't really rename the variable in the status (we need it for the other models), but we create a new one that is a reference to the first one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVector","page":"Internal API","title":"PlantSimEngine.RefVector","text":"RefVector(field::Symbol, sts...)\nRefVector(field::Symbol, sts::Vector{<:Status})\nRefVector(v::Vector{Base.RefValue{T}})\n\nA vector of references to a field of a vector of structs. This is used to efficiently pass the values between scales.\n\nArguments\n\nfield: the field of the struct to reference\nsts...: the structs to reference\nsts::Vector{<:Status}: a vector of structs to reference\n\nExamples\n\njulia> using PlantSimEngine\n\nLet's take two Status structs:\n\njulia> status1 = Status(a = 1.0, b = 2.0, c = 3.0);\n\njulia> status2 = Status(a = 2.0, b = 3.0, c = 4.0);\n\nWe can make a RefVector of the field a of the structs st1 and st2:\n\njulia> rv = PlantSimEngine.RefVector(:a, status1, status2)\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWhich is equivalent to:\n\njulia> rv = PlantSimEngine.RefVector(:a, [status1, status2])\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWe can access the values of the RefVector:\n\njulia> rv[1]\n1.0\n\nUpdating the value in the RefVector will update the value in the original struct:\n\njulia> rv[1] = 10.0\n10.0\n\njulia> status1.a\n10.0\n\nWe can also make a RefVector from a vector of references:\n\njulia> vec = [Ref(1.0), Ref(2.0), Ref(3.0)]\n3-element Vector{Base.RefValue{Float64}}:\n Base.RefValue{Float64}(1.0)\n Base.RefValue{Float64}(2.0)\n Base.RefValue{Float64}(3.0)\n\njulia> rv = PlantSimEngine.RefVector(vec)\n3-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> rv[1]\n1.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SelfNodeMapping","page":"Internal API","title":"PlantSimEngine.SelfNodeMapping","text":"SelfNodeMapping()\n\nType for the self node mapping, i.e. a node that maps onto itself. This is used to flag variables that will be referenced as a scalar value by other models. It can happen in two conditions:     - the variable is computed by another scale, so we need this variable to exist as an input to this scale (it is not      computed at this scale otherwise)     - the variable is used as input to another scale but as a single value (scalar), so we need to reference it as a scalar.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SingleNodeMapping","page":"Internal API","title":"PlantSimEngine.SingleNodeMapping","text":"SingleNodeMapping(scale)\n\nType for the single node mapping, e.g. [:soil_water_content => \"Soil\",]. Note that \"Soil\" is given as a scalar, which means that :soil_water_content will be a scalar value taken from the unique \"Soil\" node in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"Internal API","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.\n\nThe following dependency traits are supported:\n\nIsTimeStepDependent: The model depends on other time-steps for its computation, it cannot be run in parallel.\nIsTimeStepIndependent: The model does not depend on other time-steps for its computation, it can be run in parallel.\n\nAll models are time-step dependent by default (i.e. IsTimeStepDependent). This is probably not right for the  majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsTimeStepIndependent)\n\nIt is easy to override this trait for models that are time-step independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # false\n\nDefine a model that is time-step dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.UninitializedVar","page":"Internal API","title":"PlantSimEngine.UninitializedVar","text":"UninitializedVar(variable, value)\n\nA variable that is not initialized yet, it is given a name and a default value.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:ModelList","page":"Internal API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"Internal API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tₗ at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!","text":"add_mapped_variables_with_outputs_as_inputs!(mapped_vars)\n\nAdd the variables that are computed at a scale and written to another scale into the mapping.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\nusing PlantSimEngine.Examples\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}","page":"Internal API","title":"PlantSimEngine.convert_reference_values!","text":"convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nConvert the variables that are MappedVar{SelfNodeMapping} or MappedVar{SingleNodeMapping} to RefValues that reference a  common value for the variable; and convert MappedVar{MultiNodeMapping} to RefVectors that reference the values for the variable in the source organs.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_vars","page":"Internal API","title":"PlantSimEngine.convert_vars","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)\n\nConverts the types of the variables in a mapping (mapped_vars) using the type_promotion dictionary.\n\nThe mapping should be a dictionary with organ name as keys and a dictionary of variables as values, with variable names as symbols and variable value as value.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.default_variables_from_mapping","page":"Internal API","title":"PlantSimEngine.default_variables_from_mapping","text":"default_variables_from_mapping(mapped_vars, verbose=true)\n\nGet the default values for the mapped variables by recursively searching from the mapping to find the original mapped value.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"Internal API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_panel-NTuple{5, Any}","page":"Internal API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"Internal API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => namedtuple of variables => value.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\njulia> flatten_vars([:process1 => (var1 = -Inf, var2 = -Inf), :process2 => (var3 = -Inf, var4 = -Inf)])\n(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_mapped_variables-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_mapped_variables","text":"get_mapped_variables(m)\n\nGet the mapping of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of pairs of symbols and strings or vectors of strings\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}","page":"Internal API","title":"PlantSimEngine.get_model_nodes","text":"get_model_nodes(dep_graph::DependencyGraph, model)\n\nGet the nodes in the dependency graph implementing a type of model.\n\nArguments\n\ndep_graph::DependencyGraph: the dependency graph.\nmodel: the model type to look for.\n\nReturns\n\nAn array of nodes implementing the model type.\n\nExamples\n\nPlantSimEngine.get_model_nodes(dependency_graph, Beer)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_models-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_models","text":"get_models(m)\n\nGet the models of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of models\n\nExamples\n\njulia> using PlantSimEngine;\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nIf we just give a MultiScaleModel, we get its model as a one-element vector:\n\njulia> models = MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], );\n\njulia> PlantSimEngine.get_models(models)\n1-element Vector{ToyCAllocationModel}:\n ToyCAllocationModel()\n\nIf we give a tuple of models, we get each model in a vector:\n\njulia> models2 = (  MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );\n\nNotice that we provide \"Soil\", not [\"Soil\"] in the mapping because a single value is expected for the mapping here.\n\njulia> PlantSimEngine.get_models(models2)\n2-element Vector{AbstractModel}:\n ToyAssimModel{Float64}(0.2)\n ToyCDemandModel{Float64}(10.0, 200.0)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_multiscale_default_value","page":"Internal API","title":"PlantSimEngine.get_multiscale_default_value","text":"get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])\n\nGet the default value of a variable from a mapping.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nval::Any: the variable to get the default value of.\nmapping_stacktrace::Vector{Any}: the stacktrace of the search for the value in ascendind the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.get_nsteps-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_nsteps","text":"get_nsteps(t)\n\nGet the number of steps in the object.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_status-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_status","text":"get_status(m)\n\nGet the status of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a Status or nothing.\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.hard_dependencies-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.hard_dependencies","text":"hard_dependencies(models; verbose::Bool=true)\nhard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)\n\nCompute the hard dependencies between models.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_node_status!","page":"Internal API","title":"PlantSimEngine.init_node_status!","text":"init_node_status!(\n    node, \n    statuses, \n    mapped_vars, \n    reverse_multiscale_mapping,\n    vars_need_init=Dict{String,Any}(),\n    type_promotion=nothing;\n    check=true,\n    attribute_name=:plantsimengine_status)\n)\n\nInitialise the status of a plant graph node, taking into account the multiscale mapping, and add it to the statuses dictionary.\n\nArguments\n\nnode: the node to initialise\nstatuses: the dictionary of statuses by node type\nmapped_vars: the template of status for each node type\nreverse_multiscale_mapping: the variables that are mapped to other scales\nvar_need_init: the variables that are not initialised or computed by other models\nnodes_with_models: the nodes that have a model defined for their symbol\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors (see details)\nattribute_name: the name of the attribute to store the status in the node, by default: :plantsimengine_status\n\nDetails\n\nMost arguments can be computed from the graph and the mapping:\n\nstatuses is given by the first initialisation: statuses = Dict(i => Status[] for i in nodes_with_models)\nmapped_vars is computed using mapped_variables(), see code in init_statuses\nvars_need_init is computed using `varsneedinit = Dict(org => filter(x -> isa(last(x), UninitializedVar), vars) |> keys for (org, vars) in mapped_vars) |>\n\nfilter(x -> length(last(x)) > 0)`\n\nThe check argument is a boolean indicating if variables initialisation should be checked. In the case that some variables need initialisation (partially initialized mapping), we check if the value can be found  in the node attributes (using the variable name). If true, the function returns an error if the attribute is missing, otherwise it uses the default value from the model.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_simulation-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_simulation","text":"init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)\n\nInitialise the simulation. Returns:\n\nthe mtg\na status for each node by organ type, considering multi-scale variables\nthe dependency graph of the models\nthe models parsed as a Dict of organ type => NamedTuple of process => model mapping\nthe pre-allocated outputs\n\nArguments\n\nmtg: the MTG\nmapping::Dict{String,Any}: a dictionary of model mapping\nnsteps: the number of steps of the simulation\noutputs: the dynamic outputs needed for the simulation\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\nverbose: print information about errors in the mapping\n\nDetails\n\nThe function first computes a template of status for each organ type that has a model in the mapping. This template is used to initialise the status of each node of the MTG, taking into account the user-defined  initialisation, and the (multiscale) mapping. The mapping is used to make references to the variables that are defined at another scale, so that the values are automatically updated when the variable is changed at the other scale. Two types of multiscale variables are available: RefVector and MappedVar. The first one is used when the variable is mapped to a vector of nodes, and the second one when it is mapped to a single node. This  is given by the user through the mapping, using a string for a single node (e.g. => \"Leaf\"), and a vector of strings for a vector of nodes (e.g. => [\"Leaf\"] for one type of node or => [\"Leaf\", \"Internode\"] for several). \n\nThe function also computes the dependency graph of the models, i.e. the order in which the models should be called, considering the dependencies between them. The dependency graph is used to call the models in the right order when the simulation is run.\n\nNote that if a variable is not computed by models or initialised from the mapping, it is searched in the MTG attributes.  The value is not a reference to the one in the attribute of the MTG, but a copy of it. This is because we can't reference  a value in a Dict. If you need a reference, you can use a Ref for your variable in the MTG directly, and it will be  automatically passed as is.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_statuses","page":"Internal API","title":"PlantSimEngine.init_statuses","text":"init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)\n\nGet the status of each node in the MTG by node type, pre-initialised considering multi-scale variables.\n\nArguments\n\nmtg: the plant graph\nmapping: a dictionary of model mapping\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\ntype_promotion: the type promotion to use for the variables\nverbose: print information when compiling the mapping\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\n\nReturn\n\nA NamedTuple of status by node type, a dictionary of status templates by node type, a dictionary of variables mapped to other scales, a dictionary of variables that need to be initialised or computed by other models, and a vector of nodes that have a model defined for their symbol:\n\n(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.initialise_all_as_hard_dependency_node","text":"initialise_all_as_hard_dependency_node(models)\n\nTake a set of models and initialise them all as a hard dependency node, and  return a dictionary of :process => HardDependencyNode.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}","page":"Internal API","title":"PlantSimEngine.is_graph_cyclic","text":"is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)\n\nCheck if the dependency graph is cyclic.\n\nArguments\n\ndependency_graph::DependencyGraph: the dependency graph to check.\nfull_stack::Bool=false: if true, return the full stack of nodes that makes the cycle, otherwise return only the cycle.\nwarn::Bool=true: if true, print a stylised warning message when a cycle is detected.\n\nReturn a boolean indicating if the graph is cyclic, and the stack of nodes as a vector.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.mapped_variables","page":"Internal API","title":"PlantSimEngine.mapped_variables","text":"mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)\n\nGet the variables for each organ type from a dependency graph, with MappedVars for the multiscale mapping.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.mapped_variables_no_outputs_from_other_scale","page":"Internal API","title":"PlantSimEngine.mapped_variables_no_outputs_from_other_scale","text":"mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))\n\nGet the variables for each organ type from a dependency graph, without the variables that are outputs from another scale.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nDetails\n\nThis function returns a dictionary with the (multiscale-) inputs and outputs variables for each organ type. \n\nNote that this function does not include the variables that are outputs from another scale and not computed by this scale, see mapped_variables_with_outputs_as_inputs for that.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.model_-Tuple{AbstractModel}","page":"Internal API","title":"PlantSimEngine.model_","text":"model_(m::AbstractModel)\n\nGet the model of an AbstractModel (it is the model itself if it is not a MultiScaleModel).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel for different objects, or false otherwise. \n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over objects, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model T or the whole dependency graph is parallelizable, i.e. if the model can be computed in parallel for different time-steps or objects. The default implementation returns false for all models.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is parallelizable:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable:\n\nparallelizable(MyModel()) # true\n\nOr if we want to be more explicit:\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.pre_allocate_outputs-NTuple{6, Any}","page":"Internal API","title":"PlantSimEngine.pre_allocate_outputs","text":"pre_allocate_outputs(statuses, outs, nsteps; check=true)\n\nPre-allocate the outputs of needed variable for each node type in vectors of vectors. The first level vectors have length nsteps, and the second level vectors have length n_nodes of this type.\n\nNote that we pre-allocate the vectors for the time-steps, but not for each organ, because we don't  know how many nodes will be in each organ in the future (organs can appear or disapear).\n\nArguments\n\nstatuses: a dictionary of status by node type\nouts: a dictionary of outputs by node type\nnsteps: the number of time-steps\ncheck: whether to check the mapping for errors. Default (true) returns an error if some variables do not exist.\n\nIf false and some variables are missing, return an info, remove the unknown variables and continue.\n\nReturns\n\nA dictionary of pre-allocated output of vector of time-step and vector of node of that type.\n\nExamples\n\njulia> using PlantSimEngine, MultiScaleTreeGraph, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nDefine the models mapping:\n\njulia> mapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0, carbon_biomass=1.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0, carbon_biomass=1.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nImporting an example MTG provided by the package:\n\njulia> mtg = import_mtg_example();\n\njulia> statuses, status_templates, reverse_multiscale_mapping, vars_need_init = PlantSimEngine.init_statuses(mtg, mapping);\n\njulia> outs = Dict(\"Leaf\" => (:carbon_assimilation, :carbon_demand), \"Soil\" => (:soil_water_content,));\n\nPre-allocate the outputs as a dictionary:\n\njulia> preallocated_vars = PlantSimEngine.pre_allocate_outputs(statuses, status_templates, reverse_multiscale_mapping, vars_need_init, outs, 2);\n\nThe dictionary has a key for each organ from which we want outputs:\n\njulia> collect(keys(preallocated_vars))\n2-element Vector{String}:\n \"Soil\"\n \"Leaf\"\n\nEach organ has a dictionary of variables for which we want outputs from,  with the pre-allocated empty vectors (one per time-step that will be filled with one value per node):\n\njulia> collect(keys(preallocated_vars[\"Leaf\"]))\n3-element Vector{Symbol}:\n :carbon_assimilation\n :node\n :carbon_demand\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.ref_var-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.ref_var","text":"ref_var(v)\n\nCreate a reference to a variable. If the variable is already a Base.RefValue, it is returned as is, else it is returned as a Ref to the copy of the value, or a Ref to the RefVector (in case v is a RefVector).\n\nExamples\n\njulia> using PlantSimEngine;\n\njulia> PlantSimEngine.ref_var(1.0)\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var([1.0])\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(Base.RefValue(1.0))\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var(Base.RefValue([1.0]))\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))\nBase.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Internal API","title":"PlantSimEngine.reverse_mapping","text":"reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)\nreverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nGet the reverse mapping of a dictionary of model mapping, i.e. the variables that are mapped to other scales, or in other words, what variables are given to other scales from a given scale. This is used for e.g. knowing which scales are needed to add values to others.\n\nArguments\n\nmapping::Dict{String,Any}: A dictionary of model mapping.\nall::Bool: Whether to get all the variables that are mapped to other scales, including the ones that are mapped as single values.\n\nReturns\n\nA dictionary of organs (keys) with a dictionary of organs => vector of pair of variables. You can read the output as: \"for each organ (source organ), to which other organ (target organ) it is giving values for its own variables. Then for each of these source organs, which variable it is giving to the target organ (first symbol in the pair), and to which variable it is mapping the value into the target organ (second symbol in the pair)\".\n\nExamples\n\njulia> using PlantSimEngine\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\njulia> mapping = Dict( \"Plant\" => MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \"Internode\" => ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nNotice we provide \"Soil\", not [\"Soil\"] in the mapping of the ToyAssimModel for the Leaf. This is because we expect a single value for the soil_water_content to be mapped here (there is only one soil). This allows  to get the value as a singleton instead of a vector of values.\n\njulia> PlantSimEngine.reverse_mapping(mapping)\nDict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:\n  \"Soil\"      => Dict(\"Leaf\"=>Dict(:soil_water_content=>:soil_water_content))\n  \"Internode\" => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n  \"Leaf\"      => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"Internal API","title":"PlantSimEngine.save_results!","text":"save_results!(object::GraphSimulation, i)\n\nSave the results of the simulation for time-step i into the  object. For a GraphSimulation object, this will save the results from the status(object) in the outputs(object).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_multiscale_output","text":"search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies at other scales.\norgan::String: the organ for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => [:subprocess => (:var1, :var2)].\nsoft_dep_graphs::Dict{String, ...}: a dict of organ => (softdepgraph, inputs, outputs).\nrev_mapping::Dict{Symbol, Symbol}: a dict of mapped variable => source variable (this is the reverse mapping).\n'harddependenciesfromotherscale' : a vector of HardDependencyNode to provide access to the hard dependencies without traversing the whole graph\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies variables found in outputs of other scales for each process, e.g.:\n\nDict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:\n    \"Internode\" => Dict(:carbon_demand=>[:carbon_demand])\n    \"Leaf\"      => Dict(:carbon_assimilation=>[:carbon_assimilation], :carbon_demand=>[:carbon_demand])\n\nThis means that the variable :carbon_demand is computed by the process :carbon_demand at the scale \"Internode\", and the variable :carbon_assimilation  is computed by the process :carbon_assimilation at the scale \"Leaf\". Those variables are used as inputs for the process that we just passed.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.soft_dependencies","page":"Internal API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}","page":"Internal API","title":"PlantSimEngine.status_from_template","text":"status_from_template(d::Dict{Symbol,Any})\n\nCreate a status from a template dictionary of variables and values. If the values  are already RefValues or RefVectors, they are used as is, else they are converted to Refs.\n\nArguments\n\nd::Dict{Symbol,Any}: A dictionary of variables and values.\n\nReturns\n\nA Status.\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> a, b = PlantSimEngine.status_from_template(Dict(:a => 1.0, :b => 2.0));\n\njulia> a\n1.0\n\njulia> b\n2.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel over time-steps, or false otherwise.\n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over time-steps, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\nobject_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over objects:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!","text":"transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)\n\nFind variables that are inputs to other scales as a SingleNodeMapping and declare them as MappedVar from themselves in the source scale. This helps us declare it as a reference when we create the template status objects.\n\nThese node are found in the mapping as [:variable_name => \"Plant\"] (notice that \"Plant\" is a scalar value).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nfunction f(node)\n    node.value\nend\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_multiscale","page":"Internal API","title":"PlantSimEngine.variables_multiscale","text":"variables_multiscale(node, organ, mapping, st=NamedTuple())\n\nGet the variables of a HardDependencyNode, taking into account the multiscale mapping, i.e. defining variables as MappedVar if they are mapped to another scale. The default values are  taken from the model if not given by the user (st), and are marked as UninitializedVar if  they are inputs of the node.\n\nReturn a NamedTuple with the variables and their default values.\n\nArguments\n\nnode::HardDependencyNode: the node to get the variables from.\norgan::String: the organ type, e.g. \"Leaf\".\nvars_mapping::Dict{String,T}: the mapping of the models (see details below).\nst::NamedTuple: an optional named tuple with default values for the variables.\n\nDetails\n\nThe vars_mapping is a dictionary with the organ type as key and a dictionary as value. It is  computed from the user mapping like so:\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.variables_outputs_from_other_scale","text":"variables_outputs_from_other_scale(mapped_vars)\n\nFor each organ in the mapped_vars, find the variables that are outputs from another scale and not computed at this scale otherwise. This function is used with mapped_variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"Internal API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"Internal API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"introduction/why_plantsimengine/#Why-PlantSimEngine?","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine?","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"PlantSimEngine was developed to address fundamental limitations in existing plant modeling tools. This framework emerged from the need for a system that could efficiently handle the complex dynamics of the soil-plant-atmosphere continuum while remaining accessible to researchers and practitioners from diverse disciplines.","category":"page"},{"location":"introduction/why_plantsimengine/#The-Current-Landscape-of-Plant-Modeling","page":"Why PlantSimEngine ?","title":"The Current Landscape of Plant Modeling","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Plant modeling has evolved significantly over the years, with different tools making different design tradeoffs to address specific research needs. These tools generally fall into three categories, each with their own strengths and limitations:","category":"page"},{"location":"introduction/why_plantsimengine/#Monolithic-Systems","page":"Why PlantSimEngine ?","title":"Monolithic Systems","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Systems like APSIM[1], GroIMP[2], AMAPStudio[3], Helios[4], and CPlantBox[5] offer comprehensive functionality but present certain tradeoffs:","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"These systems provide robust, well-tested frameworks with established scientific validity, but their large, complex codebases can be challenging to navigate and modify without extensive programming expertise.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Their comprehensive architecture offers a wealth of integrated features but may require adaptation when implementing novel approaches that don't align with their predefined frameworks.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"They excel at specific types of simulations but may require additional engineering effort for seamless multi-scale simulations and model coupling across the soil-plant-atmosphere continuum.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"These platforms typically require dedicated engineering resources for maintenance and extension, with research teams often needing specialized technical staff to implement new models.","category":"page"},{"location":"introduction/why_plantsimengine/#Distributed-Systems","page":"Why PlantSimEngine ?","title":"Distributed Systems","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Platforms like OpenAlea[6] and Crops in Silico[7] offer different advantages and tradeoffs:","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"These systems provide accessible interfaces (often in Python) that prioritize ease of use and flexibility, making them approachable for many researchers, though they may require performance optimization for large-scale simulations.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Their modular nature facilitates component reuse and integration, while sometimes requiring proficiency in multiple programming languages for extending computational backends.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"They support diverse modeling paradigms but may involve a longer iteration cycle between design, implementation, and performance tuning compared to more specialized tools.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"While offering flexibility, implementing complex models often requires significant developer time, especially when optimizing performance using lower-level languages.","category":"page"},{"location":"introduction/why_plantsimengine/#Architecture-Focused-Tools","page":"Why PlantSimEngine ?","title":"Architecture-Focused Tools","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Tools like AMAPSim[8] make specific design choices that benefit certain applications:","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"These systems excel in their focused domains (such as structural modeling of plants) while requiring integration with other tools for comprehensive studies of plant physiology and environmental responses.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Their implementation in languages like C++ or Java delivers excellent performance but represents a tradeoff in terms of accessibility for researchers without expertise in these languages.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"They provide sophisticated functionality in their target domains but may require additional work for rapid hypothesis testing and model prototyping across diverse aspects of plant science.","category":"page"},{"location":"introduction/why_plantsimengine/#The-PlantSimEngine-Solution","page":"Why PlantSimEngine ?","title":"The PlantSimEngine Solution","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"PlantSimEngine brings together innovative ideas to address these various tradeoffs, offering a unique combination of features:","category":"page"},{"location":"introduction/why_plantsimengine/#Automatic-Model-Coupling","page":"Why PlantSimEngine ?","title":"Automatic Model Coupling","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Seamless Integration: PlantSimEngine leverages Julia's multiple-dispatch capabilities to automatically compute the dependency graph between models. This allows researchers to effortlessly couple models without writing complex connection code or manually managing dependencies.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Intuitive Multi-Scale Support: The framework naturally handles models operating at different scales—from organelle to ecosystem—connecting them with minimal effort and maintaining consistency across scales.","category":"page"},{"location":"introduction/why_plantsimengine/#Flexibility-with-Precision-Control","page":"Why PlantSimEngine ?","title":"Flexibility with Precision Control","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Effortless Model Switching: Researchers can switch between different component models using a simple syntax without rewriting the underlying model code. This enables rapid comparison between different hypotheses and model versions, accelerating the scientific discovery process.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Fine-Grained Model Control: PlantSimEngine allows users to fix parameters, force variables to match observed values, or select simpler models for specific processes. This flexibility helps reduce overall system complexity while maintaining precision where it matters most.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Adaptive Scalability: The same framework efficiently supports both simple prototypes for single-plant studies and complex ecosystem simulations, scaling computational resources appropriately to the problem at hand.","category":"page"},{"location":"introduction/why_plantsimengine/#Outstanding-Performance","page":"Why PlantSimEngine ?","title":"Outstanding Performance","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"High-Speed Computation: Benchmarks demonstrate operations completing in hundreds of nanoseconds, making PlantSimEngine suitable for computationally intensive applications. For example, the PlantBiophysics.jl implementation is over 38,000 times faster than equivalent implementations in R.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Computational Efficiency: Julia's just-ahead-of-time compilation and native support for parallelism ensure that optimizations made during prototyping directly transfer to larger-scale applications, eliminating the need for reimplementation in a different language for performance gains.","category":"page"},{"location":"introduction/why_plantsimengine/#Developer-Efficiency","page":"Why PlantSimEngine ?","title":"Developer Efficiency","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Reduced Implementation Time: PlantSimEngine leverages Julia's dynamic language features while maintaining the performance of statically-compiled languages. This significantly reduces the time researchers spend implementing and optimizing models.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Modular Building Blocks: The component-based architecture allows models to be built as unit components that can be stacked like building blocks to create complex systems. This modularity dramatically increases code reuse and reduces redundant implementation efforts.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"No Engineering Overhead: Unlike monolithic systems that require dedicated engineering teams or distributed platforms that need backend optimization, PlantSimEngine enables domain scientists to independently develop high-performance models without specialized programming expertise.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Rapid Prototyping to Production: The same code used for quick prototyping can transition directly to production-scale simulations without rewriting, eliminating the traditional gap between exploratory research and application.","category":"page"},{"location":"introduction/why_plantsimengine/#Key-Innovations","page":"Why PlantSimEngine ?","title":"Key Innovations","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"PlantSimEngine's approach to plant modeling represents a paradigm shift in how scientists can build and use models:","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Uniform API: Standardized interfaces make it easy to define new processes and component models, reducing the cognitive load on researchers.\nAutomatic Dependency Resolution: The system automatically determines the relationships between different models and processes, eliminating the need for manual coupling.\nSeamless Parallelization: Out-of-the-box support for parallel and distributed computation allows researchers to focus on the science rather than implementation details.\nFlexible Model Integration: The ability to easily combine models from different sources and at different scales facilitates more comprehensive and realistic simulations.\nUser-Centric Design: Emphasizing usability ensures that researchers with varied programming backgrounds can effectively engage with the system.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"By offering solutions to the various tradeoffs present in existing modeling approaches, PlantSimEngine enables researchers to focus more on scientific questions and less on technical implementation details, accelerating the pace of discovery in plant science, agronomy, and related fields.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[1]: Holzworth, D. P. et al. APSIM – Evolution towards a new generation of agricultural systems simulation. Environmental Modelling & Software 62, 327-350 (2014).","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[2]: Hemmerling, R., Kniemeyer, O., Lanwert, D., Kurth, W. & Buck-Sorlin, G. The rule-based language XL and the modelling environment GroIMP illustrated with simulated tree competition. Funct. Plant Biol. 35, 739 (2008).","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[3]: Griffon, S., and de Coligny, F. AMAPstudio: An editing and simulation software suite for plants architecture modelling. Ecological Modelling 290 (2014): 3‑10. https://doi.org/10.1016/j.ecolmodel.2013.10.037.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[4]: Bailey, R. Spatial Modeling Environment for Enhancing Conifer Crown Management. Front. For. Glob. Change 3, 106 (2020).","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[5]: Schnepf, A., Leitner, D., Landl, M., Lobet, G., Mai, T. H., Morandage, S., Sheng, C., Zörner, M., Vanderborght, J., & Vereecken, H. CPlantBox: A whole-plant modelling framework for the simulation of water- and carbon-related processes. in silico Plants, 63 (2018).","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[6]: Pradal, C. et al. OpenAlea: A visual programming and component-based software platform for plant modeling. Funct. Plant Biol. 35, 751-760 (2008).","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[7]: Marshall-Colon, A. et al. Crops In Silico: Generating Virtual Crops Using an Integrative and Multi-Scale Modeling Platform. Frontiers in Plant Science 8 (2017). https://doi.org/10.3389/fpls.2017.00786.","category":"page"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"[8]: Barczi, J.-F., Rey, H., Caraglio, Y., Reffye, P. de, Barthélémy, D., Dong, Q. X., & Fourcaud, T. AmapSim: A Structural Whole-plant Simulator Based on Botanical Knowledge and Designed to Host External Functional Models. Annals of botany, 101(8), 1125-1138 (2008).","category":"page"},{"location":"multiscale/multiscale_example_3/#Fixing-bugs-in-the-plant-simulation","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo, CSV, DataFrames\nusing MultiScaleTreeGraph\nfunction get_root_end_node(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\", filter_fun = MultiScaleTreeGraph.isleaf)\nend\n\nfunction get_roots_count(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return length(MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\"))\nend\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend\n\nPlantSimEngine.@process \"organ_emergence\" verbose = false\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\n    water_leaf_threshold::T\nend\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0,leaves_max_surface_area=100.0,\nwater_leaf_threshold=30.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area, water_leaf_threshold)\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0,water_stock=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if water levels are low, prioritise roots\n    if status.water_stock < m.water_leaf_threshold\n        return nothing\n    end\n\n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend\n\n############################\n# Naive water absorption model\n# Absorbs precipitation water depending on quantity of roots \n############################\nPlantSimEngine.@process \"water_absorption\" verbose = false\n\nstruct ToyWaterAbsorptionModel <: AbstractWater_AbsorptionModel\nend\n\nPlantSimEngine.inputs_(::ToyWaterAbsorptionModel) = (root_water_assimilation=1.0,)\nPlantSimEngine.outputs_(::ToyWaterAbsorptionModel) = (water_absorbed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyWaterAbsorptionModel, models, status, meteo, constants=nothing, extra=nothing)\n    #root_end = get_root_end_node(status.node)\n    #root_len = root_end[:Root_len]\n    status.water_absorbed = meteo.Precipitations * status.root_water_assimilation #* root_len\nend\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyWaterAbsorptionModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyWaterAbsorptionModel}) = PlantSimEngine.IsObjectIndependent()\n\n\n##########################\n### Root growth : when water stocks are low, expand root\n##########################\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel{T} <: AbstractRoot_GrowthModel\n    water_threshold::T\n    carbon_root_creation_cost::T\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = (water_stock=0.0,carbon_stock=0.0,)\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        \n        root_end = get_root_end_node(status.node)\n        \n        if length(root_end) != 1 \n            throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n        end\n        root_len = get_roots_count(root_end[1])\n        if root_len < m.root_max_len\n            st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n            status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n        end\n    else\n        status.carbon_root_creation_consumed = 0.0\n    end\nend\n\n##########################\n### Model accumulating carbon and water resources \n##########################\n\nPlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n#status.water_stock += meteo.precipitations * root_water_assimilation_ratio\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(water_absorbed=0.0,carbon_captured=0.0,carbon_organ_creation_consumed=0.0,carbon_root_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (water_stock=-Inf,carbon_stock=-Inf)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_stock += sum(status.water_absorbed) #- status.water_transpiration\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed) - sum(status.carbon_root_creation_consumed)\n\n    if status.water_stock < 0.0\n        status.water_stock = 0.0\n    end\nend\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyStockComputationModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyStockComputationModel}) = PlantSimEngine.IsObjectIndependent()\n\n########################\n## Leaf model capturing some arbitrary carbon quantity\n########################\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple()#(TT_cu=-Inf)\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    # very crude approximation with LAI of 1 and constant PPFD\n    status.carbon_captured = 200.0 *(1.0 - exp(-0.2))\nend\n\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLeafCarbonCaptureModel}) = PlantSimEngine.IsObjectIndependent()\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLeafCarbonCaptureModel}) = PlantSimEngine.IsTimeStepIndependent()\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>[\"Root\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:water_stock)=>\"Plant\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" => ( MultiScaleModel(\n            model=ToyRootGrowthModel(10.0, 50.0, 10),\n            mapped_variables=[PreviousTimeStep(:carbon_stock)=>\"Plant\",\n            PreviousTimeStep(:water_stock)=>\"Plant\"],\n        ),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)\n\n    mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n\n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    plant_root_start = MultiScaleTreeGraph.Node(\n        plant, \n        MultiScaleTreeGraph.NodeMTG(\"+\", \"Root\", 1, 3), \n    )\n\n    meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"There are two major issues hinted at in last chapter's implementation, which we'll discuss and resolve here.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"You can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Pages = [\"multiscale_example_3.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale_example_3/#An-organ-creation-problem","page":"Fixing bugs in the plant simulation","title":"An organ creation problem","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"There is one quirk you may have noticed when inspecting the data : when a root expands, the new root is immediately active, and some models may act on it immediately... including the root growth model. Meaning this new root may also sprout another root in the same timestep, and so on.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"You can notice this by looking at the simulation's state after the first timestep:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"outs = run!(mtg, mapping, first(meteo_day, 2))\nnodes_per_timestep = outs[\"Root\"][:node]\nroot_lengths_per_timestep = [length(nodes_per_timestep[i]) for i in 1:length(nodes_per_timestep)]\n","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Our root grew to full length within one timestep. Oops.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"This is an implementation decision in PlantSimEngine. By default, newly created organs are active, and models can affect them as soon as they are created.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"In our case, internode growth depends on a threshold thermal time value, which accumulates over several timesteps, so even though new internodes are immediately active, they can't themselves grow new organs within the same timestep. But as we've just showcased, we have a root problem.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"This quirk is also handled in XPalm.jl, a package using PlantSimEngine: some organs make use of state machines, and are considered \"immature\" when they are created. Immature organs cannot grow new organs until some conditions are met for their state to change. There are also other conditions governing organ emergence, such as specific threshold values relating to Thermal Time (see here for an example).","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"note: Note\nThis implementation decision for new organs to be immediately active may be subject to change in future versions of PlantSimEngine. Also note that the way the dependency graph is structured determines the order in which models run. Meaning that which models are run before or after organ creation might change with new additions and updates to your mapping. Some models might run \"one timestep later\", see Simulation order instability when adding models for more details.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"note: Note\nMTG node output data has a couple of subtleties, see Multi-scale output data structure for more details","category":"page"},{"location":"multiscale/multiscale_example_3/#Delaying-organ-maturity","page":"Fixing bugs in the plant simulation","title":"Delaying organ maturity","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"How do we avoid this extreme instant growth ? We can, of course, add some thermal time constraint. We could arbitrarily tinker with water resources. ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"We can otherwise add a simple state machine variable to our root and internodes in the MTG, indicating a newly added organ is immature and cannot grow on the same timestep. Since our root doesn't branch, we can simply keep track of a single state variable. See the State machines section for some examples.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"In fact, we could change the scale at which the check is made to extend the root, and have another model call this one directly. This enables running this model only for the end root when those occasional timesteps when root growth is possible, instead of at every timestep for every root node.","category":"page"},{"location":"multiscale/multiscale_example_3/#A-resource-distribution-bug","page":"Fixing bugs in the plant simulation","title":"A resource distribution bug","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Another problem you may have noticed, is that the water and carbon stock are computed by aggregating photosynthesis over leaves and absorption over roots... But they aren't always properly decremented when consumed !","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"If the end root grows, it outputs a carbon_root_creation_consumed value, but under certain conditions, we might also create other roots and internodes even when there shouldn't be enough carbon left for them. ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Indeed, if both the root and leaf water thresholds are met, and there is enough carbon for a single root or internode but not for both, and the root model runs before the internode model, both will use the carbon_stock variable prior to organ emission. The internode emission model won't account for the root carbon consumption.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"This occurs because carbon_stock is only computed once, and won't update until the next timestep.","category":"page"},{"location":"multiscale/multiscale_example_3/#Fixing-resource-computation:-a-root-growth-decision-model","page":"Fixing bugs in the plant simulation","title":"Fixing resource computation: a root growth decision model","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"To avoid that problem in our specific case, we can couple the root growth model and the internode emission model, and pass the carbon_root_creation_consumed variable to the internode emission model so that it can use an updated carbon stock. Or we could have an intermediate model recompute the new stock to pass along to the internode emission model. ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"There is a section in the [Tips and workarounds] page discussing this situation and other potential solutions: Having a variable simultaneously as input and output of a model.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"We'll go for the first option and couple the root growth and internode emission model.","category":"page"},{"location":"multiscale/multiscale_example_3/#Internode-emission-adjustments","page":"Fixing bugs in the plant simulation","title":"Internode emission adjustments","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The only change required for our internode emission model is to take into account carbon_root_creation_consumed as a new input, map that variable from the \"Root\" scale in our mapping, and compute the adjusted carbon stock. Here's the relevant excerpt in the run! function.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":" # take into account that the stock may already be depleted \n    carbon_stock_updated_after_roots = status.carbon_stock - status.carbon_root_creation_consumed\n\n    # if not enough carbon, no organ creation\n    if carbon_stock_updated_after_roots < m.carbon_internode_creation_cost\n        return nothing\n    end","category":"page"},{"location":"multiscale/multiscale_example_3/#A-multi-scale-hard-dependency-appears","page":"Fixing bugs in the plant simulation","title":"A multi-scale hard dependency appears","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Our root growth decision model inherits some of the responsibility from last chapter's root growth model, so inputs, parameters and condition checks will be similar. We'll let the root growth model keep the length check and only focus on resources.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Since the decision model is now directly responsible for calling the actual root growth model, we need to declare that it requires a root growth model as a hard dependency and cannot be run standalone. ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"This hard dependency is in fact multiscale, since both models operate at different scales, \"Plant\" and \"Root\". You can read more about multi-scale hard dependencies in the Handling dependencies in a multiscale context page.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Compared to the single-scale equivalent, the multi-scale declaration additionally requires mapping the scale:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"PlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The status argument run! function of the root growth decision model only contains variables from the \"Plant\" scale, or explicitely mapped to this scale, which isn't the case for the root growth's variables. To make use of the root growth model's variables, we need to recover the status at the \"Root\" scale. It is accessible from the extra argument in run!'s signature. ","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"In multi-scale simulations, this extra argument implicitely contains an object storing the simulation state. It contains the statuses at various scales, and all the models indexed per scale and process name.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Access to the \"Root\" status within the root growth decision model run! function is done like so:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"status_Root= extra_args.statuses[\"Root\"][1]","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"It is then possible to call the root growth model from the parent's run! function:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"PlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Which will enable writing the rest of the run! function.","category":"page"},{"location":"multiscale/multiscale_example_3/#Root-growth-decision-model-implementation","page":"Fixing bugs in the plant simulation","title":"Root growth decision model implementation","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"With that new coupling consideration properly handled, we can complete the full model implementation:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"PlantSimEngine.@process \"root_growth_decision\" verbose = false\n\nstruct ToyRootGrowthDecisionModel{T} <: AbstractRoot_Growth_DecisionModel\n    water_threshold::T\n    carbon_root_creation_cost::T\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthDecisionModel) = \n(water_stock=0.0,carbon_stock=0.0)\n\nPlantSimEngine.outputs_(::ToyRootGrowthDecisionModel) = NamedTuple()\n\nPlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)\n\n# \"status\" is at the \"Plant\" scale\nfunction PlantSimEngine.run!(m::ToyRootGrowthDecisionModel, models, status, meteo, constants=nothing, extra=nothing)\n\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        # Obtain \"status\" at \"Root\" scale\n        status_Root= extra_args.statuses[\"Root\"][1]\n        # Call the hard dependency model directly with its status\n        PlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)\n    end\nend","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The root growth model will output the carbon_root_creation_consumed computation, but it'll still be exposed to downstream models despite the root growth model being a 'hidden' model in the dependency graph due to its hard dependency nature.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"With this new coupling, we will only be creating at most a single new root per timestep, as the root growth decision will only be called once per timestep. ","category":"page"},{"location":"multiscale/multiscale_example_3/#Root-growth","page":"Fixing bugs in the plant simulation","title":"Root growth","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"This iteration turns into a simplifed version of last chapter's.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"PlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel <: AbstractRoot_GrowthModel\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = NamedTuple()\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)    \n    status.carbon_root_creation_consumed = 0.0\n\n    root_end = get_root_end_node(status.node)\n        \n    if length(root_end) != 1 \n        throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n    end\n    \n    root_len = get_roots_count(root_end[1])\n    if root_len < m.root_max_len\n        st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n        status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n    end\nend","category":"page"},{"location":"multiscale/multiscale_example_3/#Mapping-adjustments","page":"Fixing bugs in the plant simulation","title":"Mapping adjustments","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The new mapping only has straightforward changes. Some models cease to be multi-scale, others require new variables to be mapped for them. carbon_root_creation_consumed ceases to be a vector mapping and is a scalar variable.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>\"Root\",\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n    MultiScaleModel(\n        model=ToyRootGrowthDecisionModel(10.0, 50.0),\n    ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            :water_stock=>\"Plant\",\n            :carbon_stock=>\"Plant\", \n            :carbon_root_creation_consumed=>\"Root\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" =>   (ToyRootGrowthModel(10),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"We can now run our simulation as we did previously... or can we ?","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"ERROR: Cyclic dependency detected for process resource_stock_computation: resource_stock_computation for organ Plant depends on root_growth from organ Root, which depends on the first one. This is not allowed, you may need to develop a new process that does the whole computation by itself.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Ah, it looks like our additional usage of the root carbon cost creates a cyclic dependency. ","category":"page"},{"location":"multiscale/multiscale_example_3/#Breaking-the-dependency-cycle","page":"Fixing bugs in the plant simulation","title":"Breaking the dependency cycle","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Fortunately, the logic here is quite straightforward. We can't be computing our current timestep's resource stock with carbon_root_creation_consumed, and then updating it right after root creation again using a new value of carbon_root_creation_consumed.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The solution is hopefully quite intuitive : when we compute resource stocks, we should be computing it using the previous timestep's values. Then root creation happens (or doesn't), and the computed carbon_root_creation_consumed corresponds to the current timestep value. We could also do the same for water to be consistent.","category":"page"},{"location":"multiscale/multiscale_example_3/#Updated-mapping","page":"Fixing bugs in the plant simulation","title":"Updated mapping","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The relevant part of the mapping that needs to be updated is the following:","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"mapping = Dict(\n...\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            PreviousTimeStep(:carbon_root_creation_consumed)=>\"Root\",\n            PreviousTimeStep(:carbon_organ_creation_consumed)=>[\"Internode\"],\n        ],\n        ),\n        ToyRootGrowthDecisionModel(10.0, 50.0),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n...\n)","category":"page"},{"location":"multiscale/multiscale_example_3/#Final-words","page":"Fixing bugs in the plant simulation","title":"Final words","text":"","category":"section"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"And you're now ready to run the simulation.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"The full script can be found here, in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"We now have a plant with two different growth directions. Roots are added at the beginning, until water is considered abundant enough.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"Of course, there are still several design issues with this implementation. It is as utterly unrealistic as the previous one, and doesn't even consume water. Some condition checking is a little ad hoc and could be made more robust. More sanity checks could be added, and the model and variable names could definitely be made more clear.","category":"page"},{"location":"multiscale/multiscale_example_3/","page":"Fixing bugs in the plant simulation","title":"Fixing bugs in the plant simulation","text":"But once again, this example is only made to illustrate what is possible with this framework, and doesn't strive for ecophysiological consistency. And the approach can be made increasingly more complex by refining models and simulation parameters, and feeding in new information about your plant, and ramp up to realistic, production-ready and predictive simulations.","category":"page"},{"location":"multiscale/multiscale_example_1/#Writing-a-multiscale-simulation","page":"A rudimentary plant simulation","title":"Writing a multiscale simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"This three-part subsection walks you through building a multi-scale simulation from scratch. It is meant as an illustration of the iterative process you might go through when building and slowly tuning a Functional-Structural Plant Model, where previous multi-scale examples focused more on the API syntax.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"You can find the full script for the first part's toy simulation in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Pages = [\"multiscale_example_1.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale_example_1/#Disclaimer","page":"A rudimentary plant simulation","title":"Disclaimer","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The actual plant being created, as well as some of the custom models, have no real physical meaning and are very much ad hoc (which is why most of them aren't standalone in the examples folder). Similarly, some of the parameter values are pulled out of thin air, and have no ties to research papers or data.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The main purpose here is to showcase PlantSimEngine's multi-scale features and how to structure your models, not accuracy, realism or performance.","category":"page"},{"location":"multiscale/multiscale_example_1/#Initial-setup","page":"A rudimentary plant simulation","title":"Initial setup","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We'll need to make use of a few packages, as usual, after adding them to our Julia environment:","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"using PlantSimEngine\nusing PlantSimEngine.Examples # to import the ToyDegreeDaysCumulModel model\nusing PlantMeteo\nusing MultiScaleTreeGraph # multi-scale\nusing CSV, DataFrames # used to import the example weather data","category":"page"},{"location":"multiscale/multiscale_example_1/#A-basic-growing-plant","page":"A rudimentary plant simulation","title":"A basic growing plant","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"At minimum, to simulate some kind of fake growth, we need :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"A Multi-scale Tree Graph representing the plant\nSome way of adding organs to the plant\nSome kind of temporality to spread this growth over multiple timesteps","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's have some concept of 'leaves' that capture the (carbon) resource necessary for organ growth, and let's have the organ emergence happen at the 'internode' level, to illustrate multiple organs with different behavior.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We'll make the assumption that the internodes make use of carbon from a common pool. We'll also make use of thermal time as a growth delay factor.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"To sum up : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"MTG with growing internodes and leaves\nIndividual leaves capture carbon fed into a common pool\nInternodes take from that pool to create new organs, with a thermal time constraint.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"One way of modeling this approach translates into several scales and models : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Scene scale, for thermal time. The ToyDegreeDaysCumulModel from the examples folder provides thermal time from temperature data \nPlant scale, where we'll define the carbon pool\nInternode scale, which draws from the pool to create new organs\nLeaf scale, which captures carbon","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's also add a very artificial limiting factor : if the total leaf surface area is above a threshold no new organs are created.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We can expect the simulation mapping to look like a more complex version of the following : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => ToyStockComputationModel(),\n\"Internode\" => ToyCustomInternodeEmergence(),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Some of the models will need to gather variables from scales other than their own, meaning they will need to be converted into MultiScaleModels.","category":"page"},{"location":"multiscale/multiscale_example_1/#Implementation","page":"A rudimentary plant simulation","title":"Implementation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/#Carbon-Capture","page":"A rudimentary plant simulation","title":"Carbon Capture","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's start with the simplest model. Our fake leaves will continuously capture some constant amount of carbon every timestep. No inputs or parameters are required.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # No inputs\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Resource-storage","page":"A rudimentary plant simulation","title":"Resource storage","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The model storing resources for the whole plant needs a couple of inputs: the amount of carbon captured by the leaves, as well as the amount consumed by the creation of new organs. It outputs the current stock.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(carbon_captured=0.0,carbon_organ_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (carbon_stock=-Inf,)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed)\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Organ-creation","page":"A rudimentary plant simulation","title":"Organ creation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"This model is a modified version of the ToyInternodeEmergence model found in the examples folder. An internode produces two leaves and a new internode.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's first define a helper function that iterates across a Multiscale Tree Graph and returns the number of leaves :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"function get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Now that we have that, let's define a few parameters to the model. It requires :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"a thermal time emergence threshold\na carbon cost for organ creation","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We'll also add a couple of other parameters, which could go elsewhere :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"the surface area of a leaf (no variation, no growth stages)\nthe max leaf surface area beyond which organ creation stops","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"organ_emergence\" verbose = false\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\nend","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"note: Note\nWe make use of parametric types instead of the intuitive Float64 for flexibility. See Parametric types for a more in-depth explanation","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And give them some default values : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"ToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0, leaves_max_surface_area=100.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Our internode model requires thermal time, and the amount of available carbon, and outputs the amount of carbon consumed, as well as the last thermal time where emergence happened (this is useful when new organs can be produced multiple times, which won't be the case here).","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Finally, the run! function checks that conditions are met for new organ creation :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"thermal time threshold exceeded\ntotal leaf surface area not above limit\ncarbon available\nno organs already created by that internode","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"and then updates the MTG.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"function PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Updated-mapping","page":"A rudimentary plant simulation","title":"Updated mapping","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We can now define the final mapping for this simulation. ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The carbon capture and thermal time models don't need to be changed from the earlier version.  The organ creation model at the \"Internode\" scale needs the carbon stock from the \"Plant\" scale, as well as thermal time from the \"Scene\" scale. The resource storing model at the \"Plant\" scale needs the carbon captured by every leaf, and the carbon consumed by every internode that created new organs this timestep. This requires mapping vector variables :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"as opposed to the single-valued carbon stock mapped variable : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And of course, some variables need to be initialized in the status:","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],\n        ),\n        Status(carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"note: Note\nThis excerpt (and the complete script file) showcase the final properly initialized mapping, but when developing, you are encouraged to make liberal use of the helper function to_initialize and check the PlantSimEngine user errors.","category":"page"},{"location":"multiscale/multiscale_example_1/#Running-a-simulation","page":"A rudimentary plant simulation","title":"Running a simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We only need an MTG, and some weather data, and then we'll be set. Let's create a simple MTG : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Import some weather data : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And we're good to go ! ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"outs = run!(mtg, mapping, meteo_day)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"If you query or display the MTG after simulation, you'll see it expanded and grew multiple internodes and leaves :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mtg\n#get_n_leaves(mtg)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And that's it ! Feel free to tinker with the parameters and see when things break down, to get a feel for the simulation.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Of course, this is a very crude and unrealistic simulation, with many dubious assumptions and parameters. But significantly more complex modelling is possible using the same approach : XPalm runs using a few dozen models spread out over nine scales.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"This is a three-part tutorial and continues in the Expanding on the multiscale simulation page.","category":"page"},{"location":"prerequisites/key_concepts/#Key-Concepts","page":"Key Concepts","title":"Key Concepts","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You'll find a brief description of some of the main concepts and terminology related to and used in PlantSimEngine. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Pages = [\"key_concepts.md\"]\nDepth = 4","category":"page"},{"location":"prerequisites/key_concepts/#Crop-models","page":"Key Concepts","title":"Crop models","text":"","category":"section"},{"location":"prerequisites/key_concepts/#FSPM","page":"Key Concepts","title":"FSPM","text":"","category":"section"},{"location":"prerequisites/key_concepts/#PlantSimEngine-terminology","page":"Key Concepts","title":"PlantSimEngine terminology","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This page provides a general description of the concepts and terminology used in PlantSimEngine. For a more implementation-guided description of the design and some of the terms presented here, see the Detailed walkthrough of a simple simulation","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"!!! Note     Some terminology unfortunately has different meanings in different contexts. This is particularly true of the terms organ, scale and symbol, which have a different meaning for Multi-scale Tree Graphs than the rest of PlantSimEngine (see Scale/symbol terminology ambiguity further down). Make sure to double-check those subsections, and relevant examples if you encounter issues relating to these terms.","category":"page"},{"location":"prerequisites/key_concepts/#Processes","page":"Key Concepts","title":"Processes","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"See Implementing a new process for a brief explanation on how to declare a new process.","category":"page"},{"location":"prerequisites/key_concepts/#Models","page":"Key Concepts","title":"Models","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Models are then implemented for a particular process. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"There may be different models that can be used for the same process ; for instance, there are multiple hypotheses and ways of modeling photosynthesis, with different granularity and accuracy. A simple photosynthesis model might apply a simple formula and apply it to the total leaf surface, a more complex one might calculate interception and light extinction. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"The companion package PlantBiophysics.jl provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example script in this package too at examples/Beer.jl.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Models can also be used for ad hoc computations that aren't directly tied to a specific literature-defined physiological process. In PlantSimEngine, everything is a model. There are many instances where a custom model might be practical to aggregate some computations or handle other information. To illustrate, XPalm, the Oil Palm model has a few models that handle the state of different organs, and a mdoel to handle leaf pruning, which you can find here.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"To prepare a simulation, you declare a ModelList with whatever models you wish to make use of and initialize necessary parameters: see the stepbystep section to learn how to use them in practice.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"For multi-scale simulations, models need to be tied to a particular scale when used. See the Multiscale modeling section below, or the Multi-scale considerations page for a more detailed description of multi-scale peculiarities.","category":"page"},{"location":"prerequisites/key_concepts/#Variables,-inputs,-outputs,-and-model-coupling","page":"Key Concepts","title":"Variables, inputs, outputs, and model coupling","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"A model used in a simulation requires some input data and parameters, and will compute some other data which may be used by other models.  Depending on what models are combined in a simulation, some variables may be inputs of some models, outputs of other models, only be part of intermediary computations, or be a user input to the whole simulation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Here's a conceptual model coupling example; each \"node\" is equivalent to a distinct PlantSimEngine model, \"compute()\" is equivalent to the model's \"run!\" function:","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Model coupling example) (Source: Autodesk)","category":"page"},{"location":"prerequisites/key_concepts/#Dependency-graphs","page":"Key Concepts","title":"Dependency graphs","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Coupling models together in this fashion creates what is known as a Directed Acyclic Graph or DAG, a type of dependency graph. The order in which models are run is determined by the ordering of these models in that graph.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Example DAG) A simple Directed Acyclic Graph, note the required absence of cycles. Source: Astronomer","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine creates this Directed Acyclic Graph under the hood by plugging the right variables in the right models. Users therefore only need to declare models, they do not need write the code to connect them as PlantSimEngine does that work for them, as long as the model coupling has no cyclic dependency.","category":"page"},{"location":"prerequisites/key_concepts/#hard_dependency_def","page":"Key Concepts","title":"\"Hard\" and \"Soft\" dependencies","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Linking models by setting output variables from one model as input of another model handles many typical couplings (with more situations occurring with multi-scale models and variables), but what if two models are interdependent ? What if they need to iterate on some computation and pass variables back and forth ? ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can find a typical example in a companion package: PlantBioPhysics.jl. An energy balance model, the Monteith model, needs to iteratively run a photosynthesis model in its run! function. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"See the illustration below of the way these models are interdependent:","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Example of a coupling with cycles) Example of a coupling with a cycle. Source: TODO","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Model couplings that cause simulation to flow both ways break the 'acyclic' assumption of the dependency graph.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine handles this internally by not having those \"heavily-coupled\" models -called \"hard dependencies\" from now on- be part of the main dependency graph. Instead, they are made to be children nodes of the parent/ancestor model, which handles them internally, so they aren't tied to other nodes of the dependency graph. The resulting higher-level graph therefore only links models without any two-way interdependencies, and remains a directed graph, enabling a cohesive simulation order. The simpler couplings in that top-level graph are called \"soft dependencies\".","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Hard dependency coupling visualization in PlantSimEngine) The above coupling, handled by PlantSimEngine","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"How PlantSimEngine links these models under the hood. The red models (\"hard dependencies\") are not exposed in the final dependency graph, which only contains the blue \"soft dependencies\", and has no cycles.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This approach does have implications when developing interdependent models : hard dependencies need to be made explicit, and the ancestor needs to call the hard dependency model's run! function explicitely in its own run! function. Hard dependency models therefore must have only one parent model. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This reliance on another process makes these models slightly more complex to develop and validate, and less versatile than simpler models. Occasional refactoring may be necessary to handle a hard dependency creeping up when adding new models to a simulation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Note that hard dependencies can also have their own hard dependencies, and some complex couplings can happen. A hard dependency model can have another hard dependency model as a parent.","category":"page"},{"location":"prerequisites/key_concepts/#Weather-data","page":"Key Concepts","title":"Weather data","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"To run a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. We will make constant use of it throughout the documentation, and recommend working with it. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"In the example below, we also pass in the -optional- incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"More details are available from the package documentation. If you do not wish to make use of this package, you can alternately provide your own data, as long as it respects the Tables.jl interface.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"If you wish to make use of more fine-grained weather data, it will likely require more advanced model creation and MTG manipulation, and more involved work on the modeling side.∂","category":"page"},{"location":"prerequisites/key_concepts/#Organ/Scale","page":"Key Concepts","title":"Organ/Scale","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Plants have different organs with distinct physiological properties and processes. When doing more fine-grained simulations of plant growth, many models will be tied to a particular organ of a plant. Models handling flowering state or root water absorption are such examples. Others, such as carbon allocation and demand, might be reused in slightly different ways for multiple organs of the plant.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine documentation tends to use the terms \"organ\" and \"scale\" mostly interchangeably. \"Scale\" is a bit more general and accurate, since some models might not operate at a specific organ level, but (for example) at the scene level, so a \"Scene\" scale might be present in the MTG, and in the user-provided data.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"When working with multi-scale data, the scale will often need to be specified to map variables, or to indicate at what scale level models work out. You will see some code resembling this :","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"\"Root\" => (RootGrowthModel(), OrganAgeModel()),\n\"Leaf\" => (LightInterceptionModel(), OrganAgeModel()),\n\"Plant\" => (TotalBiomassModel(),),","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This example excerpt links specific models to a specific scale. Note that one model is reused at two different scales, and note that \"Plant\" isn't an actual organ, hence the preferred usage of the term \"scale\".","category":"page"},{"location":"prerequisites/key_concepts/#Multiscale-modeling","page":"Key Concepts","title":"Multiscale modeling","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale modeling is the process of simulating a system at multiple levels of detail simultaneously. Some models might run at the organ scale while others run at the plot scale. Each model can access variables at its scale and other scales if needed, allowing for a more comprehensive system representation. It can also help identify emergent properties that are not apparent at a single level of detail. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"For example, a model of photosynthesis at the leaf scale can be combined with a model of carbon allocation at the plant scale to simulate the growth and development of the plant. Another example is a combination of models to simulate the energy balance of a forest. To simulate it, you need a model for each organ type of the plant, another for the soil, and finally, one at the plot scale, integrating all others.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"When running multi-scale simulations which contain models operating at different organ levels for the plant, extra information needs to be provided by the user to run models. Since some models are reused at different organ levels, it is necessary to indicate which organ level a model operates at.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This is why multi-scale simulations make use of a 'mapping' : the ModelList in the single-scale examples does not have a way to tie models to plant organs,and the more versatile models could be used in various places. The user must also indicate how models operate with other scales, e.g. if an input variable comes from another scale, it is required to indicate which scale it is mapped from.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can read more about some practical differences as a user between single- and multi-scale simulations here: Multi-scale considerations.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"!!! Note     When you encounter the terms \"Single-scale simulations\", or \"ModelList simulations\", they will refer to simulations that are \"not multi-scale\". A multi-scale simulation makes use of a mapping between different organ/scale levels. A single-scale simulation has no such mapping, and uses the simpler ModelList interface. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can implement a mapping that only makes use of a single scale level, of course, making it a \"single-scale multi-scale simulation\", but **unless otherwise specified, single-scale, and the whole section dedicated to single-scale simulations, refer to simulations with ModelList objects, and no mapping**.","category":"page"},{"location":"prerequisites/key_concepts/#Multi-scale-Tree-Graphs","page":"Key Concepts","title":"Multi-scale Tree Graphs","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Grassy plant and equivalent MTG) A Grassy plant and its equivalent MTG","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale Tree Graphs (MTG) are a data structure used to represent plants. A more detailed introduction to the format and its attributes can be found in the MultiScaleTreeGraph.jl package documentation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale simulations can operate on MTG objects ; new nodes are added corresponding to new organs created during the plant's growth.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can see a basic display of an MTG by simply typing its name in the REPL:","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: example display of an MTG in PlantSimEngine)","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"note: Note\nAnother companion package, PlantGeom.jl, can also create MTG objects from .opf files (corresponding to the Open Plant Format, an alternate means of describing plants computationally).","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO lien avec AMAP ?","category":"page"},{"location":"prerequisites/key_concepts/#Scale/symbol-terminology-ambiguity","page":"Key Concepts","title":"Scale/symbol terminology ambiguity","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale tree graphs have different terminology (see Organ/Scale):","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"a symbol corresponds to a PlantSimEngine scale, eg \"Plant\", \"Root\", and has nothing to do with the Julia programming language's definition of symbol (eg :var)\nScales are integers passed to the Node constructor describing the level of description of the tree graph object. They don't always have a one-to-one correspondence to a multi-scale simulation's scales, but are similar.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: Three scale levels on an MTG, which differ from typical PlantSimEngine concept of scale)","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can find a brief description of the MTG concepts here.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Other words are unfortunately reused in various contexts with different meanings: tree/leaf/root have a different meaning when talking about computer science data structure (eg, graphs, dependency graphs and trees).","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"note: Note\nIn the majority of cases, you can assume the tree-related terminology refers to the biological terms, and that \"organ\" refer to plant organs, and \"single-scale\", \"multi-scale\" and \"scale\" to PlantSimEngine's concept of scales described in Organ/Scale. MTG objects are mostly manipulated no a per-node basis, unless a model makes use of functions relating to MTG traversal, in which case you may expect computer science terminology.","category":"page"},{"location":"prerequisites/key_concepts/#State-machines","page":"Key Concepts","title":"State machines","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"A state machine is a computational concept used to model mechanisms and devices, which may be of interest for your simulations.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"(Image: State machine image) A simple state machine. See the wikipedia page for more examples.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"State machines can be useful to model organ state: some organs in XPalm.jl, a package modelling the oil palm using PlantSimEngine, have a state variable behaving like a state machine, indicating whether an organ is mature, pruned, flowering, etc.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can find an example model (amongst other such models) affecting the state variable of some organs depending on their age and thermal time in the XPalm oil palm FSPM here","category":"page"},{"location":"step_by_step/implement_a_process/#Implementing-a-new-process","page":"Implementing a process","title":"Implementing a new process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"using PlantSimEngine\nusing PlantMeteo\nPlantSimEngine.@process growth","category":"page"},{"location":"step_by_step/implement_a_process/#Introduction","page":"Implementing a process","title":"Introduction","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. The next section showcases how to implement a new process with a simple example: implementing a growth model.","category":"page"},{"location":"step_by_step/implement_a_process/#Implement-a-process","page":"Implementing a process","title":"Implement a process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"A process is \"declared\", meaning we define a process, and then implement models for its simulation. Declaring a process generates some boilerplate code for its simulation: ","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"an abstract type for the process\na method for the process function, that is used internally","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"The abstract process type is then used as a supertype of all models implementations for the process, and is named Abstract<process_name>Process, e.g. AbstractLight_InterceptionModel.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"Fortunately, PlantSimEngine provides a macro to generate all that at once: @process. This macro takes only one argument: the name of the process.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"For example, the photosynthesis process in PlantBiophysics.jl is declared using just this tiny line of code:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"@process \"photosynthesis\"","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"If we want to simulate the growth of a plant, we could add a new process called growth:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"@process \"growth\"","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"And that's it! Note that the function guides you in the steps you can make after creating a process.","category":"page"},{"location":"step_by_step/implement_a_process/#Implement-a-new-model-for-the-process","page":"Implementing a process","title":"Implement a new model for the process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"Once process implementation is done, you can write a corresponding model implementation. A tutorial page showcasing a light interception model implementation can be found here","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"A full model implementation for this process is available in the example script ToyAssimGrowthModel.jl.","category":"page"},{"location":"step_by_step/implement_a_process/#under_the_hood","page":"Implementing a process","title":"Under the hood","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"The @process macro is just a shorthand reducing boilerplate.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"You can in its stead directly define a process by hand by defining an abstract type that is a subtype of AbstractModel:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"abstract type AbstractGrowthModel <: PlantSimEngine.AbstractModel end","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"And by adding a method for the process_ function that returns the name of the process:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"PlantSimEngine.process_(::Type{AbstractGrowthModel}) = :growth","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Implementing a process","title":"Implementing a process","text":"So in the earlier example, a new process was created called growth. This defined a new abstract structure called AbstractGrowthModel, which is used as a supertype of the models. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model.","category":"page"},{"location":"working_with_data/inputs/#Input-types","page":"Input types","title":"Input types","text":"","category":"section"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"run! usually takes two inputs: a ModelList and data for the meteorology. The data for the meteorology is usually provided for one time step using an Atmosphere, or for several time-steps using a TimeStepTable{Atmosphere}. The ModelList can also be provided as a singleton, or as a vector or dictionary of.","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"run! knows how to handle these data formats via the PlantSimEngine.DataFormat trait (see this blog post to learn more about traits). For example, we tell PlantSimEngine that a TimeStepTable should be handled like a table by implementing the following trait:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"If you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:MyTableFormat}) = TableAlike()","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"There are two other traits available: SingletonAlike for a data format representing one time-step only, and TreeAlike for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).","category":"page"},{"location":"working_with_data/inputs/#Special-considerations-for-new-input-types","page":"Input types","title":"Special considerations for new input types","text":"","category":"section"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on your use-cases. ","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"For example if you use models that need to get data from a different time step (e.g. a model that needs to get the previous day's temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"To do so, you need to implement the following methods for your structure that defines your rows:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"Base.parent: return the parent table of the row, e.g. the full DataFrame\nPlantMeteo.rownumber: return the row number of the row in the parent table, e.g. the row number in the DataFrame\n(Optionnally) PlantMeteo.row_from_parent(row, i): return row i from the parent table, e.g. the row i from the DataFrame. This is only needed if you want high performance, the default implementation calls Tables.rows(parent(row))[i].","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"compat: Compat\nPlantMeteo.rownumber is temporary. It soon will be replaced by DataAPI.rownumber instead, which will be also used by e.g. DataFrames.jl. See this Pull Request.","category":"page"},{"location":"working_with_data/inputs/#Working-with-weather-data","page":"Input types","title":"Working with weather data","text":"","category":"section"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"Here's a quick example showcasing how to export the example weather data to your own file :","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nPlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"If you wish to filter weather data, reshape it, adjust it, write it, you'll find some more examples in PlantMeteo's API reference.  ","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/#Floating-point-considerations","page":"Floating-point considerations","title":"Floating-point considerations","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo, MultiScaleTreeGraph, CSV\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nout_singlescale = run!(models, meteo_day)","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/#Investigating-a-discrepancy","page":"Floating-point considerations","title":"Investigating a discrepancy","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"In the Converting a single-scale simulation to multi-scale page, a single-scale simulation was converted to an equivalent multiscale simulation, and outputs were compared. One detail that was glossed over, but important to bear in mind as a PlantSimEngine user is related to floating-point approximations.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/#Single-scale-simulation:","page":"Floating-point considerations","title":"Single-scale simulation:","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"### Multi-scale equivalent: ","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"PlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"### Output comparison:","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"mapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)\ncomputed_TT_cu_multiscale = collect(Base.Iterators.flatten(outputs_multiscale[\"Scene\"][:TT_cu]))","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"\ncomputed_TT_cu_multiscale = collect(Base.Iterators.flatten(outputs_multiscale[\"Scene\"][:TT_cu]))\n\nis_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Why was the comparison only approximate ? Why ≈ instead of ==?","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Let's try it out. What if write instead:","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"computed_TT_cu_multiscale = collect(Base.Iterators.flatten(outputs_multiscale[\"Scene\"][:TT_cu]))\n\nis_perfectly_equal = length(unique(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)) == 1","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Why is this false? Let's look at the data.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Looking more closely at the output, we can notice that values are identical up to timestep #105 : ","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[104]","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[105]","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"We have the values 132.33333333333331 (multi-scale) and 132.33333333333334 (single-scale). The final output values are : 2193.8166666666643 (multi-scale) and 2193.816666666666 (single-scale).","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"The divergence isn't huge, but in other situations or over more timesteps it could start becoming a problem.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/#Floating-point-summation","page":"Floating-point considerations","title":"Floating-point summation","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"The reason values aren't identical, is due to the fact that many numbers do not have an exact floating point representation. A classical example is the fact that 0.1 + 0.2 != 0.3 : ","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"println(0.1 + 0.2 - 0.3)","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"5.551115123125783e-17","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"When summing many numbers, depnding on the order in which they are summed, floating-point approximation errors may aggregate more or less quickly. ","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"The default summation per-timestep in our example Toy_Tt_CuModel was a naive summation. The cumsum function used in the single-scale simulation to directly compute the TT_cu uses a pairwise summation method that provides approximation error on fewer digits compared to naive summation. Errors aggregate more slowly.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"In our simple example, using Float64 values, the difference wasn't significant enough to matter, but if you are writing a simulation over many timesteps or aggregating a value over many nodes, you may need to alter models to avoid numerical errors blowing up due to floating-point accuracy.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Depending on what value is being computed and the mathematical operations used, changes may range from applying a simple scale to a range of values, to significant refactoring.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/#Other-links-related-to-floating-point-numerical-concerns","page":"Floating-point considerations","title":"Other links related to floating-point numerical concerns","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Note that many of the examples in these blogposts discuss Float32 accuracy. Float64 values have several extra precision bits to work.","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"A series of blog posts on floating-point accuracy : https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ Floating-Point Visually Explained : https://fabiensanglard.net/floatingpointvisually_explained/ Examples of floating point problems: https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Relating specifically to floating-point sums:","category":"page"},{"location":"working_with_data/floating_point_accumulation_error/","page":"Floating-point considerations","title":"Floating-point considerations","text":"Pairwise summation: https://en.wikipedia.org/wiki/Pairwisesummation Kahan summation: https://en.wikipedia.org/wiki/Kahansummation_algorithm Taming Floating-Point Sums : https://orlp.net/blog/taming-float-sums/","category":"page"},{"location":"documentation_improvement/#Help-improve-our-documentation-!","page":"Improving our documentation","title":"Help improve our documentation !","text":"","category":"section"},{"location":"documentation_improvement/","page":"Improving our documentation","title":"Improving our documentation","text":"One goal for PlantSimEngine is to ensure testing ecophysiological hypotheses, or building plant simulations is as easy as can be for a wider range of people than previous frameworks.","category":"page"},{"location":"documentation_improvement/","page":"Improving our documentation","title":"Improving our documentation","text":"Good documentation is essential for that purpose.","category":"page"},{"location":"documentation_improvement/","page":"Improving our documentation","title":"Improving our documentation","text":"If parts of the documentation are unclear to you, you are very welcome to send a PR, an email, or a message (either on Github or on the FSPM Discourse) so that we can improve upon it.","category":"page"},{"location":"multiscale/multiscale_considerations/#Multi-scale-considerations","page":"Multiscale considerations","title":"Multi-scale considerations","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Pages = [\"multiscale_considerations.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"This page briefly details the subtle ways in which multi-scale simulations differ from prior single-scale simulations. The next few pages will showcase some of these subtleties with examples.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Declaring and running a multi-scale simulation follows the same general workflow as the single-scale version, but multi-scale simulations do have some differences : ","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"a simulation requires a Multi-scale Tree Graph (MTG) to run and operates on that graph\nwhen running, models are tied to a scale and only access local information\nmodels can run multiple times per timestep, \nthe ModelList is replaced by a slightly more complex model mapping to link models to the scale they will operate at.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"The simulation dependency graph will still be computed automatically and handle most couplings, meaning users don't need to specify the order of model execution once the extra code to declare the models is written. You will still need to declare hard dependencies, with extra considerations for multi-scale hard dependencies.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Multi-scale simulations also tend to require more extra ad hoc models to prepare some variables for some models.","category":"page"},{"location":"multiscale/multiscale_considerations/#Related-pages","page":"Multiscale considerations","title":"Related pages","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Other pages in the multiscale section describe :","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"How to write a direct conversion of a single-scale ModelList simulation to a multi-scale simulation and add a second scale to it: Converting a single-scale simulation to multi-scale, \nA more complex multi-scale version of the single-scale simulation showcasing different variable mappings between scales: Multi-scale variable mapping, \nA three-part tutorial describing how to build up a combination of models to simulate a growing toy plant: Writing a multiscale simulation,\nWays to handle situations where a variable ends up causing a cyclic dependency: Avoiding cyclic dependencies,\nMulti-scale specific coupling considerations and subtleties:Handling dependencies in a multiscale context","category":"page"},{"location":"multiscale/multiscale_considerations/#Multi-scale-tree-graphs","page":"Multiscale considerations","title":"Multi-scale tree graphs","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Functional-Structural Plant Models are often about simulating plant growth. A multi-scale simulation is implicitely expected to operate on a plant-like object, represented by a multi-scale tree graph.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"A multi-scale tree graph (MTG) object (see the Multi-scale Tree Graphs subsection for a quick description) is therefore required to run a multi-scale simulations. It can be a dummy MTG if the simulation doesn't actually affect it, but is nevertheless a required argument to the multi-scale run! function.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"All the multi-scale examples make use of the companion package MultiScaleTreeGraph.jl, which we therefore recommend for running your own multi-scale simulations.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"note: Note\nMulti-scale Tree Graphs make use of conflicting terminology with PlantSimEngine's concepts, which is discussed in Scale/symbol terminology ambiguity. If you are new to the concepts, make sure to read that section and keep note of it.","category":"page"},{"location":"multiscale/multiscale_considerations/#Models-run-once-per-organ-instance,-not-once-per-organ-level","page":"Multiscale considerations","title":"Models run once per organ instance, not once per organ level","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Some models, like the ones we've seen in single-scale simulations, work on a very simple model of a whole plant.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"More fine-grained models can be tied to a specific plant organ. ","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"For instance, a model computing a leaf's surface area depending on its age would operate at the \"leaf\" scale, and be called for every leaf at every timestep. On the other hand, a model computing the plant's total leaf area only needs to be run once per timestep, and can be run at the \"Plant\" scale.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"This is a major difference between a single-scale simulation and a multi-scale one. By default, any model in a single-scale simulation will only run once per timestep. However, in multi-scale, if a plant has several instances of an organ type -say it has a hundred leaves- then any model operating at the \"Leaf\" scale will by default run one hundred times per timestep, unless it is explicitely controlled by another model (which can happen in hard dependency configurations).","category":"page"},{"location":"multiscale/multiscale_considerations/#Mappings","page":"Multiscale considerations","title":"Mappings","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"When users define which models they use, PlantSimEngine cannot determine in advance which scale level they operate at. This is partly because the plant organs in an MTG do not have standardized names, and partly because some plant organs might not be part of the initial MTG, so parsing it isn't enough to infer what scales are used.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"The user therefore needs to indicate for a simulation's which models are related to which scale.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"A multi-scale mapping links models to the scale at which they operate, and is implemented as a Julia Dict, tying a scale, such as \"Leaf\" to models operating at that scale, such as \"LeafSurfaceAreaModel\". It is the equivalent of a ModelList in a single-scale simulation.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Multi-scale models can be similar models to the ones found in earlier sections, or, if they need to make use of variables at other scales, may need to be wrapped as part of a MultiScaleModel object. Many models are not tied to a particular scale, which means those models can be reused at different scales or in single-scale simulations.","category":"page"},{"location":"multiscale/multiscale_considerations/#The-simulation-operates-on-an-MTG","page":"Multiscale considerations","title":"The simulation operates on an MTG","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Unlike in single-scale simulations, which make use of a Status object to store the current state of every variable in a simulation, multi-scale simulations operate on a per-organ basis. ","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"This means every organ instance has its own Status, with scale-specific attributes.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"This has two important consequences in terms of running a simulation :","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"First, any scale absent from the MTG will not be run. If your MTG contains no leaves, then no model operating at the scale \"Leaf\" will be able to run until a \"Leaf\" organ is created and a node is added in the MTG. Otherwise, it has no MTG node to operate on. The only exceptions are hard dependency models which can be called from a different scale, since they can be called directly by a model on a node at a different existing scale, even if there is no node at their own scale.\nSecondly, models only have access to local organ information. The status argument in the run! function only contains variables at the model's scale, unless variables from other scales are mapped via a MultiScaleModel wrapping. ","category":"page"},{"location":"multiscale/multiscale_considerations/#The-run!-function's-signature","page":"Multiscale considerations","title":"The run! function's signature","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"The run! function differs slightly from its single-scale version. The current structure (excluding a couple of advanced/deprecated kwargs) is the following:","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"run!(mtg, mapping, meteo, constants, extra; nsteps, tracked_outputs)","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Instead of a ModelList, it takes an MTG and a mapping. The optional meteo and constants argument are identical to the single-scale version. The extra argument is now reserved and should not be used. A new nsteps keyword argument is available to restrict the simulation to a specified number of steps. ","category":"page"},{"location":"multiscale/multiscale_considerations/#Multi-scale-output-data-structure","page":"Multiscale considerations","title":"Multi-scale output data structure","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"The output structure, like the mapping, is a Julia Dict structure indexed by scale. In each scale, another Dict maps variables to their values per timestep, per node. This makes the structure a little bulkier and a little more verbose to inspect than in single-scale, but the general usage is similar. Multiscale Tree Graph nodes are also added to the output data, as a :node entry.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"To illustrate, here's an example output from part 3 of the Toy plant tutorial, zeroing in on a variable at the \"Root\" scale: Fixing bugs in the plant simulation:","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"julia> outs\n\nDict{String, Dict{Symbol, Vector}} with 5 entries:\n  \"Internode\" => Dict(:carbon_root_creation_consumed=>[[50.0, 50.0], [50.0, 50.0], [50.0, 50.0], [50.0, 50.0], [50.0, …\n  \"Root\"      => Dict(:carbon_root_creation_consumed=>[[50.0, 50.0], [50.0, 50.0, 50.0], [50.0, 50.0, 50.0, 50.0], [50…\n  \"Scene\"     => Dict(:TT_cu=>[[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0]  …  [2099.61], [20…\n  \"Plant\"     => Dict(:carbon_root_creation_consumed=>[[50.0], [50.0], [50.0], [50.0], [50.0], [50.0], [50.0], [50.0],…\n  \"Leaf\"      => Dict(:node=>Vector{Node{NodeMTG, Dict{Symbol, Any}}}[[+ 4: Leaf…\n\njulia> outs[\"Root\"]\nDict{Symbol, Vector} with 4 entries:\n  :carbon_root_creation_consumed => [[50.0, 50.0], [50.0, 50.0, 50.0], [50.0, 50.0, 50.0, 50.0], [50.0, 50.0, 50.0, 50…\n  :node                          => Vector{Node{NodeMTG, Dict{Symbol, Any}}}[[+ 9: Root…\n  :water_absorbed                => [[0.5, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0, 0.0], [1.1, 1.1, 1.1, 1.1, 0.0], [0.…\n  :root_water_assimilation       => [[1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.…\n\njulia> outs[\"Root\"][:carbon_root_creation_consumed]\n365-element Vector{Vector{Float64}}:\n [50.0, 50.0] # timestep 1: two root nodes\n [50.0, 50.0, 50.0]\n [50.0, 50.0, 50.0, 50.0]\n [50.0, 50.0, 50.0, 50.0, 50.0]\n [50.0, 50.0, 50.0, 50.0, 50.0, 50.0]\n [50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0] # timestep 6: 7 root nodes\n ⋮","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"As more roots get added in this simulation, the vectors expand to list the values of all the nodes for every variable for every timestep.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"warning: Warning\nCurrently, the :node entry only shallow copies nodes. The :node values at each scale for every timestep actually reflect the final state of the node, meaning attribute values may not correspond to the value at that timestep. You may need to output these values via a dedicated model to keep track of them properly. Also note that there currently is no way of removing nodes. Nodes corresponding to organs considered to be pruned/dead/aborted are still present in the output data structure.","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Multi-scale simulations, especially for plants which have thousands of leaves, internodes, root branches, buds and fruits, may compute huge amounts of data. Just like in single-scale simulations, it is possible to keep only variables whose values you want to track for every timestep, and filter the rest out, using the tracked_outputs keyword argument for the run! function. ","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Those tracked variables also need to be indexed by scale to avoid ambiguity: ","category":"page"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"outs = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"page"},{"location":"multiscale/multiscale_considerations/#Coupling-and-multi-scale-hard-dependencies","page":"Multiscale considerations","title":"Coupling and multi-scale hard dependencies","text":"","category":"section"},{"location":"multiscale/multiscale_considerations/","page":"Multiscale considerations","title":"Multiscale considerations","text":"Multi-scale brings new types of coupling: mappings are part of the approach used to handle variables used by models at different scales. A model can also have a hard dependency on another model that operates at another scale. This multi-scale-specific complexity is discussed in Handling dependencies in a multiscale context","category":"page"},{"location":"API/API_examples/#Example-models","page":"Example models","title":"Example models","text":"","category":"section"},{"location":"API/API_examples/","page":"Example models","title":"Example models","text":"PlantSimEngine provides example processes and models to users. They are available from a sub-module called Examples. To get access to these models in a working environment with PlantSimEngine, you can simply use this sub-module:","category":"page"},{"location":"API/API_examples/","page":"Example models","title":"Example models","text":"using PlantSimEngine.Examples","category":"page"},{"location":"API/API_examples/#List","page":"Example models","title":"List","text":"","category":"section"},{"location":"API/API_examples/","page":"Example models","title":"Example models","text":"Pages = [\"API_examples.md\"]","category":"page"},{"location":"API/API_examples/#Details","page":"Example models","title":"Details","text":"","category":"section"},{"location":"API/API_examples/","page":"Example models","title":"Example models","text":"Modules = [PlantSimEngine.Examples]\nPublic = true\nPrivate = true","category":"page"},{"location":"API/API_examples/#PlantSimEngine.Examples","page":"Example models","title":"PlantSimEngine.Examples","text":"A sub-module with example models.\n\nExamples used in the documentation for a set of multiscale models. The models can be found in the examples folder of the package, and are stored  in the following files:\n\nToyAssimModel.jl\nToyCDemandModel.jl\nToyCAllocationModel.jl\nToySoilModel.jl\n\nExamples\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nToyAssimModel()\n\n\n\n\n\n","category":"module"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_AllocationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_AllocationModel","text":"carbon_allocation process abstract model. \n\nAll models implemented to simulate the carbon_allocation process must be a subtype of this type, e.g.  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","text":"carbon_assimilation process abstract model. \n\nAll models implemented to simulate the carbon_assimilation process must be a subtype of this type, e.g.  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_BiomassModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_BiomassModel","text":"carbon_biomass process abstract model. \n\nAll models implemented to simulate the carbon_biomass process must be a subtype of this type, e.g.  struct MyCarbon_BiomassModel <: AbstractCarbon_BiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractCarbon_DemandModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractCarbon_DemandModel","text":"carbon_demand process abstract model. \n\nAll models implemented to simulate the carbon_demand process must be a subtype of this type, e.g.  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractDegreedaysModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractDegreedaysModel","text":"Degreedays process abstract model. \n\nAll models implemented to simulate the Degreedays process must be a subtype of this type, e.g.  struct MyDegreedaysModel <: AbstractDegreedaysModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractDegreedaysModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractGrowthModel","text":"growth process abstract model. \n\nAll models implemented to simulate the growth process must be a subtype of this type, e.g.  struct MyGrowthModel <: AbstractGrowthModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractGrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLai_DynamicModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLai_DynamicModel","text":"LAI_Dynamic process abstract model. \n\nAll models implemented to simulate the LAI_Dynamic process must be a subtype of this type, e.g.  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","text":"leaf_surface process abstract model. \n\nAll models implemented to simulate the leaf_surface process must be a subtype of this type, e.g.  struct MyLeaf_SurfaceModel <: AbstractLeaf_SurfaceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_SurfaceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLight_InterceptionModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLight_InterceptionModel","text":"light_interception process abstract model. \n\nAll models implemented to simulate the light_interception process must be a subtype of this type, e.g.  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractLight_PartitioningModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractLight_PartitioningModel","text":"light_partitioning process abstract model. \n\nAll models implemented to simulate the light_partitioning process must be a subtype of this type, e.g.  struct MyLight_PartitioningModel <: AbstractLight_PartitioningModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_PartitioningModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","text":"maintenance_respiration process abstract model. \n\nAll models implemented to simulate the maintenance_respiration process must be a subtype of this type, e.g.  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","text":"organ_emergence process abstract model. \n\nAll models implemented to simulate the organ_emergence process must be a subtype of this type, e.g.  struct MyOrgan_EmergenceModel <: AbstractOrgan_EmergenceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractOrgan_EmergenceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess1Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess1Model","text":"process1 process abstract model. \n\nAll models implemented to simulate the process1 process must be a subtype of this type, e.g.  struct MyProcess1Model <: AbstractProcess1Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess1Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess2Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess2Model","text":"process2 process abstract model. \n\nAll models implemented to simulate the process2 process must be a subtype of this type, e.g.  struct MyProcess2Model <: AbstractProcess2Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess2Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess3Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess3Model","text":"process3 process abstract model. \n\nAll models implemented to simulate the process3 process must be a subtype of this type, e.g.  struct MyProcess3Model <: AbstractProcess3Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess3Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess4Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess4Model","text":"process4 process abstract model. \n\nAll models implemented to simulate the process4 process must be a subtype of this type, e.g.  struct MyProcess4Model <: AbstractProcess4Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess4Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess5Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess5Model","text":"process5 process abstract model. \n\nAll models implemented to simulate the process5 process must be a subtype of this type, e.g.  struct MyProcess5Model <: AbstractProcess5Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess5Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess6Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess6Model","text":"process6 process abstract model. \n\nAll models implemented to simulate the process6 process must be a subtype of this type, e.g.  struct MyProcess6Model <: AbstractProcess6Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess6Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractProcess7Model","page":"Example models","title":"PlantSimEngine.Examples.AbstractProcess7Model","text":"process7 process abstract model. \n\nAll models implemented to simulate the process7 process must be a subtype of this type, e.g.  struct MyProcess7Model <: AbstractProcess7Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess7Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.AbstractSoil_WaterModel","page":"Example models","title":"PlantSimEngine.Examples.AbstractSoil_WaterModel","text":"soil_water process abstract model. \n\nAll models implemented to simulate the soil_water process must be a subtype of this type, e.g.  struct MySoil_WaterModel <: AbstractSoil_WaterModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Beer","page":"Example models","title":"PlantSimEngine.Examples.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nRequired inputs: LAI in m² m⁻². Required meteorology data: Ri_PAR_f, the incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹).\n\nOutput: aPPFD, the absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process1Model","page":"Example models","title":"PlantSimEngine.Examples.Process1Model","text":"Process1Model(a)\n\nA dummy model implementing a \"process1\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process2Model","page":"Example models","title":"PlantSimEngine.Examples.Process2Model","text":"Process2Model()\n\nA dummy model implementing a \"process2\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process3Model","page":"Example models","title":"PlantSimEngine.Examples.Process3Model","text":"Process3Model()\n\nA dummy model implementing a \"process3\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process4Model","page":"Example models","title":"PlantSimEngine.Examples.Process4Model","text":"Process4Model()\n\nA dummy model implementing a \"process4\" process for testing purposes. It computes the inputs needed for the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process5Model","page":"Example models","title":"PlantSimEngine.Examples.Process5Model","text":"Process5Model()\n\nA dummy model implementing a \"process5\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process6Model","page":"Example models","title":"PlantSimEngine.Examples.Process6Model","text":"Process6Model()\n\nA dummy model implementing a \"process6\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3, but also from process 7 that is itself independant.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.Process7Model","page":"Example models","title":"PlantSimEngine.Examples.Process7Model","text":"Process7Model()\n\nA dummy model implementing a \"process7\" process for testing purposes. It is independent (needs :var0 only as for Process4Model), but its outputs are used by Process6Model, so it is a soft-coupling.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyAssimGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.ToyAssimGrowthModel","text":"ToyAssimGrowthModel(Rm_factor, Rg_cost)\nToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\nRm_factor=0.5: the fraction of assimilation that goes into maintenance respiration\nRg_cost=1.2: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the assimilation, in gC m⁻² time-step⁻¹\nRm: the maintenance respiration, in gC m⁻² time-step⁻¹\nRg: the growth respiration, in gC m⁻² time-step⁻¹\nbiomass_increment: the daily biomass increment, in gC m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyAssimModel","page":"Example models","title":"PlantSimEngine.Examples.ToyAssimModel","text":"ToyAssimModel(LUE)\n\nComputes the assimilation of a plant (= photosynthesis).\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\nsoil_water_content: the soil water content, in %\n\nOutputs\n\ncarbon_assimilation: the assimilation or photosynthesis, also sometimes denoted A, in gC m⁻² time-step⁻¹\n\nDetails\n\nThe assimilation is computed as the product of the absorbed photosynthetic photon flux density (aPPFD) and the light use efficiency (LUE), so the units of the assimilation usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of aPPFD, e.g.  if aPPFD is in mol[PAR] plant⁻¹ time-step⁻¹, the assimilation will be in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCAllocationModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCAllocationModel","text":"ToyCAllocationModel()\n\nComputes the carbon allocation to each organ of a plant based on the plant total carbon offer and individual organ demand. This model should be used at the plant scale, because it first computes the carbon availaible for allocation as the minimum between the total demand  (sum of organs' demand) and total carbon offer (sum of organs' assimilation - total maintenance respiration), and then allocates the carbon relative  to each organ's demand.\n\nInputs\n\ncarbon_assimilation: a vector of the assimilation of all photosynthetic organs, usually in gC m⁻² time-step⁻¹\nRm: the maintenance respiration of the plant, usually in gC m⁻² time-step⁻¹\ncarbon_demand: a vector of the carbon demand of the organs, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the carbon assimilation, usually in gC m⁻² time-step⁻¹\n\nDetails\n\nThe units usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of the inputs, e.g. in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCBiomassModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCBiomassModel","text":"ToyCBiomassModel(construction_cost)\n\nComputes the carbon biomass of an organ based on the carbon allocation and construction cost.\n\nArguments\n\nconstruction_cost: the construction cost of the organ, usually in gC gC⁻¹. Should be understood as the amount of carbon needed to build 1g of carbon biomass.\n\nInputs\n\ncarbon_allocation: the carbon allocation to the organ for the time-step, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_biomass_increment: the increment of carbon biomass, usually in gC time-step⁻¹\ncarbon_biomass: the carbon biomass, usually in gC\ngrowth_respiration: the growth respiration, usually in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyCDemandModel","page":"Example models","title":"PlantSimEngine.Examples.ToyCDemandModel","text":"ToyCDemandModel(optimal_biomass, development_duration)\nToyCDemandModel(; optimal_biomass, development_duration)\n\nComputes the carbon demand of an organ depending on its biomass under optimal conditions and the duration of its development in degree days. The model assumes that the carbon demand is linear througout the duration of the development.\n\nArguments\n\noptimal_biomass: the biomass of the organ under optimal conditions, in gC\ndevelopment_duration: the duration of the development of the organ, in degree days\n\nInputs\n\nTT: the thermal time, in degree days\n\nOutputs\n\ncarbon_demand: the carbon demand, in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyDegreeDaysCumulModel","page":"Example models","title":"PlantSimEngine.Examples.ToyDegreeDaysCumulModel","text":"ToyDegreeDaysCumulModel(;init_TT=0.0, T_base=10.0, T_max=43.0)\n\nComputes the thermal time in degree days and cumulated degree-days based on the average daily temperature (T), the initial cumulated degree days, the base temperature below which there is no growth, and the maximum  temperature for growh.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyInternodeEmergence","page":"Example models","title":"PlantSimEngine.Examples.ToyInternodeEmergence","text":"ToyInternodeEmergence(;init_TT=0.0, TT_emergence = 300)\n\nComputes the organ emergence based on cumulated thermal time since last event.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLAIModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLAIModel","text":"ToyLAIModel(;max_lai=8.0, dd_incslope=800, inc_slope=110, dd_decslope=1500, dec_slope=20)\n\nComputes the Leaf Area Index (LAI) based on a sigmoid function of thermal time.\n\nArguments\n\nmax_lai: the maximum LAI value\ndd_incslope: the thermal time at which the LAI starts to increase\ninc_slope: the slope of the increase\ndd_decslope: the thermal time at which the LAI starts to decrease\ndec_slope: the slope of the decrease\n\nInputs\n\nTT_cu: the cumulated thermal time since the beginning of the simulation, usually in °C days\n\nOutputs\n\nLAI: the Leaf Area Index, usually in m² m⁻²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","text":"ToyLAIfromLeafAreaModel()\n\nComputes the Leaf Area Index (LAI) of the scene based on the plants leaf area.\n\nArguments\n\nscene_area: the area of the scene, usually in m²\n\nInputs\n\nsurface: a vector of plant leaf surfaces, usually in m²\n\nOutputs\n\nLAI: the Leaf Area Index of the scene, usually in m² m⁻²\ntotal_surface: the total surface of the plants, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLeafSurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLeafSurfaceModel","text":"ToyLeafSurfaceModel(SLA)\n\nComputes the individual leaf surface from its biomass using the SLA.\n\nArguments\n\nSLA: the specific leaf area, usually in m² gC⁻¹. Should be understood as the surface area of a leaf per unit of carbon biomass.\n\nValues typically range from 0.002 to 0.027 m² gC⁻¹.\n\nInputs\n\ncarbon_biomass: the carbon biomass of the leaf, usually in gC\n\nOutputs\n\nsurface: the leaf surface, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyLightPartitioningModel","page":"Example models","title":"PlantSimEngine.Examples.ToyLightPartitioningModel","text":"ToyLightPartitioningModel()\n\nComputes the light partitioning based on relative surface.\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density at the larger scale (e.g. scene), in mol[PAR] m⁻² time-step⁻¹ \n\nOutputs\n\naPPFD: the assimilation or photosynthesis, also sometimes denoted A, in gC time-step⁻¹\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyMaintenanceRespirationModel","page":"Example models","title":"PlantSimEngine.Examples.ToyMaintenanceRespirationModel","text":"RmQ10FixedN(Q10, Rm_base, T_ref, P_alive, nitrogen_content)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nRm_base: Base maintenance respiration (gC gDM⁻¹ time-step⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nnitrogen_content: nitrogen content of the organ (gN gC⁻¹)\n\nInputs\n\ncarbon_biomass: the carbon biomass of the organ in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","page":"Example models","title":"PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","text":"ToyPlantLeafSurfaceModel()\n\nComputes the leaf surface at plant scale by summing the individual leaf surfaces.\n\nInputs\n\nleaf_surfaces: a vector of leaf surfaces, usually in m²\n\nOutputs\n\nsurface: the leaf surface at plant scale, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyPlantRmModel","page":"Example models","title":"PlantSimEngine.Examples.ToyPlantRmModel","text":"ToyPlantRmModel()\n\nTotal plant maintenance respiration based on the sum of Rm_organs, the maintenance respiration of the organs.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC time-step⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToyRUEGrowthModel","page":"Example models","title":"PlantSimEngine.Examples.ToyRUEGrowthModel","text":"ToyRUEGrowthModel(efficiency)\n\nComputes the carbon biomass increment of a plant based on the radiation use efficiency principle.\n\nArguments\n\nefficiency: the radiation use efficiency, in gC[biomass] mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\nbiomass_increment: the daily biomass increment, in gC[biomass] m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC[biomass] m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.ToySoilWaterModel","page":"Example models","title":"PlantSimEngine.Examples.ToySoilWaterModel","text":"ToySoilWaterModel(values=[0.5])\n\nA toy model to compute the soil water content. The model simply take a random value in the values range using rand.\n\nOutputs\n\nsoil_water_content: the soil water content (%).\n\nArguments\n\nvalues: a range of soil_water_content values to sample from. Can be a vector of values [0.5,0.6] or a range 0.1:0.1:1.0. Default is [0.5].\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples/#PlantSimEngine.Examples.import_mtg_example-Tuple{}","page":"Example models","title":"PlantSimEngine.Examples.import_mtg_example","text":"import_mtg_example()\n\nReturns an example multiscale tree graph (MTG) with a scene, a soil, and a plant with two internodes and two leaves.\n\nExamples\n\njulia> using PlantSimEngine.Examples\n\njulia> import_mtg_example()\n/ 1: Scene\n├─ / 2: Soil\n└─ + 3: Plant\n   └─ / 4: Internode\n      ├─ + 5: Leaf\n      └─ < 6: Internode\n         └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples/#PlantSimEngine.fit-Tuple{Type{PlantSimEngine.Examples.Beer}, Any}","page":"Example models","title":"PlantSimEngine.fit","text":"fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n\nCompute the k parameter of the Beer-Lambert law from measurements.\n\nArguments\n\n::Type{Beer}: the model type\ndf: a DataFrame with the following columns:\naPPFD: the measured absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹\nLAI: the measured leaf area index in m² m⁻²\nRi_PAR_f: the measured incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹)\n\nExamples\n\nImport the example models defined in the Examples sub-module:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\n\nCreate a model list with a Beer model, and fit it to the data:\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples/#PlantSimEngine.run!","page":"Example models","title":"PlantSimEngine.run!","text":"run!(::Beer, object, meteo, constants=Constants(), extra=nothing)\n\nComputes the photosynthetic photon flux density (aPPFD, µmol m⁻² s⁻¹) absorbed by an  object using the incoming PAR radiation flux (Ri_PAR_f, W m⁻²) and the Beer-Lambert law of light extinction.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for LAI (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\nextra = nothing: extra arguments, not used here.\n\nExamples\n\nm = ModelList(Beer(0.5), status=(LAI=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_q=300.0)\n\nrun!(m, meteo)\n\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"multiscale/multiscale_cyclic/#Avoiding-cyclic-dependencies","page":"Handling cyclic dependencies","title":"Avoiding cyclic dependencies","text":"","category":"section"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"When defining a mapping between models and scales, it is important to avoid cyclic dependencies. A cyclic dependency occurs when a model at a given scale depends on a model at another scale that depends on the first model. Cyclic dependencies are bad because they lead to an infinite loop in the simulation (the dependency graph keeps cycling indefinitely).","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"PlantSimEngine will detect cyclic dependencies and raise an error if one is found. The error message indicates the models involved in the cycle, and the model that is causing the cycle will be highlighted in red.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"For example the following mapping will raise an error:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"details: Details\n<summary>Example mapping</summary>mapping_cyclic = Dict(\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n        Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6),\n    ),\n    \"Internode\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(TT=10.0, carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        ToyCBiomassModel(1.2),\n        Status(TT=10.0),\n    )\n)","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"Let's see what happens when we try to build the dependency graph for this mapping:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"julia> dep(mapping_cyclic)\nERROR: Cyclic dependency detected in the graph. Cycle:\n Plant: ToyPlantRmModel\n └ Leaf: ToyMaintenanceRespirationModel\n  └ Leaf: ToyCBiomassModel\n   └ Plant: ToyCAllocationModel\n    └ Plant: ToyPlantRmModel\n\n You can break the cycle using the `PreviousTimeStep` variable in the mapping.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"How can we interpret the message? We have a list of five models involved in the cycle. The first model is the one causing the cycle, and the others are the ones that depend on it. In this case, the ToyPlantRmModel is the one causing the cycle, and the others are inter-dependent. We can read this as follows:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"ToyPlantRmModel depends on ToyMaintenanceRespirationModel, the plant-scale respiration sums up all organs respiration;\nToyMaintenanceRespirationModel depends on ToyCBiomassModel, the organs respiration depends on the organs biomass;\nToyCBiomassModel depends on ToyCAllocationModel, the organs biomass depends on the organs carbon allocation;\nAnd finally ToyCAllocationModel depends on ToyPlantRmModel again, hence the cycle because the carbon allocation depends on the plant scale respiration.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"The models can not be ordered in a way that satisfies all dependencies, so the cycle can not be broken. To solve this issue, we need to re-think how models are mapped together, and break the cycle.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"There are several ways to break a cyclic dependency:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"Merge models: If two models depend on each other because they need e.g. recursive computations, they can be merged into a third model that handles the computation and takes the two models as hard dependencies. Hard dependencies are models that are explicitly called by another model and do not participate on the building of the dependency graph.\nChange models: Of course models can be interchanged to avoid cyclic dependencies, but this is not really a solution, it is more a workaround.\nPreviousTimeStep: We can break the dependency graph by defining some variables as taken from the previous time step. A very well known example is the computation of the light interception by a plant that depends on the leaf area, which is usually the result of a model that also depends on the light interception. The cyclic dependency is usually broken by using the leaf area from the previous time step in the interception model, which is a good approximation for most cases.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"We can fix our previous mapping by computing the organs respiration using the carbon biomass from the previous time step instead. Let's see how to fix the cyclic dependency in our mapping (look at the leaf and internode scales):","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"details: Details\nmapping_nocyclic = Dict(\n        \"Plant\" => (\n            MultiScaleModel(\n                model=ToyCAllocationModel(),\n                mapping=[\n                    :carbon_demand => [\"Leaf\", \"Internode\"],\n                    :carbon_allocation => [\"Leaf\", \"Internode\"]\n                ],\n            ),\n            MultiScaleModel(\n                model=ToyPlantRmModel(),\n                mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n            ),\n            Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6, carbon_assimilation=5.0),\n        ),\n        \"Internode\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (first break)\n            ),\n            Status(TT=10.0, carbon_biomass=1.0),\n        ),\n        \"Leaf\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (second break)\n            ),\n            ToyCBiomassModel(1.2),\n            Status(TT=10.0),\n        )\n    );\nnothing # hide","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"The ToyMaintenanceRespirationModel models are now defined as MultiScaleModel, and the carbon_biomass variable is wrapped in a PreviousTimeStep structure. This structure tells PlantSimEngine to take the value of the variable from the previous time step, breaking the cyclic dependency.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"note: Note\nPreviousTimeStep tells PlantSimEngine to take the value of the previous time step for the variable it wraps, or the value at initialization for the first time step. The value at initialization is the one provided by default in the models inputs, but is usually provided in the Status structure to override this default. A PreviousTimeStep is used to wrap the input variable of a model, with or without a mapping to another scale e.g. PreviousTimeStep(:carbon_biomass) => \"Leaf\".","category":"page"},{"location":"prerequisites/julia_basics/#Getting-started-with-Julia","page":"Julia language basics","title":"Getting started with Julia","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"PlantSimEngine (as well as its related packages) is written in Julia. The reasons why Julia was chosen are briefly discussed here : The choice of using Julia.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Julia is a language that is gaining traction, but it isn't the most widely used in research and data science. ","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Many elements will be familiar to those with an R, Python or Matlab background, but there are some noteworthy differences, and if you are new to the language, there will be a few hurdles you might have to overcome to be comfortable using the language.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"This page is here to list to the parts of Julia that are most relevant regarding usage of PlantSimEngine, and point to resources that can help you grasp those basics.","category":"page"},{"location":"prerequisites/julia_basics/#New-to-programming","page":"Julia language basics","title":"New to programming","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"It is not meant as a full-fledged from-scratch Julia tutorial. If you are completely new to programming, you may wish to check some other resources first, such as ones found here. The video course Julia Programming for Nervous Beginners is tailored for people with no programming experience.","category":"page"},{"location":"prerequisites/julia_basics/#Installing-packages-and-setting-up-and-environment","page":"Julia language basics","title":"Installing packages and setting up and environment","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"For PlantSimEngine, you can check our documentation page on the topic: Installing and running PlantSimEngine","category":"page"},{"location":"prerequisites/julia_basics/#Cheatsheets","page":"Julia language basics","title":"Cheatsheets","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"You can also find a few cheatsheets here as well as a short introductory notebook along with its install instructions.","category":"page"},{"location":"prerequisites/julia_basics/#Troubleshooting","page":"Julia language basics","title":"Troubleshooting","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"There is a documentation page showcasing some of the common errors than can occur when using PlantSimEngine, which may be worth checking if you are encountering issues: Troubleshooting error messages.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"For more Julia learning-related difficulties, you will find quick responses on the Discourse forum: https://discourse.julialang.org.","category":"page"},{"location":"prerequisites/julia_basics/#Noteworthy-differences-with-other-languages:","page":"Julia language basics","title":"Noteworthy differences with other languages:","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"If you wish to compare Julia to a specific language, the noteworthy differences section will provide you with a quick overview of the differences.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"(Array indexing starts at 1, for example)","category":"page"},{"location":"prerequisites/julia_basics/#Essential-Julia-concepts-for-PlantSimEngine","page":"Julia language basics","title":"Essential Julia concepts for PlantSimEngine","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Here's a list of the main aspects of the Julia language required (beyond package management) to understand how to use PlantSimEngine to its potential:","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Standard notions and constructs:","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Standard concepts of a variable, arrays, functions, function arguments\nThe typing system and custom types\nDictionaries and NamedTuple objects are used throughout the codebase","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"The Julia manual goes more in-depth than lighter introductions to some of these topics, so might be more useful as a reference than a starting point. You might find other guides or courses, such as https://scls.gitbooks.io/ljthw/content/_chapters/07-ex4.html, or the first section in https://julia.quantecon.org/intro.html, chapters 0-4 and 7 of the Learn Julia the Hard Way draft or the interactive Mathigon course.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Also of importance:","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Keyword arguments (kwargs) are present in many API functions\nType promotion, splatting, broadcasting, and comprehensions are also very useful (but not compulsory to get started)","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Many of these are also briefly presented in this Julia Data Science guide, which also happens to focus on the DataFrames.jl package.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Understanding more about methods, parametric types and the typing system is usually worthwhile, when working with Julia packages.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"TODO point to Rémi's videos ? Other videos ? TODO extra concepts useful for developers ?","category":"page"},{"location":"step_by_step/implement_a_model/#model_implementation_page","page":"Implementing a model","title":"Implementing a model","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"using PlantSimEngine\n@process \"light_interception\" verbose = false\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For your own simulations, you might want to move beyond simple usage at some point and implement your own models. In this page, we'll go through the required steps for writing a new model. The detailed version is tailored for people less familiar with programming.","category":"page"},{"location":"step_by_step/implement_a_model/#Quick-version","page":"Implementing a model","title":"Quick version","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare a new process : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare your model struct, and its parameters : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare the inputs_ and outputs_ methods for that model (note the '_', these methods are distinct from inputs and outputs)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Write the run! function that operates on a single timestep : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Determine if parallelization is possible, and which traits to declare :","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"And that is all you need to get going, for this example with a single parameter and no interdependencies. ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The @process macro does some boilerplate work described here","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Some extra utility functions can also be interesting to implement to make users' lives simpler. See the Model implementation additional notes page for details. If your custom model needs to handle more complex couplings than the simple input/output described in this example, check out the Coupling more complex models page.","category":"page"},{"location":"step_by_step/implement_a_model/#Detailed-version","page":"Implementing a model","title":"Detailed version","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The model we'll (re)implement is available as an example model from the Examples sub-module. You can access the script from here: examples/Beer.jl. It is also available in the PlantBioPhysics.jl package.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"You can import the model and PlantSimEngine's other example models into your environment with using:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"step_by_step/implement_a_model/#Other-examples","page":"Implementing a model","title":"Other examples","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine's other toy models can be found in the examples folder.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For other examples, you can look at the code in PlantBiophysics.jl, where you will find e.g. a photosynthesis model, with the implementation of the FvCB model in src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"step_by_step/implement_a_model/#Requirements","page":"Implementing a model","title":"Requirements","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If you have a look at example models, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"step_by_step/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Implementing a model","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"step_by_step/implement_a_model/#The-process","page":"Implementing a model","title":"The process","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We start by declaring the light interception process at l.7 using @process: ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"See Implementing a new process for more details on how that works and how to use the process.","category":"page"},{"location":"step_by_step/implement_a_model/#The-structure","page":"Implementing a model","title":"The structure","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"hold the parameter values\ndispatch to the right run! method when calling it","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The structure of the model (or type) is defined as follows:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The first line defines the name of the model (Beer). It is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The Beer structure is defined as a subtype of AbstractLight_InterceptionModel indicating what kind of process the model simulates. The AbstractLight_InterceptionModel type is automatically created when defining the process \"light_interception\".","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We can therefore infer from the declaration that Beer is a model to simulate the light interception process.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Then come the parameters names, and their types. ","category":"page"},{"location":"step_by_step/implement_a_model/#User-types-and-parametric-types","page":"Implementing a model","title":"User types and parametric types","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"There is a little Julia specificity here, to enable the user to pass their own types to the simulation.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Beer is a parameterized struct, indicated by the {T} annotation\nWe indicate the k parameter is of type T by adding ::T after the name.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The T is an arbitrary letter here. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct CustomModel{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Parameterized types are practical because they let the user choose the type of the parameters, and potentially change them at runtime. For example a user could use the Particles type from MonteCarloMeasurements.jl for automatic uncertainty propagation throughout the simulation. We refer you to the Parametric types subsection of the Model implementation additional notes page for more information on parametric types.","category":"page"},{"location":"step_by_step/implement_a_model/#Inputs-and-outputs","page":"Implementing a model","title":"Inputs and outputs","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"When implementing a new model, it is necessary to declare what variables will be required, whether provided as an input to our model or computed for every timestep as an output. Input variables will either be initialized by the user in a Status object, or provided by another model. Output variables may be global simulation outputs and/or used by other models.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"In our case, the Beer model, computing light interception, has one input variable and one output variable:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Inputs: :LAI, the leaf area index (m² m⁻²)\nOutputs: :aPPFD, the photosynthetic photon flux density (μmol m⁻² s⁻¹)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We declare these inputs/outputs by adding a method for the inputs and outputs functions. These functions take the type of the model as argument, and return a NamedTuple with the names of the variables as keys, and their default values as values:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"These functions are internal, and end with an \"_\". Users instead use inputs and outputs to query model variables.","category":"page"},{"location":"step_by_step/implement_a_model/#The-run!-method","page":"Implementing a model","title":"The run! method","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"When running a simulation with run!, each model is run in turn at every timestep, following whatever order was deduced from the ModelList definition and Status. Each model also has its run! method for that purpose that update the simulation's current state, with a slightly different signature. The function takes six arguments:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function run!(::Beer, models, status, meteo, constants, extras)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"the model's type\nmodels: a ModelList object, which contains all the models of the simulation\nstatus: a Status object, which contains the current values (i.e. state) of the variables for one time-step (e.g. the value of the plant LAI at time t)\nmeteo: (usually) an Atmosphere object, or a row of the meteorological data, which contains the current values of the meteorological variables for one time-step (e.g. the value of the PAR at time t)\nconstants: a Constants object, or a NamedTuple, which contains the values of the constants for the simulation (e.g. the value of the Stefan-Boltzmann constant, unit-conversion constants...)\nextras: any other object you want to pass to your model, mostly for advanced usage, not detailed here","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"A typical run! function can therefore make use of simulation constants, input/output variables accessible through the [Status](@ref object, or weather data. ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Here is the run! implementation of the light interception for a ModelList component models. Note that the input and output variable are accessed through the status argument :","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"step_by_step/implement_a_model/#Additional-notes","page":"Implementing a model","title":"Additional notes","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To use this model, users will have to make sure that the variables for that model are defined in the Status object, the meteorology, and the Constants object.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"!!! Note     Status objects contain the current state of the simulation. It is not, by default, possible to make use of earlier variable states, unless a custom model is written for that purpose.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Model parameters are available from the ModelList that is passed via the models argument. Index by the process name, then the parameter name. For example, the k parameter of the Beer model is found in models.light_interception.k.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"warning: Warning\nYou need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_. The troubleshooting subsection Implementing a model: forgetting to import or prefix functions showcases output errors that can occur when you forget to prefix.","category":"page"},{"location":"step_by_step/implement_a_model/#Parallelization-traits","page":"Implementing a model","title":"Parallelization traits","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (i.e. objects) and/or time (i.e. time-steps).","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"By default, all models are assumed to be not parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For example, if we want to add the trait for parallelization over objects to our Beer model, we would do:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"And if we want to add the trait for parallelization over time-steps to our Beer model, we would do:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"note: Note\nA model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"OK that's it! We now a full new model implementation for the light interception process! Other models might be more complex in terms of what computations they do, or how they couple with other models, but the approach remains the same.","category":"page"},{"location":"step_by_step/implement_a_model/#Dependencies","page":"Implementing a model","title":"Dependencies","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To do so, we can add a method to the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"You can read more about hard dependencies in Coupling more complex models.","category":"page"},{"location":"step_by_step/model_switching/#Model-switching","page":"Model Switching","title":"Model switching","text":"","category":"section"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine, PlantMeteo, CSV, DataFrames\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n \nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models, meteo_day)\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models2, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"One of the main objective of PlantSimEngine is allowing users to switch between model implementations for a given process without making any change to the PlantSimEngine codebase.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"The package was designed around this idea to make easy changes easy and efficient. Switch models in the ModelList, and call the run! function again. No other changes are required if no new variables are introduced.","category":"page"},{"location":"step_by_step/model_switching/#A-first-simulation-as-a-starting-point","page":"Model Switching","title":"A first simulation as a starting point","text":"","category":"section"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Let's create a ModelList with several models from the example scripts in the examples folder:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Importing the models from the scripts:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Coupling the models in a ModelList:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"models = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can the simulation by calling the run! function with meteorology data. Here we use an example data set:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can now run the simulation:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"output_initial = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/#Switching-one-model-in-the-simulation","page":"Model Switching","title":"Switching one model in the simulation","text":"","category":"section"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Now what if we want to switch the model that computes growth ? We can do this by simply replacing the model in the ModelList, and PlantSimEngine will automatically update the dependency graph, and adapt the simulation to the new model.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Let's switch ToyRUEGrowthModel with ToyAssimGrowthModel:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"models2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(), # This was `ToyRUEGrowthModel(0.2)` before\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"ToyAssimGrowthModel is a little bit more complex than ToyRUEGrowthModel](@ref), as it also computes the maintenance and growth respiration of the plant, so it has more parameters (we use the default values here). ","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can run a new simulation and see that the simulation's results are different from the previous simulation:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"output_updated = run!(models2, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"And that's it! We can switch between models without changing the code, and without having to recompute the dependency graph manually. This is a very powerful feature of PlantSimEngine!💪","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nThis was a very standard but straightforward example. Sometimes other models will require to add other models to the ModelList. For example ToyAssimGrowthModel could have required a maintenance respiration model. In this case PlantSimEngine will indicate what kind of model is required for the simulation.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nIn our example we replaced what we call a soft-dependency coupling, but the same principle applies to hard-dependencies. Hard and Soft dependencies are concepts related to model coupling, and are discussed in more detail in Standard model coupling and Coupling more complex models.","category":"page"},{"location":"multiscale/multiscale/#Multi-scale-variable-mapping","page":"More variable mapping examples","title":"Multi-scale variable mapping","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The previous page showed how to convert a single-scale simulation to multi-scale.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"This page provides another example showcasing the nuances in variable mapping, with a more complex fully multiscale version of a prior simulation. The models will all be taken form the examples folder.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Pages = [\"multiscale.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale/#Starting-with-a-single-model-mapping","page":"More variable mapping examples","title":"Starting with a single-model mapping","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Let's import the PlantSimEngine package and all the example models we will use in this tutorial:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"using PlantSimEngine\nusing PlantSimEngine.Examples # Import some example models","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Let's create a simple mapping with only one initial model, the carbon assimilation process ToyAssimModel, which will operate on leaves. It resembles the ToyAssimGrowth model used in the single-scale simulation Model switching subsection.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Our mapping between scale and model is therefore:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"mapping = Dict(\"Leaf\" => ToyAssimModel())","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Just like in single-scale simulations, we can call to_initialize to check whether variables need to be initialised. It will this time index by scale:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"In this example, the ToyAssimModel needs :aPPFD and :soil_water_content as inputs, which aren't initialised in our mapping.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The initialization values for the variables can be passed along via a Status object:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"mapping = Dict(\n    \"Leaf\" => (\n        ToyAssimModel(),\n        Status(aPPFD=1300.0, soil_water_content=0.5),\n    ),\n)","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"If we call to_initialize on this new mapping, it returns an empty dictionary, meaning the mapping is valid, and we can start the simulation:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/#Multiscale-mapping-between-models-and-scales","page":"More variable mapping examples","title":"Multiscale mapping between models and scales","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The soil_water_content variable was provided via the mapping. No model affects it, so it is constant in the above example. We could instead provide a model that computes it based on weather data, and/or a more realistic physical process. ","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"It also makes sense to have that model operate at a different scale than the \"Leaf\" scale. There is a dummy soil model called ToySoilModel in the examples folder. Let's put it at a new \"Soil\" scale level.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"ToyAssimModel is now makes use of the soil_water_content variable from the \"Soil\" scale, instead of at its own scale via the Status initialization. We therefore need to map soil_water_content from the \"Soil\" to the \"Leaf\" scale by wrapping ToyAssimModel in a MultiScaleModel:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"mapping = Dict(\n    \"Soil\" => ToySoilWaterModel(),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\" => :soil_water_content,],\n        ),\n        Status(aPPFD=1300.0),        \n    ),\n);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"In this example, we map the soil_water_content variable at scale \"Leaf\" to the soil_water_content variable at the \"Soil\" scale. If the name of the variable is the same between both scales, we can omit the variable name at the origin scale, e.g. [:soil_water_content => \"Soil\"].","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The variable aPPFD is still provided in the Status type as a constant value.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"We can check again if the mapping is valid by calling to_initialize:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Once again, to_initialize returns an empty dictionary, meaning the mapping is valid.","category":"page"},{"location":"multiscale/multiscale/#A-more-elaborate-multiscale-model-mapping","page":"More variable mapping examples","title":"A more elaborate multiscale model mapping","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Let's now expand this mapping, to showcase other ways in which variables can be mapped from one scale to another. We'll keep the first two models, and add several more to simulate a couple of other processes within our plant.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\", :aPPFD => \"Plant\"],\n        ),\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=0.5),\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"This mapping might seem a little more daunting than previous examples, but several models should be recognizable in passing. In fact, you can consider this mapping to be an enhanced and more complex multi-scale version of a previous single-scale example, the coupling between photosynthesis model, a LAI model and a carbon biomass increment model, used in the Model switching subsection.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"models2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The multi-scale models simulate carbon capture via photosynthesis and carbon allocation for the plant organs' maintenance respiration and development.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The LAI and photosynthesis models are the same as in the ModelList example. The ToyDegreeDaysCumulModel provides the Cumulative Thermal Time to the plant. ","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The newly introduced models have the following dynamic : ","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Carbon allocation is determined (ToyCAllocationModel) for the different organs of the plant (\"Leaf\" and \"Internode\") from the assimilation at the \"Leaf\" scale (i.e. the offer) and their carbon demand (ToyCDemandModel). The \"Soil\" scale is used to compute the soil water content (ToySoilWaterModel](@ref)), which is needed to calculate the assimilation at the \"Leaf\" scale (ToyAssimModel). Also note that maintenance respiration at computed at the \"Leaf\" and \"Internode\" scales (ToyMaintenanceRespirationModel), and aggregated to compute the total maintenance respiration at the \"Plant\" scale (ToyPlantRmModel). ","category":"page"},{"location":"multiscale/multiscale/#Different-possible-variable-mappings","page":"More variable mapping examples","title":"Different possible variable mappings","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"The above mapping showcases the different ways to define how the variables are mapped in a MultiScaleModel :","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":" mapped_variables=[:TT_cu => \"Scene\",],","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"At the \"Plant\" scale, the TTcu variable is mapped as a scalar from the \"Scene\" scale. There is only a single \"Scene\" node in the MTG, and only a single \"TTcu\" value per timestep for the simulation.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":":carbon_allocation => [\"Leaf\"]","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"On the other hand, we have :carbon_allocation => [\"Leaf\"] at the plant scale for ToyCAllocationModel. The carbon_assimilation variable is mapped as a vector: there are multiple \"Leaf\" nodes, but only one \"Plant\" node, which aggregrates the value over every single leaf. This gives us a 'many-to-one' vector mapping, and in the run! functions for models at that scale carbon_allocation will be available in the status as a vector.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":":carbon_allocation => [\"Leaf\", \"Internode\"]","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"A third type of the mapping would be :carbon_allocation => [\"Leaf\", \"Internode\"], which provides values for a variable from several other scales simultaneously. In this case, the values are also available as a vector in the carbon_assimilation variable of the status inside the model, sorted in the same order as nodes are traversed in the graph.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":":Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Finally, to map to a specific variable name at the target scale, e.g. :Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]. This syntax is useful when the variable name is different between scales, and we want to map to a specific variable name at the target scale. In this example, the variable Rm_organs at plant scale takes its values (is mapped) from the variable Rm at the \"Leaf\" and \"Internode\" scales.","category":"page"},{"location":"multiscale/multiscale/#Running-a-simulation","page":"More variable mapping examples","title":"Running a simulation","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Now that we have a valid mapping, we can run a simulation. Running a multiscale simulation requires a plant graph and the definition of the output variables we want dynamically for each scale.","category":"page"},{"location":"multiscale/multiscale/#Plant-graph","page":"More variable mapping examples","title":"Plant graph","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"We can import an example multi-scale tree graph like so:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"mtg = import_mtg_example()","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"note: Note\nYou can use import_mtg_example only if you previously imported the Examples sub-module of PlantSimEngine, i.e. using PlantSimEngine.Examples.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"This graph has a root node that defines a scene, then a soil, and a plant with two internodes and two leaves.","category":"page"},{"location":"multiscale/multiscale/#Output-variables","page":"More variable mapping examples","title":"Output variables","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"For long simulations on plants with many organs, the output data can be very significant. It's possible to restrict the output variables that are tracked for the whole simulation to a subset of all the variables:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"outs = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"This dictionary can be passed to the simulation via the optional tracked_outputs keyword argument to the run! function (see the next part). If no dictionary is provided, every variable will be tracked.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"These variables will be available in the output returned by run!, with a value for each time step. The corresponding timestep and node in the MTG are also returned. ","category":"page"},{"location":"multiscale/multiscale/#Meteorological-data","page":"More variable mapping examples","title":"Meteorological data","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"As for mono-scale models, we need to provide meteorological data to run a simulation. We can use the PlantMeteo package to generate some dummy data for two time steps:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f = 200.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f = 180.0)\n]\n)","category":"page"},{"location":"multiscale/multiscale/#Simulation","page":"More variable mapping examples","title":"Simulation","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Let's make a simulation using the graph and outputs we just defined:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"outputs_sim = run!(mtg, mapping, meteo, tracked_outputs = outs);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"And that's it! We can now access the outputs for each scale as a dictionary of vectors of values per variable and scale.","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"Or as a DataFrame using the DataFrames package:","category":"page"},{"location":"multiscale/multiscale/","page":"More variable mapping examples","title":"More variable mapping examples","text":"using DataFrames\nconvert_outputs(outputs_sim, DataFrame)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Quick-examples","page":"Quick examples","title":"Quick examples","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"This page is meant for people who have set up their environment and just want to copy-paste an example or two, see what the REPL returns and start tinkering. ","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"If you are less comfortable with Julia, or need to set up an environment first, see this page : Getting started with Julia. If you wish for a more detailed rundown of the examples, you can instead have a look at the step by step section, which will go into more detail.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"These examples are all for single-scale simulations. For multi-scale modelling tutorials and examples, refer to [this section][#multiscale]","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"You can find the implementation for all the example models, as well as other toy models in the examples folder.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"Pages = [\"quick_and_dirty_examples.md\"]\nDepth = 2","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Example-with-a-single-light-interception-model-and-a-single-weather-timestep","page":"Quick examples","title":"Example with a single light interception model and a single weather timestep","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout = run!(leaf, meteo)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-model-with-a-Leaf-Area-Index-model","page":"Quick examples","title":"Coupling the light interception model with a Leaf Area Index model","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"The weather data in this example contains data over 365 days, meaning the simulation will have as many timesteps.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-and-Leaf-Area-Index-models-with-a-biomass-increment-model","page":"Quick examples","title":"Coupling the light interception and Leaf Area Index models with a biomass increment model","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Example-using-PlantBioPhysics","page":"Quick examples","title":"Example using PlantBioPhysics","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"A companion package, PlantBioPhysics, uses PlantSimEngine, and contains other models used in ecophysiological simulations.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"You can have a look at its documentation here","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"Several example simulations are provided there. Here's one taken from this page : ","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantBiophysics, PlantSimEngine\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        Monteith(),\n        Fvcb(),\n        Medlyn(0.03, 12.0),\n        status = (Ra_SW_f = 13.747, sky_fraction = 1.0, aPPFD = 1500.0, d = 0.03)\n    )\n\nout = run!(leaf,meteo)","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Tips-and-workarounds","page":"Tips and Workarounds","title":"Tips and workarounds","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#PlantSimEngine-is-actively-being-developed","page":"Tips and Workarounds","title":"PlantSimEngine is actively being developed","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"PlantSimEngine, despite the somewhat abstract codebase and generic simulation ambitions, is quite grounded in reality. There IS a desire to accomodate for a wide range of possible simulations, without constraining the user too much, but most features are developed on an as-needed basis, and grow out of necessity, partly from the requirements of an increasingly complex and refined implementation of an oil palm model, XPalm.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Since the oil palm model is actively being developed, and some features aren't ready in PlantSimEngine, or require a lot of rewriting that we're not certain would be worth it (especially if it ends up constraining the codebase or what the user can do), some workarounds and shortcuts are occasionally used to circumvent a limitation. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"There are also a couple of features that are quick hacks or that are meant for quick and dirty prototyping, not for production. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"We'll list a few of them here, and will likely add some entry in the future listing some built-in limitations or implicit expectations of the package.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Pages = [\"tips_and_workarounds.md\"]\nDepth = 2","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Making-use-of-past-states-in-multi-scale-simulations","page":"Tips and Workarounds","title":"Making use of past states in multi-scale simulations","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It is possible to make use of the value of a variable in the past simulation timestep via the PreviousTimeStep mechanism in the mapping API (In fact, as mentioned elsewhere, it is the default way to break undesirable cyclic dependencies that can come up when coupling models, see : Avoiding cyclic dependencies).","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"However, it is not possible to go beyond that through the mapping API. Something like PreviousTimeStep(PreviousTimeStep(PreviousTimeStep(:carbon_biomass))) is not supported. Don't do that.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One way to access prior variable states is simply to write an ad hoc model that stores a few values into an array or however many variables you might need, which you can then update every timestep and feed into other models that might need it.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Having-a-variable-simultaneously-as-input-and-output-of-a-model","page":"Tips and Workarounds","title":"Having a variable simultaneously as input and output of a model","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One current limitation of PlantSimEngine that can be occasionally awkward is that using the same variable name as input and output in a single model is unsupported. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"(On a related note : it is not possible to have two variables with the same name in the same scale. They are considered as the same variable.)","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"The reason being that it is usually impossible to automatically determine how the coupling is supposed to work out, when other dependencies latch onto such a model. The user would have to explicitely declare some order of simulation between several models, and some amount of programmer work would also be necessary to implement that extra API feature into PlantSimEngine.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"We haven't found an approach that was fully satisfactory from both a code simplicity and an API convenience POV. Especially when prototyping and adding in new models, as that might require redeclaring the simulation order for those specific variables.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"There are two workarounds : ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One possibly awkward approach is to rename one of the variables. It is not ideal, of course, as it means you might not be able to use a predefined model 'out of the box', but it does not have any of the tradeoffs and constraints mentioned above.\nIn many other situations one can work with what PlantSimEngine already provides.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"For example, one model in XPalm.jl handles leaf pruning, affecting biomass. A straightforward implementation would be to have a leaf_biomass variable as both input and output. The workaround is to instead output a variable leaf_biomass_pruning_loss and to have that as input in the next timestep to compute the new leaf biomass.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Part 3 of the Toy Plant tutorial does something similar for its carbon stock. The carbon_stock variable indicates how much carbon is available for root and internode growth, but instead of updating it and passing it along after the root growth decision model decided whether or not roots should be added, that model computes a carbon_stock_updated_after_roots which is then used by the internode growth model. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"This change in design avoids model order ambiguity and also improves readability, and makes sense in terms of PlantSimEngine's philosophy.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#multiscale_vector","page":"Tips and Workarounds","title":"Multiscale : passing in a vector in a mapping status at a specific scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"note: Note\nThis section is a little more advanced and not recommended for beginners","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"You may have noticed that sometimes a vector (1-dimensional array) variable is passed into the status component of a ModelList in documentation examples (An example here with cumulative thermal time : Model switching).","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"This is practical for simple simulations, or when quickly prototyping, to avoid having to write a model specifically for it. Whatever models make use of that variable are provided with one element corresponding to the current timestep every iteration.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"In multi-scale simulations, this feature is also supported, though not part of the main API. The way outputs and statuses work is a little different, so that little convenience feature is not as straightforward. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It is more brittle, makes use of not-recommended Julia metaprogramming features (eval()), fiddles with global variables, might not work outside of a REPL environment and is not tested for more complex interactions, so it may interact badly with variables that are mapped to different scales or in bizarre dependency couplings.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Due to, uh, implementation quirks, the way to use this is as follows : ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Call the function replace_mapping_status_vectors_with_generated_models(mapping_with_vectors_in_status, timestep_model_organ_level, nsteps)on your mapping.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It will parse your mapping, generate custom models to store and feed the vector values each timestep, and return the new mapping you can then use for your simulation. It also slips in a couple of internal models that provide the timestep index to these models (so note that symbols :current_timestep and :next_timestep will be declared for that mapping). You can decide which scale/organ level you want those models to be in via the timestep_model_organ_levelparameter. nsteps is used as a sanity check, and expects you to provide the amount of simulation timesteps.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"warning: Warning\nOnly subtypes of AbstractVector present in statuses will be affected. In some cases, meteo values might need a small conversion. For instance : meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18) status(TT_cu=cumsum(meteo_day.TT),)cumsum(meteoday.TT) actually returns a CSV.SentinelArray.ChainedVectors{T, Vector{T}}, which is not a subtype of AbstractVector.  Replacing it with Vector(cumsum(meteoday.TT)) will provide an adequate type.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Here's an example usage, fixing the first attempt at Converting a single-scale simulation to multi-scale :","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo, CSV, DataFrames\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Direct translation of the single-scale simulation\nmapping_pseudo_multiscale = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 0),)\n\n# will generate an error as vectors can't be directly passed into a Status in multi-scale simulations\n#out_pseudo_multiscale_error = run!(mtg, mapping_pseudo_multiscale, meteo_day)\n\nmapping_pseudo_multiscale_adjusted = PlantSimEngine.replace_mapping_status_vectors_with_generated_models(mapping_pseudo_multiscale, \"Plant\", PlantSimEngine.get_nsteps(meteo_day))\n\nout_pseudo_multiscale_successful = run!(mtg, mapping_pseudo_multiscale_adjusted, meteo_day)\n","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"This feature is likely to break in simulations that make use of planned future features (such as mixing models with different timesteps), without guarantee of a fix on a short notice. Again, bear in mind it is mostly a convenient shortcut for prototyping, when doing multi-scale simulations.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"TODO workaround status initialisation bug ?","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Cyclic-dependencies-in-single-scale-simulations","page":"Tips and Workarounds","title":"Cyclic dependencies in single-scale simulations","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Cyclic dependencies can happen in single-scale simulations, but the PreviousTimestep feature currently isn't available. Hard dependencies are one way to deal with them, creating a multi-scale simulation with a single effective scale is also an option.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Installing-and-running-PlantSimEngine","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Pages = [\"installing_plantsimengine.md\"]\nDepth = 3","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"This page is meant to help along people newer to Julia. If you are quite accustomed to Julia, installing PlantSimEngine should be par for the course, and you can move on to the next section, or read about PlantSimEngine's Key Concepts.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Installing-Julia","page":"Installing and running PlantSimEngine","title":"Installing Julia","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"The direct download link can be found here, and some additional pointers in the official manual.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Installing-VSCode","page":"Installing and running PlantSimEngine","title":"Installing VSCode","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"You can get by using a REPL, but if writing a larger piece of software you may prefer using an IDE. PlantSimEngine is developed using VSCode, which you can install by following instruction on this page. A documentation section specific to using Julia in VSCode can be found here.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Installing-PlantSimEngine-and-its-dependencies","page":"Installing and running PlantSimEngine","title":"Installing PlantSimEngine and its dependencies","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/#Julia-environments","page":"Installing and running PlantSimEngine","title":"Julia environments","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Julia package management is done via the Pkg.jl package. You can find more in-depth sections detailing its usage, and working with Julia environments in its documentation","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"If you find this page insufficient to get started, this tutorial explains in detail the subtleties of Julia environments.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Running-an-environment","page":"Installing and running PlantSimEngine","title":"Running an environment","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Once your environment is set up, you can launch a command prompt and type julia. This will launch Julia, and you should see julia> in the command prompt.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"You can always type ? from there to enter help mode, and type the name of a function or language feature you wish to know more about.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"You can find out which directory you are in by typing pwd() in a Julia session.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Handling environments and dependencies is done in Julia through a specific Package called Pkg, which comes with the base install. You can either call Pkg features the same way you would for another package, or enter Pkg mode by typing ], which will change the display from julia> to something like (@v1.11) pkg>, indicating your current environment (in this case, the default julia environment, which we don't recommend bloating).","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Once in Pkg mode, you can choose to create an environment by typing activate path/to/environment. ","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"You can then add packages that have been added to Julia's online global registry by typing add packagename and you can remove them by typing remove packagename. Typing status or st will indicate what your current environment is comprised of. To update packages in need of updating (a ^ symbol will display next to their name), type update… or up.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"If you are editing/developing a package or using one locally, typing develop path/to/package source/ (or dev path/to/package/source) will cause your environment to use that version instead of the registered one.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Typing instantiate will download all the packages declared in the manifest file (if it exists) of an environment.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"For instance, PlantSimEngine has a test folder used in development. If you wanted to run tests, you would type ] then activate ../path/to/PlantSimEngine/test then instantiate and then you would be ready to run some scripts.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"So if you wish to use PlantSimEngine, you can enter Pkg mode (]), choose an environment folder, then activate that environment with activate ../path/to/your_environment, add PlantSimEngine to it with add PlantSimEngine then download the package and its dependencies with instantiate.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Companion-packages","page":"Installing and running PlantSimEngine","title":"Companion packages","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"You'll also, for most of our examples, need PlantMeteo. For several multi-scale simulations, you'll need MultiScaleTreeGraph.","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Some of the weather data examples make use of the CSV package, some output data is manipulated as a DataFrame, which is part of the DataFrames package.","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Using-the-example-models","page":"Installing and running PlantSimEngine","title":"Using the example models","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Example models are exported as a distinct submodule of PlantSimEngine, meaning they aren't part of the main API. You can use them by typing:","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"using PlantSimEngine.Examples","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Running-a-test-simulation","page":"Installing and running PlantSimEngine","title":"Running a test simulation","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"Assuming you've setup you're environement, correctly added PlantMeteo and PlantSimEngine to that environment, and downloaded everything with instantiate, you'll be able to run a test example in your REPL by typing line-by-line:","category":"page"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout_sim = run!(leaf, meteo)","category":"page"},{"location":"prerequisites/installing_plantsimengine/#Environements-in-VSCode","page":"Installing and running PlantSimEngine","title":"Environements in VSCode","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine/","page":"Installing and running PlantSimEngine","title":"Installing and running PlantSimEngine","text":"There is detailed documentation explaining how to make use of Julia with VSCode with one section indicating how to handle environments in VSCode: https://www.julia-vscode.org/docs/stable/userguide/env/","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Include the model definition from the examples folder:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nsim_out = run!(model, meteo_day)\n","category":"page"},{"location":"working_with_data/visualising_outputs/#Visualizing-outputs-and-data","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/#Output-structure","page":"Visualizing outputs and data","title":"Output structure","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"PlantSimEngine's run! functions return for each timestep the state of the variables that were requested using the tracked_outputs kwarg (or the state of every variable if this kwarg was left unspecified). Multi-scale simulations also indicate which organ and MTG node these state variables are related to.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"Here's an example indicating how to plot output data using CairoMakie, a package used for plotting.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Include the model definition from the examples folder:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nsim_outputs = run!(models, meteo_day)","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"The output data is displayed as a by default as a TimeStepTable. It is also possible to filter which variables are kept via the optional tracked_outputs keyword argument.","category":"page"},{"location":"working_with_data/visualising_outputs/#Plotting-outputs","page":"Visualizing outputs and data","title":"Plotting outputs","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"Using CairoMakie, one can plot out selected variables :","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"note: Note\nYou will need to add CairoMakie to your environment through Pkg mode first.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"# Plot the results:\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, sim_outputs[:TT_cu], sim_outputs[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, sim_outputs[:TT_cu], sim_outputs[:aPPFD], color=:firebrick1)\n\nfig","category":"page"},{"location":"working_with_data/visualising_outputs/#TimeStepTables-and-DataFrames","page":"Visualizing outputs and data","title":"TimeStepTables and DataFrames","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"sim_out = run!(model, meteo_day)","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"The output data is usually stored in a TimeStepTable structure defined in PlantMeteo.jl, which is a fast DataFrame-like structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. Weather data is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"Another simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"using DataFrames\nsim_outputs_df = PlantSimEngine.convert_outputs(sim_outputs, DataFrame)\nsim_outputs_df[[1, 2, 3, 363, 364, 365], :]","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"It is also possible to create DataFrames from specific variables:","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"df = DataFrame(aPPFD=sim_outputs[:aPPFD][1], LAI=sim_outputs.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs and data","title":"Visualizing outputs and data","text":"Which can also be useful for Parameter fitting .","category":"page"},{"location":"multiscale/multiscale_example_2/#Expanding-on-the-multiscale-simulation","page":"Expanding the plant simulation","title":"Expanding on the multiscale simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Let's build on the previous example and add some other organ growth, as well as some very mild coupling between the two.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"You can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Pages = [\"multiscale_example_2.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale_example_2/#Setup","page":"Expanding the plant simulation","title":"Setup","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Once again, with a properly set-up Julia environment:","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo\nusing MultiScaleTreeGraph\nusing CSV, DataFrames\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # No inputs\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Adding-roots-to-our-plant","page":"Expanding the plant simulation","title":"Adding roots to our plant","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"We'll add a root that extracts water and adds it to the stock. Initial water stocks are low, so root growth is prioritized, then the plant also grows leaves and a new internode like it did before. Roots only grow up to a certain point, and don't branch.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"This leads to adding a new scale, \"Root\" to the mapping, as well as two more models, one for water absorption, the other for root growth. Other models are updated here and there to account for water. The carbon capture model remains unchanged, and so is the get_n_leaves helper function.","category":"page"},{"location":"multiscale/multiscale_example_2/#Root-models","page":"Expanding the plant simulation","title":"Root models","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Water-absorption","page":"Expanding the plant simulation","title":"Water absorption","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Let's implement a very fake model of root water absorption. It'll capture the amount of precipitation in the weather data multiplied by some assimilation factor.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"PlantSimEngine.@process \"water_absorption\" verbose = false\n\nstruct ToyWaterAbsorptionModel <: AbstractWater_AbsorptionModel\nend\n\nPlantSimEngine.inputs_(::ToyWaterAbsorptionModel) = (root_water_assimilation=1.0,)\nPlantSimEngine.outputs_(::ToyWaterAbsorptionModel) = (water_absorbed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyWaterAbsorptionModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_absorbed = meteo.Precipitations * status.root_water_assimilation\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Root-growth","page":"Expanding the plant simulation","title":"Root growth","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The root growth model is similar to the internode growth one : it checks for a water threshold and that there is enough carbon, and adds a new organ to the MTG if the maximum length hasn't been reached.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"It also makes use of a couple of helper functions to find the end root and compute root length : ","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"function get_root_end_node(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\", filter_fun = MultiScaleTreeGraph.isleaf)\nend\n\nfunction get_roots_count(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return length(MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\"))\nend\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel{T} <: AbstractRoot_GrowthModel\n    water_threshold::T\n    carbon_root_creation_cost::T\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = (water_stock=0.0,carbon_stock=0.0,)\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        \n        root_end = get_root_end_node(status.node)\n        \n        if length(root_end) != 1 \n            throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n        end\n        root_len = get_roots_count(root_end[1])\n        if root_len < m.root_max_len\n            st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n            status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n        end\n    else\n        status.carbon_root_creation_consumed = 0.0\n    end\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Updating-other-models-to-account-for-water","page":"Expanding the plant simulation","title":"Updating other models to account for water","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Resource-storage","page":"Expanding the plant simulation","title":"Resource storage","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Water absorbed must now be accumulated, and root carbon creation costs taken into account.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"PlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(water_absorbed=0.0,carbon_captured=0.0,carbon_organ_creation_consumed=0.0,carbon_root_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (water_stock=-Inf,carbon_stock=-Inf)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_stock += sum(status.water_absorbed)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed) - sum(status.carbon_root_creation_consumed)\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Internode-creation","page":"Expanding the plant simulation","title":"Internode creation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The minor change is that new organs are now created only if the water stock is above a given threshold.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"struct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\n    water_leaf_threshold::T\nend\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0,leaves_max_surface_area=100.0,\nwater_leaf_threshold=30.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area, water_leaf_threshold)\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0,water_stock=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if water levels are low, prioritise roots\n    if status.water_stock < m.water_leaf_threshold\n        return nothing\n    end\n\n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Updating-the-mapping","page":"Expanding the plant simulation","title":"Updating the mapping","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The resource storage and internode emergence models now need a couple of extra water-related mapped variables.  The \"Root\" organ is added to the mapping with its own models. New parameters need to be initialized.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>[\"Root\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:water_stock)=>\"Plant\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" => ( MultiScaleModel(\n            model=ToyRootGrowthModel(10.0, 50.0, 10),\n            mapped_variables=[PreviousTimeStep(:carbon_stock)=>\"Plant\",\n            PreviousTimeStep(:water_stock)=>\"Plant\"],\n        ),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)","category":"page"},{"location":"multiscale/multiscale_example_2/#Running-the-simulation","page":"Expanding the plant simulation","title":"Running the simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Running this new simulation is almost the same as before. The weather data is unchanged, but a new \"Root\" node was added to the MTG.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    plant_root_start = MultiScaleTreeGraph.Node(\n        plant, \n        MultiScaleTreeGraph.NodeMTG(\"+\", \"Root\", 1, 3), \n    )\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    \nouts = run!(mtg, mapping, meteo_day)\nmtg","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"And that's it ! ","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"...Or is it ?","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"If you inspect the code and output data closely, you may notice some distinctive problems with the way the simulation runs... Some things aren't quite right. If you wish to know more, onwards to the next chapter: Fixing bugs in the plant simulation","category":"page"},{"location":"step_by_step/implement_a_model_additional/#Model-implementation-additional-notes","page":"Implementing a model : additional notes","title":"Model implementation additional notes","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Pages = [\"implement_a_model_additional.md\"]\nDepth = 3","category":"page"},{"location":"step_by_step/implement_a_model_additional/#Parametric-types","page":"Implementing a model : additional notes","title":"Parametric types","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"In Implementing a model, the Beer model's structure was declared with a parametric type.","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Why not force the type ? Float64 is more accurate than Float32, after all:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"struct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Doing so would lose some flexibility in the way users can make use of your models. For example a user could use the Particles type from MonteCarloMeasurements.jl for automatic uncertainty propagation, and this is only possible if the model type is parameterizable. Forcing a Float64 type would render the model incompatible with Particles.","category":"page"},{"location":"step_by_step/implement_a_model_additional/#Type-promotion","page":"Implementing a model : additional notes","title":"Type promotion","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"When implementing a new model, you can do a little optional extra work to help future users.","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"You can add a method for type promotion. It wouldn't make any sense for the previous Beer example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"struct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"To add type promotion to Beer2 we would do:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"function Beer2(k,x)\n    Beer2(promote(k,x)...)\nend","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"note: Note\npromote returns a NamedTuple, which needs to be splatted for the constructor, see the Julia docs for a more in-depth explanation, or our Getting started with Julia page for some links to other references discussing Julia concepts used in PlantSimEngine.","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"This would allow users to instantiate the model parameters using different types of inputs. For example users may write the following:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Beer2(0.6,2)","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Beer2 is a parametric type, with all fields sharing the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this forces the user to give all parameters with the same type.","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"And in the example above, providin 0.6 for k, which is a Float64, and 2 for x, which is an Int. If you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were type promotion comes in handy, as it will convert all your inputs to a common type (when possible). In our case it will convert 2 to 2.0.","category":"page"},{"location":"step_by_step/implement_a_model_additional/#Other-helper-functions-and-constructors","page":"Implementing a model : additional notes","title":"Other helper functions and constructors","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/#Default-parameter-values","page":"Implementing a model : additional notes","title":"Default parameter values","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"You can simplify model usage by helping your user with default values for some parameters (if applicable). For example, in the Beer model a user will almost never change the value of k. So we can provide a default value like so:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Beer() = Beer(0.6)","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Now the user can call Beer with no arguments, and k will default to 0.6.","category":"page"},{"location":"step_by_step/implement_a_model_additional/#Parameter-values-as-kwargs","page":"Implementing a model : additional notes","title":"Parameter values as kwargs","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Another useful thing is the ability to instantiate your model type with keyword arguments, i.e. naming the arguments. You can do it by adding the following method:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Beer(;k) = Beer(k)","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"The ; syntax indicates that subsequent arguments are provided as keyword arguments, so now we can call Beer like this:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Beer(k = 0.7)","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"This helps readability when there are a lot of parameters and some have default values.","category":"page"},{"location":"step_by_step/implement_a_model_additional/#eltype","page":"Implementing a model : additional notes","title":"eltype","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"The last optional utility function to implement is a method for the eltype function:","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"Base.eltype(x::Beer{T}) where {T} = T","category":"page"},{"location":"step_by_step/implement_a_model_additional/","page":"Implementing a model : additional notes","title":"Implementing a model : additional notes","text":"This one helps Julia know the type of the elements in the structure, and make it faster.","category":"page"},{"location":"step_by_step/simple_model_coupling/#Standard-model-coupling","page":"Coupling","title":"Standard model coupling","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\nusing DataFrames\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nnothing","category":"page"},{"location":"step_by_step/simple_model_coupling/#ModelList","page":"Coupling","title":"ModelList","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"The ModelList is a container that holds a list of models, their parameter values, and the status of the variables associated to them.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"If one looks at prior examples, the Modellists so far have only contained a single model, whose input variables are initialised in the Modellist status keyword argument. ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Example models are all taken from the example scripts in the examples folder.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a first ModelList declaration with a light interception model, requiring input Leaf Area Index (LAI): ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"modellist_coupling_part_1 = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a second one with a Leaf Area Index model, with some example Cumulated Thermal Time as input. (This TT_cu is usually computed from weather data):","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"modellist_coupling_part_2 = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)","category":"page"},{"location":"step_by_step/simple_model_coupling/#Combining-models","page":"Coupling","title":"Combining models","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Suppose we want our ToyLAIModel to compute the LAI for the light interception model. ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"We can couple the two models by having them be part of a single ModelList. The LAI variable will then be a coupled output  computed by the ToyLAIModel, then used as input by Beer. It will no longer need to be declared as part of the [status .","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"This is an instance of what we call a \"soft dependency\" coupling: a model depends on another model's outputs for its inputs.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a first attempt : ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=1.0:2000.0,),\n)\nstruct UnexpectedSuccess <: Exception end #hack to enable checking an error without failing docbuild #hide\n# see https://github.com/JuliaDocs/Documenter.jl/issues/1420 #hide\ntry #hide\nrun!(models)\nthrow(UnexpectedSuccess()) #hide\ncatch err; err isa UnexpectedSuccess ? rethrow(err) : showerror(stderr, err); end  #hide","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Oops, we get an error related to the weather data : ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"ERROR: type NamedTuple has no field Ri_PAR_f\nStacktrace:\n  [1] getindex(mnt::Atmosphere{(), Tuple{}}, i::Symbol)\n    @ PlantMeteo ~/Documents/CIRAD/dev/PlantMeteo/src/structs/atmosphere.jl:147\n  [2] getcolumn(row::PlantMeteo.TimeStepRow{Atmosphere{(), Tuple{}}}, nm::Symbol)\n    @ PlantMeteo ~/Documents/CIRAD/dev/PlantMeteo/src/structs/TimeStepTable.jl:205\n    ...","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"The Beer model requires a specific meteorological parameter. Let's fix that by importing the example weather data :","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\n\n# PlantMeteo and CSV packages are now used\nusing PlantMeteo, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import example weather data\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),), # We can now compute a genuine cumulative thermal time from the weather data\n)\n\n# Add the weather data to the run! call\noutputs_coupled = run!(models, meteo_day)\n","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"And there you have it. The light interception model made its computations using the Leaf Area Index computed by ToyLAIModel.","category":"page"},{"location":"step_by_step/simple_model_coupling/#Further-coupling","page":"Coupling","title":"Further coupling","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Of course, one can keep adding models. Here's an example ModelList with another model, ToyRUEGrowthModel, which computes the carbon biomass increment caused by photosynthesis.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"models = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"model_execution/#Model-execution","page":"Execution","title":"Model execution","text":"","category":"section"},{"location":"model_execution/#Simulation-order","page":"Execution","title":"Simulation order","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the ModelList to automatically compute a dependency graph between the models and run the simulation in the correct order. When running a simulation with run!, the models are then executed following this simple set of rules:","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Independent models are run first. A model is independent if it can be run independently from other models, only using initializations (or nothing). \nThen, models that have a dependency on other models are run. The first ones are the ones that depend on an independent model. Then the ones that are children of the second ones, and then their children ... until no children are found anymore. There are two types of children models (i.e. dependencies): hard and soft dependencies:\nHard dependencies are always run before soft dependencies. A hard dependency is a model that list dependencies in their own method for dep. See this example that shows Process2Model defining a hard dependency on any model that simulate process1. Inner hard dependency graphs (i.e. consecutive hard-dependency children) are considered as a single soft dependency.\nSoft dependencies are then run sequentially. A model has a soft dependency on another model if one or more of its inputs is computed by another model. If a soft dependency has several parent nodes (e.g. two different models compute two inputs of the model), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"},{"location":"multiscale/multiscale_coupling/#Handling-dependencies-in-a-multiscale-context","page":"Multiscale coupling considerations","title":"Handling dependencies in a multiscale context","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Pages = [\"multiscale_coupling.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/multiscale_coupling/#Scalar-and-vector-variable-mappings","page":"Multiscale coupling considerations","title":"Scalar and vector variable mappings","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the detailed example discussed previously Multi-scale variable mapping, there were several instances of mapping a variable from one scale to another, which we'll briefly describe again to help transition to the next and more advanced subsection. Here's a relevant exerpt from the mapping : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"\"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        ...\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        ...\n    ),","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"For flexibility reasons, instead of explicitely linking most models from different scales together, one only declares which variables are meant to be taken from another scale (or more accurately, a model at a different scale outputting those variables). This keeps the convenience of switching models while making few changes to the mapping. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"However, PlantSimEngine cannot infer which scales have multiple instances, and which are single-instance, as the scale names are user-defined.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the above example, there is only one scene at the \"Scene\", and one plant at the \"Plant\" scale, meaning the TT_cu variable mapped between the two has a one-to-one scalar-to-scalar correspondance.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"On the other hand, the carbon_assimilation variable is computed for every leaf, of which there could be hundreds, or thousands, giving a scalar-to-vector correspondance. The carbon assimilation model runs many times every timestep, whereas the carbon allocation model only runs once per timestep. There may be initially be only a single leaf, though, meaning PlantSimEngine cannot currently guess from the initial configuration that there might be multiple leaves created during the simulation.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Hence the difference in mapping declaration :  TT_cuis declared as a scalar correspondence : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":":TT_cu => \"Scene\",","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"whereas carbon_assimilation (and other variables) will be declared as a vector correspondence :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":":carbon_assimilation => [\"Leaf\"],","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Note that there may be instances where you might wish to write your own model to aggregate a variable from a multi-instance scale.","category":"page"},{"location":"multiscale/multiscale_coupling/#Hard-dependencies-between-models-at-different-scale-levels","page":"Multiscale coupling considerations","title":"Hard dependencies between models at different scale levels","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"If a model requires some input variable that is computed at another scale, then providing the appropriate mapping for that variable will resolve name conflicts and enable that model to run with no further steps for the user or the modeler when the coupling is a 'soft dependency'.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the case of a hard dependency that operates at the same scale as its parent, declaring the hard dependency is exactly the same as in single-scale simulations and there are also no new extra steps on the user-side:","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The parent model directly handles the call to its hard dependency model(s), meaning they are not explicitely managed by the top-level dependency graph.\nThis means only the owning model of that dependency is visible in the graph, and its hard dependency nodes are internal.\nWhen the caller (or any downstream model that requires some variables from the hard dependency model) operates at the same scale, variables are easily accessible, and no mapping is required. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"On the other hand, modelers do need to bear in mind a couple of subtleties when developing models that possess hard dependencies that operate at a different organ level from their parent: ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"If an model needs to be directly called by a parent but operates at a different scale/organ level, a modeler must declare hard dependencies with their respective organ level, similarly to the way the user provides a mapping. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Conceptually :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":" PlantSimEngine.dep(m::ParentModel) = (\n    name_provided_in_the_mapping=AbstractHardDependencyModel => [\"Organ_Name_1\",],\n)","category":"page"},{"location":"multiscale/multiscale_coupling/#An-example-from-the-toy-plant-simulation-tutorial","page":"Multiscale coupling considerations","title":"An example from the toy plant simulation tutorial","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"You can find an example of a hard dependency discussed in the A multi-scale hard dependency appears subsection of the third part of toy plant tutorial.","category":"page"},{"location":"multiscale/multiscale_coupling/#An-example-from-XPalm.jl","page":"Multiscale coupling considerations","title":"An example from XPalm.jl","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Here's a concrete example in XPalm, an oil palm model developed on top of PlantSimEngine.   Organs are produced at the phytomer scale, but need to run an age model and a biomass model at the reproductive organs' scales.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":" PlantSimEngine.dep(m::ReproductiveOrganEmission) = (\n    initiation_age=AbstractInitiation_AgeModel => [m.male_symbol, m.female_symbol],\n    final_potential_biomass=AbstractFinal_Potential_BiomassModel => [m.male_symbol, m.female_symbol],\n)","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The user-mapping includes the required models at specific organ levels. Here's the relevant portion of the mapping for the male reproductive organ :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"mapping = Dict(\n    ...\n    \"Male\" =>\n    MultiScaleModel(\n        model=XPalm.InitiationAgeFromPlantAge(),\n        mapped_variables=[:plant_age => \"Plant\",],\n    ),\n    ...\n    XPalm.MaleFinalPotentialBiomass(\n        p.parameters[:male][:male_max_biomass],\n        p.parameters[:male][:age_mature_male],\n        p.parameters[:male][:fraction_biomass_first_male],\n    ),\n    ...\n)","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The model's constructor provides convenient default names for the scale corresponding to the reproductive organs. A user may override that if their naming schemes or MTG attributes differ.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"function ReproductiveOrganEmission(mtg::MultiScaleTreeGraph.Node; phytomer_symbol=\"Phytomer\", male_symbol=\"Male\", female_symbol=\"Female\")\n    ...\nend","category":"page"},{"location":"multiscale/multiscale_coupling/#Implementation-details:-accessing-a-hard-dependency's-variables-from-a-different-scale","page":"Multiscale coupling considerations","title":"Implementation details: accessing a hard dependency's variables from a different scale","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"But how does a model M calling a hard dependency H provide H's variables when calling H's run! function ? The status argument the user provides M operates at M's organ level, so if used to call H's run! function any required variable for H will be missing.    ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"PlantSimEngine provides what are called Status Templates in the simulation graph. Each organ level has its own Status template listing the available variables at that scale. So when a model M calls a hard dependency H's run! function, any required variables can be accessed through the status template of H's organ level.","category":"page"},{"location":"multiscale/multiscale_coupling/#XPalm.jl-example-to-illustrate","page":"Multiscale coupling considerations","title":"XPalm.jl example to illustrate","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Using the same example in XPalm : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"# Note that the function's 'status' parameter does NOT contain the variables required by the hard dependencies as the calling model's organ level is \"Phytomer\", not \"Male\" or \"Female\"\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n    ...\n    status.graph_node_count += 1\n\n    # Create the new organ as a child of the phytomer:\n    st_repro_organ = add_organ!(\n        status.node[1], # The phytomer's internode is its first child \n        sim_object,  # The simulation object, so we can add the new status \n        \"+\", status.sex, 4;\n        index=status.phytomer_count,\n        id=status.graph_node_count,\n        attributes=Dict{Symbol,Any}()\n    )\n\n    # Compute the initiation age of the organ:\n    PlantSimEngine.run!(sim_object.models[status.sex].initiation_age, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\n    PlantSimEngine.run!(sim_object.models[status.sex].final_potential_biomass, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\nend","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the above example the organ and its status template are created on the fly. When that isn't the case, the status template can be accessed through the simulation graph :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"function PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n\n    ...\n\n    if status.sex == \"Male\"\n\n        status_male = sim_object.statuses[\"Male\"][1]\n        run!(sim_object.models[\"Male\"].initiation_age, models, status_male, meteo, constants, sim_object)\n        run!(sim_object.models[\"Male\"].final_potential_biomass, models, status_male, meteo, constants, sim_object)\n    else\n        # Female\n        ...\n    end\nend","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/#Automated-tests-:-downstream-dependency-checking","page":"Automated testing","title":"Automated tests : downstream dependency checking","text":"","category":"section"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"PlantSimEngine is open sourced on Github, and so are its other companion packages, PlantGeom.jl, PlantMeteo.jl, PlantBioPhysics.jl, MultiScaleTreeGraph.jl, and XPalm.","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"One handy CI (Continuous Integration) feature implemented for these packages is automated integration and downstream testing: after changes to a package, its known downstream dependencies are tested to ensure no breaking changes were introduced. ","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"For instance, PlantBioPhysics uses PlantSimEngine, so an integration test ensures that PlantBioPhysics's tests don't break in an unforeseen manner after a new PlantSimEngine release. There also is a benchmark check in the downstream tests: [https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/test/downstream/test-plantbiophysics.jl]","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"This is something you can take advantage of if you wish to develop using PlantSimEngine, by providing us with your package name (or adding it to the CI yml file in a Pull Request); we can then add it to the list of downstream packages to test, and generate PR when breaking changes are introduced.","category":"page"},{"location":"step_by_step/advanced_coupling/#Coupling-more-complex-models","page":"Advanced coupling and hard dependencies","title":"Coupling more complex models","text":"","category":"section"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"When two or more models have a two-way interdependency (rather than variables flowing out only one-way from one model into the next), we describe it as a hard dependency.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"This kind of interdependency requires a little more work from the user/modeler for PlantSimEngine to be able to automatically create the dependency graph.","category":"page"},{"location":"step_by_step/advanced_coupling/#Declaring-hard-dependencies","page":"Advanced coupling and hard dependencies","title":"Declaring hard dependencies","text":"","category":"section"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"A model that explicitly and directly calls another process in its run! function is part of a hard dependency, or a hard-coupled model. ","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"Let's go through the example processes and models from a script provided by the package here examples/dummy.jl","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"In this script, we declare seven processes and seven models, one for each process. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model...","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"When run, Process2Model calls another process's run! function explicitely, which requires defining that process as a hard-dependency of Process2Model :","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"function PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # computing var3 using process1:\n    run!(models.process1, models, status, meteo, constants)\n    # computing var4 and var5:\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"Process2Model is coupled to another process (process1), and calls its model's run function. The run! function is called with the same arguments as the run! function of the model that calls it, except that we pass the process we want to simulate as the first argument.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"note: Note\nWe don't enforce any type of model to simulate process1. This is the reason why we can switch so easily between model implementations for any process, by just changing the model in the ModelList.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"A hard-dependency must always be declared to PlantSimEngine. This is done by adding a method to the dep function when implementing the model. For example, the hard-dependency to process1 into Process2Model is declared as follows:","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"PlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"This way PlantSimEngine knows that Process2Model needs a model for the simulation of the process1 process. To avoid imposing a specific model to be coupled with Process2Model, the dependency only requires a model that is a subtype of the abstract parent type AbstractProcess1Model. This avoids constraining to the specific Process1Model implementation, meaning an alternate model computing the same variables for the same process is still interchangeable with Process1Model.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"While not encouraged, if you have a valid reason to force the coupling with a particular model, you can force the dependency to require that model specifically. For example, if we want to use only Process1Model for the simulation of process1, we would declare the dependency as follows:","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"PlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"## Examples in the wild","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"You can find a typical example in a companion package: PlantBioPhysics.jl. An energy balance model, the Monteith model, needs to iteratively run a photosynthesis model in its run! function.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Troubleshooting-error-messages","page":"Troubleshooting","title":"Troubleshooting error messages","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"PlantSimEngine attempts to be as comfortable and easy to use as possible for the user, and many kinds of user error will be caught and explanations provided to resolve them, but there are still blind spots, as well as syntax errors that will often generate a Julia error (which can be less intuitive to decrypt) rather than a PlantSimEngine error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"To help people newer to Julia with troubleshooting, here are a few common 'easy-to-make' mistakes with the current API that might not be obvious to interpret, and pointers on how to fix them.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"They are listed by 'nature of error', rather than by error message, so you may need to search the page to find your specific error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you need more help to decode Julia errors, you can find help on the Julia Discourse forums. If you need some advice on the FSPM side, the research community has its own discourse forum.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If the issue seems PlantSimEngine-related, or you have questions regarding modeling or have suggestions, you can also file an issue on Github.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Pages = [\"plantsimengine_and_julia_troubleshooting.md\"]\nDepth = 3","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Tips-and-workflow","page":"Troubleshooting","title":"Tips and workflow","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Some errors are very specific as to their cause, and the PlantSimEngine errors tend to be explicit about which parameter / variable / organ is causing the error, helping narrow down its origin.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Some generic-looking errors usually do contain some extra information to help focus the debugging hunt. For instance, a dispatch failure on run! caused by some issue with args/kwargs may highlight explicitely indicate which arguments are currently causing conflict. In VSCode, such arguments are highlighted in red (the first and last arguments in the example below) : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = 1\nrun!(a, simple_mtg, mapping, meteo_day, a)\n\nERROR: MethodError: no method matching run!(::Int64, ::Node{NodeMTG, Dict{…}}, ::Dict{String, Tuple{…}}, ::DataFrame, ::Int64)\nThe function [`run!`](@ref) exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyPlantLeafSurfaceModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ PlantSimEngine /PlantSimEngine/examples/ToyLeafSurfaceModel.jl:75\n   ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you wish to search for a specific error in the current page, copy the part of the description that is not specific to your script, and Ctrl+F it here. In the above example, the generic part would be : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: MethodError: no method matching","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Common-Julia-errors","page":"Troubleshooting","title":"Common Julia errors","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#NamedTuples-with-a-single-value-require-a-comma-:","page":"Troubleshooting","title":"NamedTuples with a single value require a comma :","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This one is easy to miss.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Empty NamedTuple objects are initialised with x = NamedTuple(). Ones with more than one variable can be initialised like this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0, var2 = 0)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"or like this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0, var2 = 0,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The second comma being optional.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"However, if there is only a single variable, notation has to be : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The comma is compulsory. If it is forgotten : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"the line will be interpreted as setting the variable a to the value var1 is set to, hence a will be an Int64 of value 0.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This is a liability when writing custom models as some functions work with NamedTuples : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"function PlantSimEngine.inputs_(::HardDepSameScaleAvalModel)\n    (e2 = -Inf,)\nend","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The error returned will likely be a Julia error along the lines of : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[ERROR: MethodError: no method matching merge(::Float64, ::@NamedTuple{g::Float64})\n\nClosest candidates are:\nmerge(::NamedTuple{()}, ::NamedTuple)\n@ Base namedtuple.jl:337\nmerge(::NamedTuple{an}, ::NamedTuple{bn}) where {an, bn}\n@ Base namedtuple.jl:324\nmerge(::NamedTuple, ::NamedTuple, NamedTuple...)\n@ Base namedtuple.jl:343\n\nStacktrace:\n[1] variables_multiscale(node::PlantSimEngine.HardDependencyNode{…}, organ::String, vars_mapping::Dict{…}, st::@NamedTuple{})\n...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"It is sometimes properly detected and explained on PlantSimEngine's side (when passing in tracked_outputs, for instance), but may also occur when declaring statuses.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Incorrectly-declaring-empty-inputs-or-outputs","page":"Troubleshooting","title":"Incorrectly declaring empty inputs or outputs","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The syntax for an empty NamedTuple is NamedTuple(). If instead one types () or (,)an error returned respectively by PlantSimEngine or Julia will be returned.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#PlantSimEngine-user-errors","page":"Troubleshooting","title":"PlantSimEngine user errors","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Most of the following errors occur exclusively in multi-scale simulations, which has a slightly more complex API, but some are common to both single- and multi-scale simulations.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Implementing-a-model:-forgetting-to-import-or-prefix-functions","page":"Troubleshooting","title":"Implementing a model: forgetting to import or prefix functions","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"When implementing a model, you need to make sure that your implementation is correctly recognised as extending PlantSimEngine methods and types, and not writing new independent ones.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In the following working toy model implementation, note that the inputs_, outputs_ and run! function are all prefixed with the module name. If there were hard dependencies to manage, the dep function would also be identically prefixed.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using PlantSimEngine\n@process \"toy\" verbose = false\n\nstruct ToyToyModel{T} <: AbstractToyModel \n    internal_constant::T\nend\n\nfunction PlantSimEngine.inputs_(::ToyToyModel)\n    (a = -Inf, b = -Inf, c = -Inf)\nend\n\nfunction PlantSimEngine.outputs_(::ToyToyModel)\n    (d = -Inf, e = -Inf)\nend\n\n\nfunction PlantSimEngine.run!(m::ToyToyModel, models, status, meteo, constants=nothing, extra_args=nothing)\n    status.d = m.internal_constant * status.a \n    status.e += m.internal_constant\nend\n\nmeteo = Weather([\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=18.0, Wind=1.0, Rh=0.65, Ri_PAR_f=100.0),\n])\n\nmodel = ModelList(\n    ToyToyModel(1),\n   status = ( a = 1, b = 0, c = 0),\n)\nto_initialize(model) \nsim = PlantSimEngine.run!(model, meteo)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you declare these functions without importing them first, or prefixing them with the module name, they will be considered to be part of your current environment, and won't be extending PlantSimEngine methods, which means PlantSimEngine will not be able to properly make use of your functions, and simulations are likely to error, or run incorrectly.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting to prefix the run! function definition gives the following error : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: MethodError: no method matching run!(::ModelList{@NamedTuple{…}, Status{…}}, ::TimeStepTable{Atmosphere{…}})\nThe function [`run!`](@ref) exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyToyModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ Main ~/path/to/file.jl:20","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting to prefix the inputs_or outputs_ functions for your model might not always generate an error, depending on whether the variables declared in this function are present in your ModelList or mapping's corresponding Status.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In cases where they do throw an error, you may get the following kind of output:","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: type NamedTuple has no field d\nStacktrace:\n [1] setproperty!(mnt::Status{(:a, :b, :c), Tuple{…}}, s::Symbol, x::Int64)\n   @ PlantSimEngine ~/path/to/package/PlantSimEngine/src/component_models/Status.jl:100\n [2] run!(m::ToyToyModel{…}, models::@NamedTuple{…}, status::Status{…}, meteo::PlantMeteo.TimeStepRow{…}, constants::Constants{…}, extra_args::Nothing)\n ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"note: Note\nThere may be more we can do on our end in the future to make the issue more obvious, but in the meantime it is safest to consistently prefix the methods you need to declare and call with PlantSimEngine., or to explicitely import the functions you wish to extend, e.g.: import PlantSimEngine: inputs_, outputs_.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#MultiScaleModel-:-forgetting-a-kwarg-in-the-declaration","page":"Troubleshooting","title":"MultiScaleModel : forgetting a kwarg in the declaration","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A MultiScaleModel requires two kwargs, model and mapped_variables : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        model=ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting 'model=' :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )\nERROR: MethodError: no method matching MultiScaleModel(::ToyLAIModel; mapped_variables::Vector{Pair{Symbol, String}})\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n    \nClosest candidates are:\n    MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"mapped_variables\"\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:188\n    MultiScaleModel(; model, mapped_variables)\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting 'mapped_variables=' :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        model=ToyLAIModel(),\n        [:TT_cu => \"Scene\",],\n    )\n\nERROR: MethodError: no method matching MultiScaleModel(::Vector{Pair{Symbol, String}}; model::ToyLAIModel)\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  MultiScaleModel(; model, mapping)\n   @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n  MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"model\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The message 'got unsupported keyword argument \"model\"' can be misleading, as in the error in this case is not that a kwarg is unsupported, but rather that a keyword argument is missing.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#MultiScaleModel-:-variable-not-defined-in-Module","page":"Troubleshooting","title":"MultiScaleModel : variable not defined in Module","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A possible cause for this error is that a variable was declared instead of a symbol in a mapping for a multiscale model :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"mapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables = [should_be_symbol => \"Other_Scale\"] # should_be_symbol is a variable, likely not found in the current module \n),\n...\n),","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here's the correct version : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"mapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables=[:should_be_symbol => \"Other_Scale\"] # should_be_symbol is now a symbol\n),\n...\n),","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Kwarg-and-arg-parameter-issues-when-calling-run!","page":"Troubleshooting","title":"Kwarg and arg parameter issues when calling run!","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"There are, unfortunately, multiple ways of passing in arguments to the run! functions that will confuse dynamic dispatch. Some of it is due to imperfections in type declarations on PlantSimEngine's end and may be improved upon in the future. ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here are a few examples when modifying the usual multiscale run! call in this working example : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"    meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\n    var1 = 15.0\n\n    mapping = Dict(\n        \"Leaf\" => (\n            Process1Model(1.0),\n            Process2Model(),\n            Process3Model(),\n            Status(var1=var1,)\n        )\n    )\n\n    outs = Dict(\n        \"Leaf\" => (:var1,), # :non_existing_variable is not computed by any model\n    )\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The exact signature is this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"function run!(\n    object::MultiScaleTreeGraph.Node,\n    mapping::Dict{String,T} where {T},\n    meteo=nothing,\n    constants=PlantMeteo.Constants(),\n    extra=nothing;\n    nsteps=nothing,\n    tracked_outputs=nothing,\n    check=true,\n    executor=ThreadedEx()","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Arguments after the mtg and mapping all have a default value and are optional, and arguments after the ';' delimiter are kwargs and need to be named.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If one forgets the mtg, a flaw in the way run! is defined will lead to this error :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching check_dimensions(::PlantSimEngine.TableAlike, ::Tuple{…}, ::DataFrame)\nThe function `check_dimensions` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  check_dimensions(::Any, ::Any)\n   @ PlantSimEngine PlantSimEngine/src/checks/dimensions.jl:43\n ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If one forgets the necessary 'tracked_outputs=' in the definition, outs will be interpreted as the 'extra' arg instead of a kwarg. 'extra' usually defaults to nothing, and is reserved in multiscale mode, leading to the following error :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mtg, mapping, meteo_day, PlantMeteo.Constants(), outs)\n\nERROR: Extra parameters are not allowed for the simulation of an MTG (already used for statuses).\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] run!(::PlantSimEngine.TreeAlike, object::PlantSimEngine.GraphSimulation{…}, meteo::DataFrames.DataFrameRows{…}, constants::Constants{…}, extra::Dict{…}; tracked_outputs::Nothing, check::Bool, executor::ThreadedEx{…})","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In case of a more generic error that returns a  For example, if one does the opposite and adds a non-existent kwarg, the generic dispatch failure has some more specific information :  got unsupported keyword argument \"constants\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mtg, mapping, meteo_day, constants=PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching run!(::Node{…}, ::Dict{…}, ::DataFrame, ::Dict{…}, ::Nothing; constants::Constants{…})\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\nClosest candidates are:\n  run!(::Node, ::Dict{String}, ::Any, ::Any, ::Any; nsteps, tracked_outputs, check, executor) got unsupported keyword argument \"constants\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Hard-dependency-process-not-present-in-the-mapping","page":"Troubleshooting","title":"Hard dependency process not present in the mapping","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Another weakness in the current error checking leads to an unclear Julia error if a model A is present in a mapping and has a hard dependency on a model B, but B is absent from the mapping.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In the following example, A corresponds to Process3Model, which requires a model B implementing 'Process2Model' and referred to as 'process2'.  Looking at the source code for Process3Model, the hard dependency is declared here : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"PlantSimEngine.dep(::Process3Model) = (process2=Process2Model,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"However, the model provided in the examples, Process2Model is absent from the mapping :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"simple_mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))    \nmapping = Dict(\n    \"Leaf\" => (\n        Process3Model(),\n        Status(var5=15.0,)\n    )\n)\nouts = Dict(\n    \"Leaf\" => (:var5,),\n)\nrun!(simple_mtg, mapping, meteo_day, tracked_outputs=outs)\n\nERROR: type NamedTuple has no field process2\nStacktrace:\n [1] getproperty(x::@NamedTuple{process3::Process3Model}, f::Symbol)\n   @ Base ./Base.jl:49\n [2] run!(::Process3Model, models::@NamedTuple{…}, status::Status{…}, meteo::DataFrameRow{…}, constants::Constants{…}, extra::PlantSimEngine.GraphSimulation{…})\n ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The fix is to add Process2Model() -or another model for the same process- to the mapping.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Status-API-ambiguity","page":"Troubleshooting","title":"Status API ambiguity","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"One current problem with PlantSimEngine's API is that declaring a simulation's Status or Statuses differs between single- and multi-scale.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Returning to the example in Implementing a model: forgetting to import or prefix functions, the ModelList status was declared like this:","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"model = ModelList(\n    ToyToyModel(1),\n   status = ( a = 1, b = 0, c = 0),\n)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If instead you replace status = ...with the multi-scale declaration: Status(...), you will get the following error:","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: MethodError: no method matching process(::Status{(:a, :b, :c), Tuple{Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}}})\nThe function `process` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  process(::Pair{Symbol, A}) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:16\n  process(::A) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:13\n\nStacktrace:\n [1] (::PlantSimEngine.var\"#5#6\")(i::Status{(:a, :b, :c), Tuple{Base.RefValue{…}, Base.RefValue{…}, Base.RefValue{…}}})\n   @ PlantSimEngine ./none:0\n [2] iterate","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you do the opposite in a multi-scale simulation by replacing the necessary Status(...) with status = ..., you may get an ERROR: syntax: invalid named tuple element error. Here's some output when tinkering with the Toy Plant tutorial's mapping:","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: syntax: invalid named tuple element \"MultiScaleModel(...)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"or ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: syntax: invalid named tuple element \"ToyRootGrowthModel(50, 10)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Forgetting-to-declare-a-scale-in-the-mapping-but-having-variables-point-to-it","page":"Troubleshooting","title":"Forgetting to declare a scale in the mapping but having variables point to it","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If there is a need to collect variables at two different scales, and one scale is completely absent from the mapping, the error currently occurs on the Julia side :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# No models at the E3 scale in the mapping !\n\n\"E2\" => (\n        MultiScaleModel(\n        model = HardDepSameScaleEchelle2Model(),\n        mapped_variables=[:c => \"E1\" => :c, :e3 => \"E3\" => :e3, :f3 => \"E3\" => :f3,], \n        ),\n    ),\n\nException has occurred: KeyError\n*\nKeyError: key \"E3\" not found\nStacktrace:\n[1] hard_dependencies(mapping::Dict{String, Tuple{Any, Any}}; verbose::Bool)\n@ PlantSimEngine ......./src/dependencies/hard_dependencies.jl:175\n...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Parenthesis-placement-when-declaring-a-mapping","page":"Troubleshooting","title":"Parenthesis placement when declaring a mapping","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"An unintuitive error encountered in the past when defining a mapping : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: ArgumentError: AbstractDict(kv): kv needs to be an iterator of 2-tuples or pairs","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"may occur when forgetting the parenthesis after '=>' in a mapping declaration, and combining it with another parenthesis error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"mapping = Dict( \"Scale\" => (ToyAssimGrowthModel(0.0, 0.0, 0.0), ToyCAllocationModel(), Status( TT_cu=Vector(cumsum(meteo_day.TT))), ), )","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Other errors such as : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: MethodError: no method matching Dict(::Pair{String, ToyAssimGrowthModel{Float64}}, ::ToyCAllocationModel, ::Status{(:TT_cu,), Tuple{Base.RefValue{…}}})\nThe type `Dict` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Dict(::Pair{K, V}...) where {K, V}","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"often indicate a likely syntax error somewhere in the mapping definition.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Empty-status-vectors-in-multi-scale-simulations","page":"Troubleshooting","title":"Empty status vectors in multi-scale simulations","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This situation won't trigger an error. Unexpectedly empty vectors can be returned as outputs if you happen to forget to a node at the corresponding scale in the MTG, and no organ creation occurs for that node.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here's an example taken from the Converting a single-scale simulation to multi-scale page. It was modified by removing the \"Plant\" node in the dummy MTG passed into the run!function. Without that \"Plant\" node, only \"Scene\"-scale models can run initially, and since no nodes are created, \"Plant\"-scale models will never be run.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"PlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=-Inf,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n#plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\nout_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)\n\nout_multiscale[\"Plant\"][:LAI]","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In the above code, uncommenting the second line will add a \"Plant\" node to the MTG, and the simulation will then behave as intuitively expected.","category":"page"},{"location":"FAQ/translate_a_model/#I-want-to-use-PlantSimEngine-for-my-model","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using PlantSimEngine\nusing CairoMakie\nusing CSV, DataFrames\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If you already have a model, you can easily use PlantSimEngine to couple it with other models with minor adjustments.","category":"page"},{"location":"FAQ/translate_a_model/#Toy-LAI-Model","page":"I want to use PlantSimEngine for my model","title":"Toy LAI Model","text":"","category":"section"},{"location":"FAQ/translate_a_model/#Model-description","page":"I want to use PlantSimEngine for my model","title":"Model description","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Let's take an example with a simple LAI model that we define below:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"\"\"\"\nSimulate leaf area index (LAI, m² m⁻²) for a crop based on the amount of degree-days since sowing with a simple double-logistic function.\n\n# Arguments\n\n- `TT_cu`: degree-days since sowing\n- `max_lai=8`: Maximum value for LAI\n- `dd_incslope=500`: degree-days at which we get the maximal increase in LAI\n- `inc_slope=5`: slope of the increasing part of the LAI curve\n- `dd_decslope=1000`: degree-days at which we get the maximal decrease in LAI\n- `dec_slope=2`: slope of the decreasing part of the LAI curve\n\"\"\"\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This model takes the number of days since sowing as input and returns the simulated LAI. We can plot the simulated LAI for a year:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"FAQ/translate_a_model/#Changes-for-PlantSimEngine","page":"I want to use PlantSimEngine for my model","title":"Changes for PlantSimEngine","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"The model can be implemented using PlantSimEngine as follows:","category":"page"},{"location":"FAQ/translate_a_model/#Define-a-process","page":"I want to use PlantSimEngine for my model","title":"Define a process","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If the process of LAI dynamic is not implemented yet, we can define it like so:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"@process LAI_Dynamic","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model","page":"I want to use PlantSimEngine for my model","title":"Define the model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We have to define a structure for our model that will contain the parameters of the model:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"struct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We can also define default values for the parameters by defining a method with keyword arguments:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"ToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This way users can create a model with default parameters just by calling ToyLAIModel(), or they can specify only the parameters they want to change, e.g. ToyLAIModel(inc_slope=80.0)","category":"page"},{"location":"FAQ/translate_a_model/#Define-inputs-/-outputs","page":"I want to use PlantSimEngine for my model","title":"Define inputs / outputs","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define the inputs and outputs of the model, and the default value at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"PlantSimEngine.inputs_(::ToyLAIModel) = (TT_cu=-Inf,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we use -Inf for the default value, it is the recommended value for Float64 (-999 for Int), as it is a valid value for this type, and is easy to catch in the outputs if not properly set because it propagates nicely. You can also use NaN instead.","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model-function","page":"I want to use PlantSimEngine for my model","title":"Define the model function","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Finally, we can define the model function that will be called at each time step:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"function PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.TT_cu) / model.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.TT_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we don't return the value of the LAI in the definition of the function. This is because we rather update its value in the status directly. The status is a structure that efficiently stores the state of the model at each time step, and it contains all variables either declared as inputs or outputs of the model. This way, we can access the value of the LAI at any time step by calling status.LAI.","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nThe function is defined for one time step only, and is called at each time step automatically by PlantSimEngine. This means that we don't have to loop over the time steps in the function.","category":"page"},{"location":"FAQ/translate_a_model/#defining_the_meteo","page":"I want to use PlantSimEngine for my model","title":"Running a simulation","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Now that we have everything set up, we can run a simulation. The first step here is to define the weather:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"# Import the packages we need:\nusing PlantMeteo, Dates, DataFrames\n\n# Define the period of the simulation:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# Get the weather data for CIRAD's site in Montpellier, France:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# Compute the degree-days with a base temperature of 10°C:\nmeteo.TT = max.(meteo.T .- 10.0, 0.0)\n\n# Aggregate the weather data to daily values:\nmeteo_day = to_daily(meteo, :TT => (x -> sum(x) / 24) => :TT)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define our list of models, passing the values for TT_cu in the status at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"m = ModelList(\n    ToyLAIModel(),\n    status = (TT_cu = cumsum(meteo_day.TT),),\n)\n\noutputs_sim = run!(m)\n\nlines(outputs_sim[:TT_cu], outputs_sim[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"planned_features/#Roadmap","page":"Planned features","title":"Roadmap","text":"","category":"section"},{"location":"planned_features/#Planned-major-features","page":"Planned features","title":"Planned major features","text":"","category":"section"},{"location":"planned_features/#Varying-timesteps","page":"Planned features","title":"Varying timesteps","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Currently, all models are required to make use of the same timestep. Some physiological phenomenae within a plant tend to run on an hourly basis, others are slower. Weather data is often provided daily. Enabling different timesteps depending on the model is on the roadmap.","category":"page"},{"location":"planned_features/#Multi-plant/Multi-species-simulations","page":"Planned features","title":"Multi-plant/Multi-species simulations","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"A goal for PlantSimEngine down the line is to be able to simulate complex scenes with data comprising several plants, possibly of different species, for agroforestry purposes.","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Its current state doesn't enable practical declaration of several plant species, or multiple plants relying on similar subsets of models with partially different models or parameters. ","category":"page"},{"location":"planned_features/#Minor-features","page":"Planned features","title":"Minor features","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Implement a trait or a prepass that checks whether weather data is needed, and if so, if it is properly provided to a simulation\nBetter dependency graph visualization and information printing","category":"page"},{"location":"planned_features/#Minor-planned-improvements-and-QOL-features","page":"Planned features","title":"Minor planned improvements and QOL features","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"A reworked and more consistent mapping API, and multiscale dependency declaration\nImproved user errors\nMore examples\nBetter dependency graph traversal functions\nEnsure cyclic dependency checking and PreviousTimestep is active for ModelLists","category":"page"},{"location":"planned_features/#Improvements-on-the-testing-side","page":"Planned features","title":"Improvements on the testing side","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Better tracking of memory usage and type stability\nWorking CI/Downstream tests\nstate machine checker, validating output invariants\ngraph fuzzing for improved corner-case testing","category":"page"},{"location":"planned_features/#Possible-features-(likely-not-a-priority)","page":"Planned features","title":"Possible features (likely not a priority)","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"API enabling iterative builds and validation of mappings and modellists\nImproved parallelisation \nReintroduce multi-object parallelisation in single-scale","category":"page"},{"location":"planned_features/#Other-minor-points","page":"Planned features","title":"Other minor points","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Examples/solutions for floating-point accumulation errors\nMore examples for fitting/type conversion/error propagation\nMTG couple of new features #106 \nOther minor bugs\nUnrolling the run! function","category":"page"},{"location":"planned_features/#Other","page":"Planned features","title":"Other","text":"","category":"section"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Reproducing another FSPM ?\nDiffusion model example ?","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"The full list of issues can be found here","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"TODO Detail other related packages' roadmaps (mostly stuff like PlantGeom's mtg reference mesh linking) ? PBP updates ?","category":"page"},{"location":"step_by_step/parallelization/#Parallel-execution","page":"Parallelization","title":"Parallel execution","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"note: Note\nThis page is likely to change and become outdated. In any case, parallel execution only currently applies to single-scale simulations (multi-scale simulations' changing MTGs and extra complexity don't allow for straightforward parallelisation)","category":"page"},{"location":"step_by_step/parallelization/#FLoops","page":"Parallelization","title":"FLoops","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.jl uses the Floops package to run the simulation in sequential, parallel (multi-threaded) or distributed (multi-process) computations over objects, time-steps and independent processes. ","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"That means that you can provide any compatible executor to the executor argument of run!. By default, run! uses the ThreadedEx executor, which is a multi-threaded executor. You can also use the SequentialExfor sequential execution (non-parallel), or DistributedEx for distributed computations.","category":"page"},{"location":"step_by_step/parallelization/#Parallel-traits","page":"Parallelization","title":"Parallel traits","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.jl uses Holy traits to define if a model can be run in parallel.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"note: Note\nA model is executable in parallel over time-steps if it does not uses or set values from other time-steps, and over objects if it does not uses or set values from other objects.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"You can define a model as executable in parallel by defining the traits for time-steps and objects. For example, the ToyLAIModel model from the examples folder can be run in parallel over time-steps and objects, so it defines the following traits:","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"By default all models are considered not executable in parallel, because it is the safest option to avoid bugs that are difficult to catch, so you only need to define these traits if it is executable in parallel for them.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"tip: Tip\nA model that is defined executable in parallel will not necessarily will. First, the user has to pass a parallel executor to run! (e.g. ThreadedEx). Second, if the model is coupled with another model that is not executable in parallel, PlantSimEngine will run all models in sequential.","category":"page"},{"location":"step_by_step/parallelization/#Further-executors","page":"Parallelization","title":"Further executors","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"You can also take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"Finally, you can take a look into Transducers.jl's documentation for more information, for example if you don't know what is an executor, you can look into this explanation.","category":"page"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF","page":"Reducing DoF","title":"Reducing the DoF","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"working_with_data/reducing_dof/#Introduction","page":"Reducing DoF","title":"Introduction","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Why-reduce-the-degrees-of-freedom","page":"Reducing DoF","title":"Why reduce the degrees of freedom","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Reducing the degrees of freedom in a model, by forcing certain variables to measurements, can be useful for several reasons:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It can prevent overfitting by constraining the model and making it less complex.\nIt can help to better calibrate the other components of the model by reducing the co-variability of the variables (see Parameter degeneracy).\nIt can lead to more interpretable models by identifying the most important variables and relationships.\nIt can improve the computational efficiency of the model by reducing the number of variables that need to be estimated.\nIt can also help to ensure that the model is consistent with known physical or observational constraints and improve the credibility of the model and its predictions.\nIt is important to note that over-constraining a model can also lead to poor fits and false conclusions, so it is essential to carefully consider which variables to constrain and to what measurements.","category":"page"},{"location":"working_with_data/reducing_dof/#Parameter-degeneracy","page":"Reducing DoF","title":"Parameter degeneracy","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"The concept of \"degeneracy\" or \"parameter degeneracy\" in a model occurs when two or more variables in a model are highly correlated, and small changes in one variable can be compensated by small changes in another variable, so that the overall predictions of the model remain unchanged. Degeneracy can make it difficult to estimate the true values of the variables and to determine the unique solutions of the model. It also makes the model sensitive to the initial conditions (e.g. the parameters) and the optimization algorithm used.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Degeneracy is related to the concept of \"co-variability\" or \"collinearity\", which refers to the degree of linear relationship between two or more variables. In a degenerate model, two or more variables are highly co-variate, meaning that they are highly correlated and can produce similar predictions. By fixing one variable to a measured value, the model will have less flexibility to adjust the other variables, which can help to reduce the co-variability and improve the robustness of the model.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"This is an important topic in plant/crop modelling, as the models are very often degenerate. It is most often referred to as \"multicollinearity\" in the field. In the context of model calibration, it is also known as \"parameter degeneracy\" or \"parameter collinearity\". In the context of model reduction, it is also known as \"redundancy\" or \"redundant variables\".","category":"page"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF-in-PlantSimEngine","page":"Reducing DoF","title":"Reducing the DoF in PlantSimEngine","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Soft-coupled-models","page":"Reducing DoF","title":"Soft-coupled models","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"PlantSimEngine provides a simple way to reduce the degrees of freedom in a model by constraining the values of some variables to measurements.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's define a model list as usual with the seven processes from examples/dummy.jl:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's say that m is our complete model, and that we want to reduce the degrees of freedom by constraining the value of var9 to a measurement, which was previously computed by Process7Model, a soft-dependency model. It is very easy to do this in PlantSimEngine: just remove the model from the model list and give the value of the measurement in the status:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nout = run!(m2, meteo)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"And that's it ! The models that depend on var9 will now use the measured value of var9 instead of the one computed by Process7Model.","category":"page"},{"location":"working_with_data/reducing_dof/#Hard-coupled-models","page":"Reducing DoF","title":"Hard-coupled models","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It is a bit more complicated to reduce the degrees of freedom in a model that is hard-coupled to another model, because it calls the run! method of the other model.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"In this case, we need to replace the old model with a new model that forces the value of the variable to the measurement. This is done by giving the measurements as inputs of the new model, and returning nothing so the value is unchanged. ","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Starting from the model list with the seven processes from above, but this time let's say that we want to reduce the degrees of freedom by constraining the value of var3 to a measurement, which was previously computed by Process1Model, a hard-dependency model. It is very easy to do this in PlantSimEngine: just replace the model by a new model that forces the value of var3 to the measurement:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"struct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Now we can create a new model list with the new model for process7:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nout = run!(m3, meteo)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"note: Note\nWe could also eventually provide the measured variable using the meteo data, but it is not recommended. The meteo data is meant to be used for the meteo variables only, and not for the model variables. It is better to use the status for that.","category":"page"},{"location":"API/API_public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"API/API_public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"Pages = [\"API_public.md\"]","category":"page"},{"location":"API/API_public/#API-documentation","page":"Public API","title":"API documentation","text":"","category":"section"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/API_public/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"Public API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.AbstractModel","page":"Public API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.ModelList","page":"Public API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> outputs_sim = run!(models,meteo)\nTimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):\n╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮\n│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │\n╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯\n\njulia> outputs_sim[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.MultiScaleModel","page":"Public API","title":"PlantSimEngine.MultiScaleModel","text":"MultiScaleModel(model, mapped_variables)\n\nA structure to make a model multi-scale. It defines a mapping between the variables of a  model and the nodes symbols from which the values are taken from.\n\nArguments\n\nmodel<:AbstractModel: the model to make multi-scale\nmapped_variables<:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}: a vector of pairs of symbols and strings or vectors of strings\n\nThe mapped_variables argument can be of the form:\n\n[:variable_name => \"Plant\"]: We take one value from the Plant node\n[:variable_name => [\"Leaf\"]]: We take a vector of values from the Leaf nodes\n[:variable_name => [\"Leaf\", \"Internode\"]]: We take a vector of values from the Leaf and Internode nodes\n[:variable_name => \"Plant\" => :variable_name_in_plant_scale]: We take one value from another variable name in the Plant node\n[:variable_name => [\"Leaf\" => :variable_name_1, \"Internode\" => :variable_name_2]]: We take a vector of values from the Leaf and Internode nodes with different names\n[PreviousTimeStep(:variable_name) => ...]: We flag the variable to be initialized with the value from the previous time step, and we do not use it to build the dep graph\n[:variable_name => :variable_name_from_another_model]: We take the value from another model at the same scale but rename it\n[PreviousTimeStep(:variable_name),]: We just flag the variable as a PreviousTimeStep to not use it to build the dep graph\n\nDetails about the different forms:\n\nThe variable variable_name of the model will be taken from the Plant node, assuming only one node has the Plant symbol.\n\nIn this case the value available from the status will be a scalar, and so the user must guaranty that only one node of type Plant is available in the MTG.\n\nThe variable variable_name of the model will be taken from the Leaf nodes. Notice it is given as a vector, indicating that the values will be taken \n\nfrom all the nodes of type Leaf. The model should be able to handle a vector of values. Note that even if there is only one node of type Leaf, the value will be taken as a vector of one element.\n\nThe variable variable_name of the model will be taken from the Leaf and Internode nodes. The values will be taken from all the nodes of type Leaf \n\nand Internode.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_in_plant_scale in the Plant node. This is useful\n\nwhen the variable name in the model is different from the variable name in the scale it is taken from.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_1 in the Leaf node and variable_name_2 in the Internode node.\nThe variable variable_name of the model uses the value computed on the previous time-step. This implies that the variable is not used to build the dependency graph\n\nbecause the dependency graph only applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe variable variable_name of the model will be taken from another model at the same scale, but with another variable name.\nThe variable variable_name of the model is just flagged as a PreviousTimeStep variable, so it is not used to build the dependency graph.\n\nNote that the mapping does not make any copy of the values, it only references them. This means that if the values are updated in the status of one node, they will be updated in the other nodes.\n\nExamples\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\nLet's take a model:\n\njulia> model = ToyCAllocationModel()\nToyCAllocationModel()\n\nWe can make it multi-scale by defining a mapping between the variables of the model and the nodes symbols from which the values are taken from:\n\nFor example, if the carbon_allocation comes from the Leaf and Internode nodes, we can define the mapping as follows:\n\njulia> mapped_variables=[:carbon_allocation => [\"Leaf\", \"Internode\"]]\n1-element Vector{Pair{Symbol, Vector{String}}}:\n :carbon_allocation => [\"Leaf\", \"Internode\"]\n\nThe mappedvariables argument is a vector of pairs of symbols and strings or vectors of strings. In this case, we have only one pair to define the mapping between the `carbonallocationvariable and theLeafandInternode` nodes.\n\nWe can now make the model multi-scale by passing the model and the mapped variables to the MultiScaleModel constructor :\n\njulia> multiscale_model = PlantSimEngine.MultiScaleModel(model, mapped_variables)\nMultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]])\n\nWe can access the mapped variables and the model:\n\njulia> PlantSimEngine.mapped_variables_(multiscale_model)\n1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:\n :carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]\n\njulia> PlantSimEngine.model_(multiscale_model)\nToyCAllocationModel()\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.PreviousTimeStep","page":"Public API","title":"PlantSimEngine.PreviousTimeStep","text":"PreviousTimeStep(variable)\n\nA structure to manually flag a variable in a model to use the value computed on the previous time-step.  This implies that the variable is not used to build the dependency graph because the dependency graph only  applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe process is added when building the MultiScaleModel, to avoid conflicts between processes with the same variable name. For exemple one process can define a variable :carbon_biomass as a PreviousTimeStep, but the othe process would use  the variable as a dependency for the current time-step (and it would be fine because theyr don't share the same issue of cyclic dependency).\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Status","page":"Public API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> using PlantSimEngine\n\njulia> st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Rₛ]\n13.747\n\njulia> st.Rₛ\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Rₛ] = 20.0\n20.0\n\njulia> st.Rₛ = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.EF-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}","page":"Public API","title":"PlantSimEngine.add_organ!","text":"add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)\n\nAdd an organ to the graph, automatically taking care of initialising the status of the organ (multiscale-)variables.\n\nThis function should be called from a model that implements organ emergence, for example in function of thermal time.\n\nArguments\n\nnode: the node to which the organ is added (the parent organ of the new organ)\nsim_object: the simulation object, e.g. the GraphSimulation object from the extra argument of a model.\nlink: the link type between the new node and the organ:\n\"<\": the new node is following the parent organ\n\"+\": the new node is branching the parent organ\n\"/\": the new node is decomposing the parent organ, i.e. we change scale\nsymbol: the symbol of the organ, e.g. \"Leaf\"\nscale: the scale of the organ, e.g. 2.\nindex: the index of the organ, e.g. 1. The index may be used to easily identify branching order, or growth unit index on the axis. It is different from the node id that is unique.\nid: the unique id of the new node. If not provided, a new id is generated.\nattributes: the attributes of the new node. If not provided, an empty dictionary is used.\ncheck: a boolean indicating if variables initialisation should be checked. Passed to init_node_status!.\n\nReturns\n\nstatus: the status of the new node\n\nExamples\n\nSee the ToyInternodeEmergence example model from the Examples module (also found in the examples folder), or the test-mtg-dynamic.jl test file for an example usage.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.convert_outputs-Tuple{Dict{String}, Any}","page":"Public API","title":"PlantSimEngine.convert_outputs","text":"convert_outputs(sim_outputs::Dict{String,O} where O, sink; refvectors=false, no_value=nothing)\nconvert_outputs(sim_outputs::TimeStepTable{T} where T, sink)\n\nConvert the outputs returned by a simulation made on a plant graph into another format.\n\nDetails\n\nThe first method operates on the outputs of a multiscale simulation, the second one on those of a typical single-scale simulation.  The sink function determines the format used, for exemple a DataFrame.\n\nArguments\n\nsim_outputs : the outputs of a prior simulation, typically returned byrun!`.\nsink: a sink compatible with the Tables.jl interface (e.g. a DataFrame)\nrefvectors: if false (default), the function will remove the RefVector values, otherwise it will keep them\nno_value: the value to replace nothing values. Default is nothing. Usually used to replace nothing values \n\nby missing in DataFrames.\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph, DataFrames, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nmapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), )\n\nmtg = import_mtg_example();\n\nout = run!(mtg, mapping, meteo, tracked_outputs = Dict(\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :soil_water_content, :carbon_allocation),\n    \"Internode\" => (:carbon_allocation,),\n    \"Plant\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n));\n\nconvert_outputs(out, DataFrames)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.dep","page":"Public API","title":"PlantSimEngine.dep","text":"dep(m::ModelList, nsteps=1; verbose::Bool=true)\ndep(mapping::Dict{String,T}; verbose=true)\n\nGet the model dependency graph given a ModelList or a multiscale model mapping. If one graph is returned,  then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph. It is set to 1 in the case of a  multiscale mapping.\n\nDetails\n\nThe dependency graph is computed by searching the inputs of each process in the outputs of its own scale, or the other scales. There are five cases for every model (one model simulates one process):\n\nThe process has no inputs. It is completely independent, and is placed as one of the roots of the dependency graph.\nThe process needs inputs from models at its own scale. We put it as a child of this other process.\nThe process needs inputs from another scale. We put it as a child of this process at another scale.\nThe process needs inputs from its own scale and another scale. We put it as a child of both.\nThe process is a hard dependency of another process (only possible at the same scale). In this case, the process is set as a hard-dependency of the \n\nother process, and its simulation is handled directly from this process.\n\nFor the 4th case, the process have two parent processes. This is OK because the process will only be computed once during simulation as we check if both  parents were run before running the process. \n\nNote that in the 5th case, we still need to check if a variable is needed from another scale. In this case, the parent node is  used as a child of the process at the other scale. Note there can be several levels of hard dependency graph, so this is done recursively.\n\nHow do we do all that? We identify the hard dependencies first. Then we link the inputs/outputs of the hard dependencies roots  to other scales if needed. Then we transform all these nodes into soft dependencies, that we put into a Dict of Scale => Dict(process => SoftDependencyNode). Then we traverse all these and we set nodes that need outputs from other nodes as inputs as children/parents. If a node has no dependency, it is set as a root node and pushed into a new Dict (independantprocessroot). This Dict is the returned dependency graph. And  it presents root nodes as independent starting points for the sub-graphs, which are the models that are coupled together. We can then traverse each of  these graphs independently to retrieve the models that are coupled together, in the right order of execution.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nmodels = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;models...)\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.dr-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.fit","page":"Public API","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/Beer.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of PPFD, LAI  and Ri_PAR_f. \n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated PPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"Public API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(mapping::Dict{String,T})\n\nGet the inputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"Public API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(mapping::Dict{String,T})\n\nGet the outputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.run!","page":"Public API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\nrun!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or a plant graph (MTG).\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters, not available for simulation of plant graphs (the simulation object is passed using this).\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nmapping: a mapping between the MTG and the model list.\nnsteps: the number of time-steps to run, only needed if no meteo is given (else it is infered from it).\noutputs: the outputs to get in dynamic for each node type of the MTG.\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nUsers can ask for parallel execution by providing a compatible executor to the executor argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the Examples sub-module:\n\njulia> using PlantSimEngine.Examples;\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> outputs_sim = run!(models, meteo);\n\nGet the results:\n\njulia> (outputs_sim[:var4],outputs_sim[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.status-Tuple{Any}","page":"Public API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including example models and processes:\nusing PlantSimEngine.Examples;\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"Public API","title":"PlantSimEngine.to_initialize","text":"to_initialize(; verbose=true, vars...)\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\nto_initialize(mapping::Dict{String,T}, graph=nothing)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nArguments\n\nverbose: if true, print information messages.\nvars...: the models and processes to consider.\nm::T: a ModelList.\nm::DependencyGraph: a DependencyGraph.\nmapping::Dict{String,T}: a mapping that associates models to organs.\ngraph: a graph representing a plant or a scene, e.g. a multiscale tree graph. The graph is used to check if variables that are not initialized can be found in the graph nodes attributes.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\nto_initialize(m)\n\nOr with a mapping:\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmapping = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"Internode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\nto_initialize(mapping)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Tuple{Module}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.variables","text":"variables(mapping::Dict{String,T})\n\nGet the variables (inputs and outputs) of the models in a mapping, for each  process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"Public API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nNewcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of AbstractModel:\n\nabstract type MyNewProcess <: AbstractModel end\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"multiscale/multiscale_example_4/#Visualizing-a-plant","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing a plant","text":"","category":"section"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"We've created our toy plant, part of the fun is to actually visualize it !","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"Let's see how to do so with the PlantGeom companion package.","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"We'll be reusing the mtg from part 3 of the plant tutorial: Fixing bugs in the plant simulation, so you need to run that simulation first.","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"You'll need to add PlantGeom and a compatible visualization package to your environment. We'll use Plots:","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"using Plots\nusing PlantGeom\n\nRecipesBase.plot(mtg)","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"This provides the following visualization: (Image: MTG Plots visualization)","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"And that's it !","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"We can see the root expansion in one direction, and the internodes with their leaves in the other.","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"You can find other examples with PlantGeom and other backends such as CairoMakie here","category":"page"},{"location":"multiscale/multiscale_example_4/","page":"Visualizing our toy plant with PlantGeom","title":"Visualizing our toy plant with PlantGeom","text":"note: Note\nThis is just a quick visualization, with no 3D, and little control over parameters. There's a lot more that can be done with PlantGeom (and more to come on the roadmap), which we might showcase later.","category":"page"},{"location":"step_by_step/detailed_first_example/#Detailed-walkthrough-of-a-simple-simulation","page":"Detailed first simulation","title":"Detailed walkthrough of a simple simulation","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"This page walks you through the ins and outs of a basic simulation, mostly aimed at people who have less experience programming, to showcase the various concepts presented earlier and requirements for a simulation in context.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A working trimmed-down script can be found further down in the Example simulation, and other subsections in this page will detail setup and helper functions, and querying outputs.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"If you simply wish to copy-paste examples and tinker with them, you can find a few examples on the Quick examples page.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout_sim = run!(leaf, meteo)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Pages = [\"detailed_first_example.md\"]\nDepth = 3","category":"page"},{"location":"step_by_step/detailed_first_example/#Definitions","page":"Detailed first simulation","title":"Definitions","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/#Processes","page":"Detailed first simulation","title":"Processes","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A process is \"declared\", meaning we define a process, and then implement models for its simulation. In this example, we will make use of a process that was already defined, and for which there already is a model implementation.","category":"page"},{"location":"step_by_step/detailed_first_example/#Models-(ModelList)","page":"Detailed first simulation","title":"Models (ModelList)","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/Beer.jl.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Models can use several types of entries:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Parameters are constant values that are used by the model to compute its outputs, and are exclusive to that model. ","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Meteorological information contains values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. ","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Variables are either used or computed by the model and can optionally be initialized before the simulation. They can be part of multiple models, computed by one and then used as an input by another. They can also be a global simulation output, or be provided at the start of a simulation by the user. ","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Constants are constant values, usually common between models, e.g. the universal gas constant. ","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"And extras are just extra values that can be used by a model.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Users declare a set of models used for simulation, as well as the necessary parameters for each model, and whatever variables need to be initialized. This is done using a ModelList structure. ","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"For example let's instantiate a ModelList with a single model : the Beer-Lambert model of light extinction, used to simulate the light interception process. The model is implemented with the Beer structure and only has one parameter: the extinction coefficient (k).","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Importing the package:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using PlantSimEngine","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Import the examples defined in the Examples sub-module (light_interception and Beer):","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using PlantSimEngine.Examples","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"And then declare a ModelList with the Beer model:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"m = ModelList(Beer(0.5))","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"What happened here? We provided an instance of the Beer model to a ModelList to simulate the light interception process.","category":"page"},{"location":"step_by_step/detailed_first_example/#Parameters","page":"Detailed first simulation","title":"Parameters","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A parameter is a value constant for a simulation that is internal to a model and used for its computations. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer structure in the Beer-Lambert model implementation,  only has one field: k. We can see that using fieldnames on the model structure:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"fieldnames(Beer)","category":"page"},{"location":"step_by_step/detailed_first_example/#Variables-(inputs,-outputs)","page":"Detailed first simulation","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Variables are either inputs or outputs (i.e. computed) of models. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"For example, the Beer model needs the leaf area index (LAI, m² m⁻²) to run.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"We can see which variables are passed in as inputs using inputs:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"inputs(Beer(0.5))","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"and which are computed outputs of the model using outputs:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"outputs(Beer(0.5))","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The ModelList structure will keep track of every variable's current state when running the simulation, storing them in a field called status. We can inspect that field with the status function and see that in our example it has two variables: LAI and PPFD. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"m = ModelList(Beer(0.5))\nkeys(status(m))","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"m = ModelList(Beer(0.5))\nto_initialize(m)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"(m[:LAI], m[:aPPFD])","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Uninitialized variables are initialized to the value given in the inputs or outputs methods in the model's implementation code, which is usually equal to typemin(), e.g. -Inf for Float64.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns every variable that is needed by the model to run, but in multi-model simulations, some of them may already be computed by other models and not require initialization. to_initialize returns only the variables that are needed by the model to run and that are not initialized in the ModelList.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"We can initialize the required variables by providing their starting values to the status when declaring the ModelList:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"m = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Or after instantiation using init_status!:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"m = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"is_initialized(m)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Some variables are inputs of models, but outputs of other models. When we couple models, to_initialize only requests the variables that are not computed by other models.","category":"page"},{"location":"step_by_step/detailed_first_example/#Climate-forcing","page":"Detailed first simulation","title":"Climate forcing","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). In our example, we also need the incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"This meteo variable will therefore provide a single weather timeframe that can be used in a simulation.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"More details are available from the package documentation.","category":"page"},{"location":"step_by_step/detailed_first_example/#Simulation","page":"Detailed first simulation","title":"Simulation","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/#Simulation-of-processes","page":"Detailed first simulation","title":"Simulation of processes","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"To run a simulation, you can call the run! method on the ModelList](@ref). If some meteorological data is required for models to be simulated over several timesteps, that can be passed in as an optional argument as well.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Your call to the function would then look like this:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"run!(model_list, meteo)","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The ModelList should already be initialized for the given process before calling the function. Refer to the earlier subsection Variables (inputs, outputs) for more details.","category":"page"},{"location":"step_by_step/detailed_first_example/#Example-simulation","page":"Detailed first simulation","title":"Example simulation","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"For example we can simulate the light_interception of a leaf like so:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using PlantSimEngine, PlantMeteo\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\noutputs_example = run!(leaf, meteo)\n\noutputs_example[:aPPFD]","category":"page"},{"location":"step_by_step/detailed_first_example/#Outputs","page":"Detailed first simulation","title":"Outputs","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract outputs of the very last timestep of a simulation using the status function.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"The actual full output data is returned by the run! function. Data is usually stored in a TimeStepTable structure from PlantMeteo.jl, which is a fast DataFrame-like structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"In our example, the simulation was only provided one weather timestep, so the outputs returned by run! and the ModelList's status field are identical.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Let's look at the outputs structure of our previous simulated leaf:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"outputs_example","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"We can extract the value of one variable by indexing into it, e.g. for the intercepted light:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"outputs_example[:aPPFD]","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Or similarly using the dot syntax:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"outputs_example.aPPFD","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"You can then print the outputs, convert them to another format, or visualize them, using other Julia packages. You can read more on how to do that in the Visualizing outputs and data page.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"Another convenient way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"using DataFrames\nconvert_outputs(outputs_example, DataFrame)","category":"page"},{"location":"step_by_step/detailed_first_example/#Model-coupling","page":"Detailed first simulation","title":"Model coupling","text":"","category":"section"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"step_by_step/detailed_first_example/","page":"Detailed first simulation","title":"Detailed first simulation","text":"PlantSimEngine.jl is designed to make model coupling painless for modelers and users. Please see Standard model coupling and Coupling more complex models for more details, or Handling dependencies in a multiscale context for multi-scale specific coupling considerations.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This page summarizes some of the assumptions, coupling constraints and inner workings of PlantSimEngine which may be particular relevant when implementing new models.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"If you are unsure of an implementation subtlety, check this page out to see whether it answers your question.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Pages = [\"implicit_contracts.md\"]\nDepth = 2","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-provides-the-simulation-timestep,-but-models-can-veer-away-from-it","page":"Implicit contracts","title":"Weather data provides the simulation timestep, but models can veer away from it","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"The weather data timesteps, whether hourly or daily, provide the pace at which most other models run.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"In XPalm, weather data for most models is provided daily, meaning biomass calculations are also provided daily. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Many models are considered to be steady-state over that timeframe, but not all : the leaf pruning model pertubes the plant in a non-steady state fashion, for example. Models that require computations over several iterations to stabilise (often part of hard dependencies) might also have a timestep unrelated to the weather data.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"!!! Note     Implicitely, this means any vector variables given as input to the simulation must be consistent with the number of weather timesteps. Providing one weather value but a larger vector variable is an exception : the weather data is replicated over each timestep. (This may be subject to change in the future when support for different timesteps in a single simulation is implemented)","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-must-be-interpolated-prior-to-simulation","page":"Implicit contracts","title":"Weather data must be interpolated prior to simulation","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"If your weather data isn't adjusted to conform to a regular timestep, you will need to adjust it to fit that constraint. PlantSimEngine does no interpolation prior to simulation and expects regular weather timesteps.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-cyclic-dependencies-in-the-simplified-dependency-graph","page":"Implicit contracts","title":"No cyclic dependencies in the simplified dependency graph","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"The model dependency graph used for running the simulation is comprised of soft and hard dependency nodes, and the final version only links soft dependency nodes together, and is expected to contain no cycles.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Any user model coupling which causes a cyclic dependency to occur will require some extra tinkering to run : either design models differently, create a hard dependency with some of the problematic models, or break the cycle by having a variable take the previous timestep's value as input.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"See Dependency graphs and the following subsections for more discussion related to dependency graph constraints.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Note : Only the previous timestep is accessible in PlantSimEngine without any kind of dedicated model. How to create a model to store more past timesteps of a specific variable is described in the Tips and workarounds page: Making use of past states in multi-scale simulations","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-need-to-be-declared-in-the-model-definition","page":"Implicit contracts","title":"Hard dependencies need to be declared in the model definition","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Hard dependencies are handled internally by their owning soft dependency model, ie the hard dep's run! function is directly called by the soft dependency's run!.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"The current way in which PlantSimEngine creates its dependency graph requires users to declare what process is required in the hard dependency and which scale it pulls the model and its variables from.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Parallelisation-opportunities-must-be-part-of-the-model-definition","page":"Implicit contracts","title":"Parallelisation opportunities must be part of the model definition","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Traits that indicate that a model is independent or objects need to be part of the model definition. Modelers need to keep this in mind when implementing new models.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This is currently mostly a concern for single-scale simulations, as multi-scale simulations are not currently parallelised ; a more involved scheduler would need to be implemented when MTGs are modified by models, and to handle more interesting parallelisation opportunities at specific scales. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"There may be new parallelisation features for multi-plant simulations further down the road.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-can-only-have-one-parent-in-the-dependency-graph","page":"Implicit contracts","title":"Hard dependencies can only have one parent in the dependency graph","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"The final dependency graph is comprised only of soft dependency nodes, and is guaranteed to contain no cycles. Hard dependencies are handled internally by their soft dependency ancestor. To avoid any ambiguity in terms of processing order, only one soft dependency node can 'own' a hard dependency And similarly, nested hard dependencies only have a single soft dependency ancestor.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This is not solely an implementation detail of PlantSimEngine's internal mechanisms ; if your simulation requires complex coupling, you might need to carefully consider how to manage your hard dependencies, or insert an extra intermediate model to simplify things.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#A-model-can-only-be-used-once-per-scale","page":"Implicit contracts","title":"A model can only be used once per scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Similarly, to avoid depedency graph ambiguity (and for simulation cohesion), PlantSimEngine currently assumes a model describing a process only occurs once per scale.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"Model renaming and duplicating works around this assumption. It may change once multi-plant/multi-species features are implemented.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-two-variables-with-the-same-name-at-the-same-scale","page":"Implicit contracts","title":"No two variables with the same name at the same scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This rule avoids potential ambiguity which could then cause both problems in terms of model ordering during the simulation, as well as incorrectly coupling models with the wrong variable.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"A workaround for some of the situations where this occurs is described here : Having a variable simultaneously as input and output of a model","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#TODO-Organs-missing-in-the-MTG-but-declared-in-the-mapping-?","page":"Implicit contracts","title":"TODO Organs missing in the MTG but declared in the mapping ?","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Status-template-intialisation-order-TODO","page":"Implicit contracts","title":"Status template intialisation order TODO","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#TODO-simulation-order,-node-order,-etc.","page":"Implicit contracts","title":"TODO simulation order, node order, etc.","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Simulation-order-instability-when-adding-models","page":"Implicit contracts","title":"Simulation order instability when adding models","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"An important aspect to bear in mind is that PlantSimEngine automatically determines an order in which models are run from the dependency graph it generates by coupling models together. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This order of simulation depends on the way the models link together. If you replace a model by a new set of models, or pass in new variables that create new links between models, you may change the simulation order.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"When iterating and slowly making a simulation more physiologically realistic and complex, it is therefore fully possible that the order in which two models are run is flipped by a user change. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"Implicit contracts","title":"Implicit contracts","text":"This design choice implementation -a concession made for ease of use and flexibility when developing a simulation- means that until your set of models is fully stabilized and you know which variables are PreviousTimestep and what order models run in, as you expand and change the set you might see differences of execution of one timestep for some models. It isn't a conceptual problem as most models are steady-state, and simulation order is stable for a given set of models, but it does mean PlantSimEngine will be less conveient for some types of simulation.","category":"page"},{"location":"multiscale/single_to_multiscale/#Converting-a-single-scale-simulation-to-multi-scale","page":"Converting a simulation to multi-scale","title":"Converting a single-scale simulation to multi-scale","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"using PlantMeteo\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\nusing DataFrames\nusing MultiScaleTreeGraph\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"A single-scale simulation can be turned into a 'pseudo-multi-scale' simulation by providing a simple multi-scale tree graph, and declaring a mapping linking all models to a unique scale level.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"This page showcases how to do the conversion, and then adds a model at a new scale to make the simulation genuinely multi-scale.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"The full script for the example can be found in [https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToySingleToMultiScale.jl]","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Pages = [\"single_to_multiscale.md\"]\nDepth = 3","category":"page"},{"location":"multiscale/single_to_multiscale/#Converting-the-ModelList-to-a-multi-scale-mapping","page":"Converting a simulation to multi-scale","title":"Converting the ModelList to a multi-scale mapping","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"For example, let's return to the ModelList coupling a light interception model, a Leaf Area Index model, and a carbon biomass increment model that was discussed in the Model switching subsection: ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"using PlantMeteo\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Those models all operate on a simplified model of a single plant, without any organ-local information. We can therefore consider them to be working at the 'whole plant' scale. Their variables also operate at that \"plant\" scale, so there is no need to map any variable to other scales.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We can therefore convert this into the following mapping : ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"mapping = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Note the slight difference in syntax for the Status. This is due to an implementation quirk (sorry).","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"None of these models operate on a multi-scale tree graph, either. There is no concept of organ creation or growth. We still need to provide a multi-scale tree graph to a multi-scale simulation, so we can -for now- declare a very simple MTG, with a single node:","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"using MultiScaleTreeGraph\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"note: Note\nYou will need to add the MultiScaleTreeGraph package to your environment. See Installing and running PlantSimEngine if you are not yet comfortable with Julia.","category":"page"},{"location":"multiscale/single_to_multiscale/#Running-the-multi-scale-simulation-?","page":"Converting a simulation to multi-scale","title":"Running the multi-scale simulation ?","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We now have almost everything we need to run the multiscale simulation.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"This first conversion step can be a starting point for a more elaborate multi-scale simulation. ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"The signature of the run! function in multi-scale differs slightly from the ModelList version : ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"out_multiscale = run!(mtg, mapping, meteo_day)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"(Some of the optional arguments also change slightly)","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Unfortunately, there is one caveat. Passing in a vector through the Status field is still possible in multi-scale mode, but requires a little more advanced tinkering with the mapping, as it generates a custom model under the hood and the implementation is experimental and less user-friendly.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"If you are keen on going down that path, you can find a detailed example here, but we don't recommend it for beginners.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"What we'll do instead, is write our own model provide the thermal time per timestep as a variable, instead of as a single vector in the Status.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Our 'pseudo-multiscale' first approach will therefore turn into a genuine multi-scale simulation.","category":"page"},{"location":"multiscale/single_to_multiscale/#Adding-a-second-scale","page":"Converting a simulation to multi-scale","title":"Adding a second scale","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Let's have a model provide the Cumulated Thermal Time to our Leaf Area Index model, instead of initializing it through the Status. ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Let's instead implement our own ToyTT_cuModel.","category":"page"},{"location":"multiscale/single_to_multiscale/#TT_cu-model-implementation","page":"Converting a simulation to multi-scale","title":"TT_cu model implementation","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"This model doesn't require any outside data or input variables, it only operates on the weather data and outputs our desired TT_cu. The implementation doesn't require any advanced coupling and is very straightforward.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"PlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel\nend\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # No input variables\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"note: Note\nThe only accessible variables in the run! function via the status are the ones that are local to the \"Scene\" scale. This isn't explicit at first glance, but very important to keep in mind when developing models, or using them at different scales. If variables from other scales are required, then they need to be mapped via a MultiScaleModel, or sometimes a more complex coupling is necessary.","category":"page"},{"location":"multiscale/single_to_multiscale/#Linking-the-new-TT_cu-model-to-a-scale-in-the-mapping","page":"Converting a simulation to multi-scale","title":"Linking the new TT_cu model to a scale in the mapping","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We now have our model implementation. How does it fit into our mapping ?","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Our new model doesn't really relate to a specific organ of our plant. In fact, this model doesn't represent a physiological process of the plant, but rather an environmental process affecting its physiology. We could therefore have it operate at a different scale unrelated to the plant, which we'll call \"Scene\". This makes sense.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"Note that we now need to add a \"Scene\" node to our Multi-scale Tree Graph, otherwise our model will not run, since no other model calls it and \"Plant\" nodes will only call models at the \"Plant\" scale. See Empty status vectors in multi-scale simulations for more details.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"mtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))","category":"page"},{"location":"multiscale/single_to_multiscale/#Mapping-between-scales-:-the-MultiScaleModel-wrapper","page":"Converting a simulation to multi-scale","title":"Mapping between scales : the MultiScaleModel wrapper","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"The cumulated thermal time (:TT_cu) which was previously provided to the LAI model as a simulation parameter now needs to be mapped from the \"Scene\" scale level. ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"This is done by wrapping our ToyLAIModel in a dedicated structure called a MultiScaleModel. A MultiScaleModel requires two keyword arguments : model, indicating the model for which some variables are mapped, and mapped_variables, indicating which scale link to which variables, and potentially renaming them.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"There can be different kinds of variable mapping with slightly different syntax, but in our case, only a single scalar value of the TT_cu is passed from the \"Scene\" to the \"Plant\" scale.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"This gives us the following declaration with the [MultiScaleModel wrapper for our LAI model: ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        )","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"and the new mapping with two scales :","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"mapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)","category":"page"},{"location":"multiscale/single_to_multiscale/#Running-the-multi-scale-simulation","page":"Converting a simulation to multi-scale","title":"Running the multi-scale simulation","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We can then run the multiscale simulation, with our two-node MTG :","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"outputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)","category":"page"},{"location":"multiscale/single_to_multiscale/#Comparing-outputs-between-single-and-multi-scale","page":"Converting a simulation to multi-scale","title":"Comparing outputs between single- and multi-scale","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"The outputs structures are slightly different : multi-scale outputs are indexed by scale, and a variable has a value for every node of the scale it operates at (for instance, there would be a \"leaf_surface\" value for every leaf in a plant), stored in an array.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"In our simple example, we only have one MTG scene node and one plant node, so the arrays for each variable in the multi-scale output only contain one value.","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We can access the output variables at the \"Scene\" scale by indexing our outputs:","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"outputs_multiscale[\"Scene\"]","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"and then the computed :TT_cu:","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"outputs_multiscale[\"Scene\"][:TT_cu]","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"As you can see, it is a Vector{Vector{T}}, whereas our single-scale output is a Vector{T}:","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"outputs_singlescale.TT_cu","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"To compare them value-by-value, we can flatten the multiscale Vector and then do a piecewise approximate equality test :","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"computed_TT_cu_multiscale = collect(Base.Iterators.flatten(outputs_multiscale[\"Scene\"][:TT_cu]))\n\nfor i in 1:length(computed_TT_cu_multiscale)\n    if !(computed_TT_cu_multiscale[i] ≈ outputs_singlescale.TT_cu[i])\n        println(i)\n    end\nend","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"or equivalently, with broadcasting, we can write :","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"is_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"note: Note\nYou may be wondering why we check for approximate equality rather than strict equality. The reason for that is due to floating-point accumulation errors, which are discussed in more detail in Floating-point considerations.","category":"page"},{"location":"multiscale/single_to_multiscale/#ToyDegreeDaysCumulModel","page":"Converting a simulation to multi-scale","title":"ToyDegreeDaysCumulModel","text":"","category":"section"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"There is a model able to provide Thermal Time based on weather temperature data, ToyDegreeDaysCumulModel, which can also be found in the examples folder. ","category":"page"},{"location":"multiscale/single_to_multiscale/","page":"Converting a simulation to multi-scale","title":"Converting a simulation to multi-scale","text":"We didn't make use of it here for learning purposes. It also computes a thermal time based on default parameters that don't correspond to the thermal time in the example weather data, so results differ from the thermal time already present in the weather data without tinkering with the parameters. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nout = run!(model)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\nout2 = run!(model2, meteo_day)\n","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: Aqua QA) (Image: DOI) (Image: JOSS)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine is a comprehensive framework for building models of the soil-plant-atmosphere continuum. It includes everything you need to prototype, evaluate, test, and deploy plant/crop models at any scale, with a strong emphasis on performance and efficiency, so you can focus on building and refining your models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why choose PlantSimEngine?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplicity: Write less code, focus on your model's logic, and let the framework handle the rest.\nModularity: Each model component can be developed, tested, and improved independently. Assemble complex simulations by reusing pre-built, high-quality modules.\nStandardisation: Clear, enforceable guidelines ensure that all models adhere to best practices. This built-in consistency means that once you implement a model, it works seamlessly with others in the ecosystem.\nOptimised Performance: Don't re-invent the wheel. Delegating low-level tasks to PlantSimEngine guarantees that your model will benefit from every improvement in the framework. Enjoy faster prototyping, robust simulations, and efficient execution using Julia's high-performance capabilities.","category":"page"},{"location":"#Unique-Features","page":"Home","title":"Unique Features","text":"","category":"section"},{"location":"#Automatic-Model-Coupling","page":"Home","title":"Automatic Model Coupling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Seamless Integration: PlantSimEngine leverages Julia's multiple-dispatch capabilities to automatically compute the dependency graph between models. This allows researchers to effortlessly couple models without writing complex connection code or manually managing dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Intuitive Multi-Scale Support: The framework naturally handles models operating at different scales—from organelle to ecosystem—connecting them with minimal effort and maintaining consistency across scales.","category":"page"},{"location":"#Flexibility-with-Precision-Control","page":"Home","title":"Flexibility with Precision Control","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effortless Model Switching: Researchers can switch between different component models using a simple syntax without rewriting the underlying model code. This enables rapid comparison between different hypotheses and model versions, accelerating the scientific discovery process.","category":"page"},{"location":"#Batteries-included","page":"Home","title":"Batteries included","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Automated Management: Seamlessly handle inputs, outputs, time-steps, objects, and dependency resolution.\nIterative Development: Fast and interactive prototyping of models with built-in constraints to avoid errors and sensible defaults to streamline the model writing process.\nControl Your Degrees of Freedom: Fix variables to constant values or force to observations, use simpler models for specific processes to reduce complexity.\nHigh-Speed Computations: Achieve impressive performance with benchmarks showing operations in the 100th of nanoseconds range for complex models (see this benchmark script).\nParallelize and Distribute Computing: Out-of-the-box support for sequential, multi-threaded, or distributed computations over objects, time-steps, and independent processes, thanks to Floops.jl.\nScale Effortlessly: Methods for computing over objects, time-steps, and Multi-Scale Tree Graphs.\nCompose Freely: Use any types as inputs, including Unitful for unit propagation and MonteCarloMeasurements.jl for measurement error propagation.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine delivers impressive performance for plant modeling tasks. On an M1 MacBook Pro:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A toy model for leaf area over a year at daily time-scale took only 260 μs (about 688 ns per day)\nThe same model coupled to a light interception model took 275 μs (756 ns per day)","category":"page"},{"location":"","page":"Home","title":"Home","text":"These benchmarks demonstrate performance on par with compiled languages like Fortran or C, far outpacing typical interpreted language implementations. For example, PlantBiophysics.jl, which implements ecophysiological models using PlantSimEngine, has been measured to run up to 38,000 times faster than equivalent implementations in other scientific computing languages.","category":"page"},{"location":"#Ask-Questions","page":"Home","title":"Ask Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have any questions or feedback, open an issue or ask on discourse.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easy to use, and to help users avoid errors when implementing, coupling and simulating models.","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example of a model that simulates the growth of a plant, using a simple exponential growth model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine\nusing PlantSimEngine\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nout = run!(model) # run the model and extract its outputs","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note   The ToyLAIModel is available from the examples folder, and is a simple exponential growth model. It is used here for the sake of simplicity, but you can use any model you want, as long as it follows PlantSimEngine interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course you can plot the outputs quite easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add CairoMakie\nusing CairoMakie\n\nlines(out[:TT_cu], out[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Cumulated growing degree days since sowing (°C)\"))","category":"page"},{"location":"#Model-coupling","page":"Home","title":"Model coupling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Model coupling is done automatically by the package, and is based on the dependency graph between the models. To couple models, we just have to add them to the ModelList. For example, let's couple the ToyLAIModel with a model for light interception based on Beer's law:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nout2 = run!(model2, meteo_day)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ModelList couples the models by automatically computing the dependency graph of the models. The resulting dependency graph is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"╭──── Dependency graph ──────────────────────────────────────────╮\n│  ╭──── LAI_Dynamic ─────────────────────────────────────────╮  │\n│  │  ╭──── Main model ────────╮                              │  │\n│  │  │  Process: LAI_Dynamic  │                              │  │\n│  │  │  Model: ToyLAIModel    │                              │  │\n│  │  │  Dep: nothing          │                              │  │\n│  │  ╰────────────────────────╯                              │  │\n│  │                  │  ╭──── Soft-coupled model ─────────╮  │  │\n│  │                  │  │  Process: light_interception    │  │  │\n│  │                  └──│  Model: Beer                    │  │  │\n│  │                     │  Dep: (LAI_Dynamic = (:LAI,),)  │  │  │\n│  │                     ╰─────────────────────────────────╯  │  │\n│  ╰──────────────────────────────────────────────────────────╯  │\n╰────────────────────────────────────────────────────────────────╯","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can plot the results by indexing the outputs with the variable name (e.g. out2[:LAI]):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, out2[:TT_cu], out2[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, out2[:TT_cu], out2[:aPPFD], color=:firebrick1)\n\nfig","category":"page"},{"location":"#Multi-scale-modeling","page":"Home","title":"Multi-scale modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Multi-scale modeling section for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easily scalable, and can be used to simulate models at different scales. For example, you can simulate a model at the leaf scale, and then couple it with models at any other scale, e.g. internode, plant, soil, scene scales. Here's an example of a simple model that simulates plant growth using sub-models operating at different scales:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\"],\n        ),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        MultiScaleModel(\n            model=ToyInternodeEmergence(TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\"],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can import an example plant from the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mtg = import_mtg_example()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make a fake meteorological data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=300.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f=500.0)\n]\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"And run the simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"out_vars = Dict(\n    \"Scene\" => (:TT_cu,),\n    \"Plant\" => (:carbon_allocation, :carbon_assimilation, :soil_water_content, :aPPFD, :TT_cu, :LAI),\n    \"Leaf\" => (:carbon_demand, :carbon_allocation),\n    \"Internode\" => (:carbon_demand, :carbon_allocation),\n    \"Soil\" => (:soil_water_content,),\n)\n\nout = run!(mtg, mapping, meteo, tracked_outputs=out_vars, executor=SequentialEx());\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then extract the outputs in a DataFrame and sort them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames\ndf_out = convert_outputs(out, DataFrame)\nsort!(df_out, [:timestep, :node])","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example output of a multiscale simulation is shown in the documentation of PlantBiophysics.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Plant growth simulation)","category":"page"},{"location":"#State-of-the-field","page":"Home","title":"State of the field","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine is a state-of-the-art plant simulation software that offers significant advantages over existing tools such as OpenAlea, STICS, APSIM, or DSSAT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The use of Julia programming language in PlantSimEngine allows for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quick and easy prototyping compared to compiled languages\nSignificantly better performance than typical interpreted languages\nNo need for translation into another compiled language","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia's features enable PlantSimEngine to provide:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple-dispatch for automatic computation of model dependency graphs\nType stability for optimized performance\nSeamless compatibility with powerful tools like MultiScaleTreeGraph.jl for multi-scale computations","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine's approach streamlines the process of model development by automatically managing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Model coupling with automated dependency graph computation\nTime-steps and parallelization\nInput and output variables\nVarious types of objects used for simulations (vectors, dictionaries, multi-scale tree graphs)","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! 😃","category":"page"},{"location":"introduction/why_julia/#The-choice-of-using-Julia","page":"Why Julia ?","title":"The choice of using Julia","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine is implemented in Julia. It arose from a particular combination of needs and requirements that Julia addresses effectively.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Other modelling frameworks, FSPMs and crop models are -often- written in combinations of Java, C++, Python, or Fortran. Given that Julia isn't the language many researchers (and developers!) are most familiar with yet, this page provides a short explanation of the reasoning behind that language choice. Another nice resource is this discourse post by Alejandro Morales Sierra, the creator and maintainer of Virtual Plant Lab.","category":"page"},{"location":"introduction/why_julia/#From-research-to-real-world-applications","page":"Why Julia ?","title":"From research to real-world applications","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine was originally a goal-oriented framework. Its features arose -and continue to evolve- out of necessity for more and more complex simulation setups.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While PlantSimEngine primarily helps researchers prototype and test their models efficiently, we consistently work with the vision of making it suitable for real-world applications. Our goal is to build a bridge between academic plant modeling and practical field applications. Ideally, researchers should be able to develop and refine their models in a comfortable environment, and these models could eventually be deployed in production environments.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"This vision of dual-purpose functionality drives our focus on performance optimization. We aspire for the models you develop to be useful beyond academic papers, potentially serving reliably in production environments where efficiency and accuracy are crucial. Julia's strong performance characteristics support this vision in ways other languages would struggle to match.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine aims to balance scientific rigor with developer productivity, with the long-term goal of ensuring that models can be deployed at scale. Julia provides an environment where researchers can express complex mathematical concepts directly in code with good performance potential, creating a pathway for these models to potentially reach practical implementation.","category":"page"},{"location":"introduction/why_julia/#PlantSimEngine's-constraints","page":"Why Julia ?","title":"PlantSimEngine's constraints","text":"","category":"section"},{"location":"introduction/why_julia/#Performance","page":"Why Julia ?","title":"Performance","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While computers have gained several orders of magnitude of power and memory over the past few decades, to the point where many prior performance bottlenecks have vanished, performance can still be a limiting factor.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Simulating multiple processes with user-provided variables over many plants with tens of thousands of leaves requires a lot of computation. Using a higher-level language such as Python or R would not lead to adequate simulation times.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"In fact, part of the initial motivation to commit to Julia happened after porting a model from R to Julia and getting several orders of magnitude difference in performance 'out-of-the-box'. Seeing computations that previously took minutes suddenly completing in seconds was quite convincing (see also this benchmark showing a difference of 5 orders of magnitude).","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia, with its well-designed 'Just-ahead-of-time' compilation model and its flexibility allowing to do some lower-level optimisation, doesn't suffer from the limitations one would encounter by using only Python or R.","category":"page"},{"location":"introduction/why_julia/#Flexibility,-ease-of-use","page":"Why Julia ?","title":"Flexibility, ease of use","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine was also developed with a few goals in mind, one of them being to make hypothesis testing quite easy. It is currently difficult to validate FSPM, crop model or ecophysiological hypotheses in many existing frameworks due to their rigid structure or steep learning curve.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Similarly, when developing a full-featured FSPM, there might be a need to test different models for a specific process, or to switch a model for a more complex one. API and language ease of use is as much of a factor as automated model coupling in keeping these changes smooth.","category":"page"},{"location":"introduction/why_julia/#Packages-destined-to-be-used-by-a-wider-community","page":"Why Julia ?","title":"Packages destined to be used by a wider community","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"As mentioned earlier, PlantSimEngine is intended for a wide audience. Only few of them are expected to have a strong development background. Many other potential users might be researchers more well-versed in ecophysiology or plant architecture and only know a little bit of Python, Matlab or R. Reducing friction for these users is paramount.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Open-source libraries/packages, ease of installation and low entry barrier also factor in the decision.","category":"page"},{"location":"introduction/why_julia/#Modularity-and-flexibility-while-retaining-performance","page":"Why Julia ?","title":"Modularity and flexibility while retaining performance","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"One approach could be to combine, say, Python, with a more performant language such as C++ or Fortran. The slower but flexible language being used for prototyping, and when performance is required, some chunks are reimplmented in the other language.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"This fits the performance constraint, but has a few caveats.","category":"page"},{"location":"introduction/why_julia/#Low-developer-bandwidth","page":"Why Julia ?","title":"Low developer bandwidth","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"And of course, budget, time and resources are a concern. The more autonomous researchers and modelers are, and the less specialist developer/engineering resources are required, the easier it is for the project to keep evolving.","category":"page"},{"location":"introduction/why_julia/#Comparison","page":"Why Julia ?","title":"Comparison","text":"","category":"section"},{"location":"introduction/why_julia/#The-Two-Language-Problem","page":"Why Julia ?","title":"The Two-Language Problem","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Combining two different languages requires a lot of language expertise, with constant knowledge refreshing, as one might only occasionally work with and debug with the lower-level language. Or more engineering resources.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Speed of iteration is also lost whenever performance is a concern, which happens often in our context. However modular and easy-to-use a language like Python might be, whenever it's time to switch to a low-level language, development speed will slow down.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia effectively solves this problem. While it might be a little harder to learn than Python, and require extra knowledge to properly make use of its flexibility and performance capabilities, it leads to a smoother development experience.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Everything can be done using Julia exclusively, so there is no need to learn two languages. No need to interface between them. Iteration speed doesn't suddenly grind to a halt if a low-level implementation is needed. A competent researcher-developer can move seamlessly from prototype to production, while still being able to focus on modeling and the actual plant side of things.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"(Image: Language usage comparison for different ML packages (source: https://pde-on-gpu.vaw.ethz.ch/lecture1/)) (Language usage comparison for different ML packages; source: https://pde-on-gpu.vaw.ethz.ch/lecture1/)","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"It seems we aren't the only ones to find Julia a good tool for our job. Other niches where Julia is gaining traction tend to be other computationally heavy areas with much active research, such as machine learning and climate modeling - areas where this balance of expressivity and performance is equally valuable.","category":"page"},{"location":"introduction/why_julia/#A-good-balance-in-terms-of-accessibility","page":"Why Julia ?","title":"A good balance in terms of accessibility","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Another argument in favour of Julia is that one of the aims for PlantSimEngine is to be easy-to-use for researchers wishing to test hypothesis, or reproduce results from other papers. Scientific reproducibility is greatly enhanced when the barrier to running and modifying simulations is lowered.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Many researchers are not developers by trade or heart, and a Java-only or C++-only implementation, on top of the earlier points, would not be accessible enough and would not gain much traction.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia, while less ubiquitous than other languages in research circles, resembles Python and R and is more beginner-friendly than Java or C++. It is easier for a Python user to learn to use a simple Julia package than a C++ one.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Users will also find it easier to quickly implement new models without the potential hurdle of a low-level implementation, or some language interfacing also being required. The prototyping phase doesn't require a subsequent performance tuning phase.","category":"page"},{"location":"introduction/why_julia/#Ease-of-environment-setup","page":"Why Julia ?","title":"Ease of environment setup","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Similarly, Julia's language and package installation is -mostly- fairly straightforward and requires little additional knowledge.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"The package manager is built directly into the language, making dependency management straightforward. This is particularly important for reproducible scientific workflows, where consistent environments are crucial.","category":"page"},{"location":"introduction/why_julia/#Downsides-acceptable","page":"Why Julia ?","title":"Downsides acceptable","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While very practical for a 'researcher-developer', Julia is of course far from being the perfect language in every discipline. It is massive in terms of features, has a heavy runtime, is more involved to learn and master quickly compared to Python, has a few hurdles for beginners, some quirks that can be awkward for developers, tools that aren't fully mature, no clear 'recommended' workflow, and so on. ","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"The cost for switching may not be worth it in many other circumstances. However, several of these downsides, while very relevant for embedded systems, or game development, are much less relevant regarding PlantSimEngine. And others can be mitigated with, hopefully, adequate learning resources and documentation.","category":"page"},{"location":"introduction/why_julia/#Conclusion","page":"Why Julia ?","title":"Conclusion","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"For PlantSimEngine's specific requirements—balancing performance with flexibility, enabling rapid iteration while maintaining computational efficiency, and providing an accessible interface for both researchers and field practitioners—Julia represents a suitable choice. The language allows us to build an ecosystem where plant modeling can advance through collaborative, efficient, and scientifically rigorous development while delivering real-world value through production deployments.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While no language solution is perfect, Julia's combination of features makes it well-suited to the challenges of modern plant modeling and simulation, both in research and practical applications. We're optimistic about the possibilities it offers for the future of plant modeling.","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Model coupling for users","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls again run! inside its implementation at some point. Note that it does not force any kind of conductance model over another, just that there is one to simulate the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We provide an example script that implements seven dummy processes in examples/dummy. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model... ","category":"page"},{"location":"model_coupling/model_coupling_user/#Hard-coupled-models","page":"Model coupling for users","title":"Hard coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The Process3Model calls Process2Model, and Process2Model calls Process1Model. This explicit call is called a hard-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The other models for the other processes are called Process4Model, Process5Model... and they do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"tip: Tip\nHard-coupling of models is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is hard-coupled to a photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Back to our example, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's use the Examples sub-module so we can play around:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"tip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Here is how we can make the model coupling:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Note that the user only declares the models, not the way the models are coupled because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Now the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their hard or soft-coupling.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"For example, Process1Model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"inputs(Process1Model(2.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"And Process2Model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"inputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"outputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"So considering those two models, we only need var1 and var2 to be initialized, as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"page"},{"location":"model_coupling/model_coupling_user/#Soft-coupled-models","page":"Model coupling for users","title":"Soft coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"All following models (Process4Model to Process7Model) do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's make a new model list including the soft-coupled models:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"With this list of models, we only need to initialize var0, that is an input of Process4Model and Process7Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"to_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We can initialize it like so:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"model_coupling/model_coupling_user/#Simulation-order","page":"Model coupling for users","title":"Simulation order","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"When calling run!, the models are run in the right order using a dependency graph that is computed automatically based on the hard and soft dependencies of the models following a simple set of rules:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Independent models are run first. A model is independent if it can be run alone, or only using initializations. It is not dependent on any other model.\nFrom their children dependencies:\nHard dependencies are always run before soft dependencies. Inner hard dependency graphs are considered as a whole, i.e. as a single soft dependency.\nSoft dependencies are then run sequentially. If a soft dependency has several parent nodes (i.e. its inputs are computed by several models), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"}]
}
