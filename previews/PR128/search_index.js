var documenterSearchIndex = {"docs":
[{"location":"working_with_data/fitting/#Parameter-fitting","page":"Fitting","title":"Parameter fitting","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"working_with_data/fitting/#The-fit-method","page":"Fitting","title":"The fit method","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Models are often calibrated using data, but the calibration process is not always the same depending on the model, and the data available to the user.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"PlantSimEngine defines a generic fit function that allows modelers provide a fitting algorithm for their model, and for users to use this method to calibrate the model using data.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The function does nothing in this package, it is only defined to provide a common interface for all the models. It is up to the modeler to implement the method for their model. ","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The method is implemented as a function with the following design pattern: the call to the function should take the model type as the first argument (T::Type{<:AbstractModel}), the data as the second argument (as a Table.jl compatible type, such as DataFrame), and any more information as keyword arguments, e.g. constants or parameters initializations with default values when necessary.","category":"page"},{"location":"working_with_data/fitting/#Example-with-Beer","page":"Fitting","title":"Example with Beer","text":"","category":"section"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The example script (see src/examples/Beer.jl) that implements the Beer model provides an example of how to implement the fit method for a model:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"The function takes a Beer type as the first argument, the data as a Tables.jl compatible type, such as a DataFrame as the second argument, and the J_to_umol constant as a keyword argument, which is used to convert between μ mol m⁻² s⁻¹ and J m⁻² s⁻¹.","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"df should contain the columns PPFD (μ mol m⁻² s⁻¹), LAI (m² m⁻²) and Ri_PAR_f (W m⁻²). The function then computes k based on these values, and returns it as a NamedTuple of the form (parameter_name=parameter_value,).","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Here's an example of how to use the fit method:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Importing the script first: ","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Defining the meteo data:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Computing the PPFD values from the Ri_PAR_f values using the Beer model (with k=0.6):","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"m = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"Now we can define the \"data\" to fit the model using the simulated PPFD values:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"And finally we can fit the model using the fit method:","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"fit(Beer, df)","category":"page"},{"location":"working_with_data/fitting/","page":"Fitting","title":"Fitting","text":"note: Note\nThis is a dummy example to show that the fitting method works. A real application would fit the parameter values on the data directly.","category":"page"},{"location":"API/API_private/#API-internal-functions","page":"Internal API","title":"API - internal functions","text":"","category":"section"},{"location":"API/API_private/#Un-exported","page":"Internal API","title":"Un-exported","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat). Most of them are developer code, but some may be useful for tinkerers, or to have greater control over some simulation parameters (future versions of this documentation might break those categories into separate pages for clarity).","category":"page"},{"location":"API/API_private/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"API/API_private/#API-documentation","page":"Internal API","title":"API documentation","text":"","category":"section"},{"location":"API/API_private/","page":"Internal API","title":"Internal API","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"API/API_private/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"Internal API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:Status}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Current_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Current_TimestepModel","text":"basic_current_timestep process abstract model. \n\nAll models implemented to simulate the basic_current_timestep process must be a subtype of this type, e.g.  struct MyBasic_Current_TimestepModel <: AbstractBasic_Current_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Current_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractBasic_Next_TimestepModel","page":"Internal API","title":"PlantSimEngine.AbstractBasic_Next_TimestepModel","text":"basic_next_timestep process abstract model. \n\nAll models implemented to simulate the basic_next_timestep process must be a subtype of this type, e.g.  struct MyBasic_Next_TimestepModel <: AbstractBasic_Next_TimestepModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractBasic_Next_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.AbstractNodeMapping","page":"Internal API","title":"PlantSimEngine.AbstractNodeMapping","text":"AbstractNodeMapping\n\nAbstract type for the type of node mapping, e.g. single node mapping or multiple node mapping.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"Internal API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\nTreeAlike: The data is a tree-like object, e.g. a Node.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for GraphSimulation,  SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.DependencyGraph","page":"Internal API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.DependencyTrait","page":"Internal API","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\nReturns information about the eventual dependence of a model T to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.\n\nThe following dependence traits are supported:\n\nTimeStepDependencyTrait: Trait that defines whether a model can be parallelizable over time-steps for its computation.\nObjectDependencyTrait: Trait that defines whether a model can be parallelizable over objects for its computation.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.GraphSimulation","page":"Internal API","title":"PlantSimEngine.GraphSimulation","text":"GraphSimulation(graph, mapping)\nGraphSimulation(graph, statuses, dependency_graph, models, outputs)\n\nA type that holds all information for a simulation over a graph.\n\nArguments\n\ngraph: an graph, such as an MTG\nmapping: a dictionary of model mapping\nstatuses: a structure that defines the status of each node in the graph\nstatus_templates: a dictionary of status templates\nreverse_multiscale_mapping: a dictionary of mapping for other scales\nvar_need_init: a dictionary indicating if a variable needs to be initialized\ndependency_graph: the dependency graph of the models applied to the graph\nmodels: a dictionary of models\noutputs: a dictionary of outputs\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MappedVar","page":"Internal API","title":"PlantSimEngine.MappedVar","text":"MappedVar(source_organ, variable, source_variable, source_default)\n\nA variable mapped to another scale.\n\nArguments\n\nsource_organ: the organ(s) that are targeted by the mapping\nvariable: the name of the variable that is mapped\nsource_variable: the name of the variable from the source organ (the one that computes the variable)\nsource_default: the default value of the variable\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\nPlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.MultiNodeMapping","page":"Internal API","title":"PlantSimEngine.MultiNodeMapping","text":"MultiNodeMapping(scale)\n\nType for the multiple node mapping, e.g. [:carbon_assimilation => [\"Leaf\"],]. Note that \"Leaf\" is given as a vector, which means :carbon_assimilation will be a vector of values taken from each \"Leaf\" in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.ObjectDependencyTrait","page":"Internal API","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.\n\nThe following dependency traits are supported:\n\nIsObjectDependent: The model depends on other objects for its computation, it cannot be run in parallel.\nIsObjectIndependent: The model does not depend on other objects for its computation, it can be run in parallel.\n\nAll models are object dependent by default (i.e. IsObjectDependent). This is probably not right for the majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsObjectIndependent)\n\nIt is easy to override this trait for models that are object independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # false\n\nDefine a model that is object dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVariable","page":"Internal API","title":"PlantSimEngine.RefVariable","text":"RefVariable(reference_variable)\n\nA structure to manually flag a variable in a model to use the value of another variable at the same scale. This is used for variable renaming, when a variable is computed by a model but is used by another model with a different name.\n\nNote: we don't really rename the variable in the status (we need it for the other models), but we create a new one that is a reference to the first one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.RefVector","page":"Internal API","title":"PlantSimEngine.RefVector","text":"RefVector(field::Symbol, sts...)\nRefVector(field::Symbol, sts::Vector{<:Status})\nRefVector(v::Vector{Base.RefValue{T}})\n\nA vector of references to a field of a vector of structs. This is used to efficiently pass the values between scales.\n\nArguments\n\nfield: the field of the struct to reference\nsts...: the structs to reference\nsts::Vector{<:Status}: a vector of structs to reference\n\nExamples\n\njulia> using PlantSimEngine\n\nLet's take two Status structs:\n\njulia> status1 = Status(a = 1.0, b = 2.0, c = 3.0);\n\njulia> status2 = Status(a = 2.0, b = 3.0, c = 4.0);\n\nWe can make a RefVector of the field a of the structs st1 and st2:\n\njulia> rv = PlantSimEngine.RefVector(:a, status1, status2)\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWhich is equivalent to:\n\njulia> rv = PlantSimEngine.RefVector(:a, [status1, status2])\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWe can access the values of the RefVector:\n\njulia> rv[1]\n1.0\n\nUpdating the value in the RefVector will update the value in the original struct:\n\njulia> rv[1] = 10.0\n10.0\n\njulia> status1.a\n10.0\n\nWe can also make a RefVector from a vector of references:\n\njulia> vec = [Ref(1.0), Ref(2.0), Ref(3.0)]\n3-element Vector{Base.RefValue{Float64}}:\n Base.RefValue{Float64}(1.0)\n Base.RefValue{Float64}(2.0)\n Base.RefValue{Float64}(3.0)\n\njulia> rv = PlantSimEngine.RefVector(vec)\n3-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> rv[1]\n1.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SelfNodeMapping","page":"Internal API","title":"PlantSimEngine.SelfNodeMapping","text":"SelfNodeMapping()\n\nType for the self node mapping, i.e. a node that maps onto itself. This is used to flag variables that will be referenced as a scalar value by other models. It can happen in two conditions:     - the variable is computed by another scale, so we need this variable to exist as an input to this scale (it is not      computed at this scale otherwise)     - the variable is used as input to another scale but as a single value (scalar), so we need to reference it as a scalar.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.SingleNodeMapping","page":"Internal API","title":"PlantSimEngine.SingleNodeMapping","text":"SingleNodeMapping(scale)\n\nType for the single node mapping, e.g. [:soil_water_content => \"Soil\",]. Note that \"Soil\" is given as a scalar, which means that :soil_water_content will be a scalar value taken from the unique \"Soil\" node in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"Internal API","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.\n\nThe following dependency traits are supported:\n\nIsTimeStepDependent: The model depends on other time-steps for its computation, it cannot be run in parallel.\nIsTimeStepIndependent: The model does not depend on other time-steps for its computation, it can be run in parallel.\n\nAll models are time-step dependent by default (i.e. IsTimeStepDependent). This is probably not right for the  majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsTimeStepIndependent)\n\nIt is easy to override this trait for models that are time-step independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # false\n\nDefine a model that is time-step dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.UninitializedVar","page":"Internal API","title":"PlantSimEngine.UninitializedVar","text":"UninitializedVar(variable, value)\n\nA variable that is not initialized yet, it is given a name and a default value.\n\n\n\n\n\n","category":"type"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"Internal API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.copy-Tuple{T} where T<:ModelList","page":"Internal API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"Internal API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tₗ at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!","text":"add_mapped_variables_with_outputs_as_inputs!(mapped_vars)\n\nAdd the variables that are computed at a scale and written to another scale into the mapping.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\nusing PlantSimEngine.Examples\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}","page":"Internal API","title":"PlantSimEngine.convert_reference_values!","text":"convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nConvert the variables that are MappedVar{SelfNodeMapping} or MappedVar{SingleNodeMapping} to RefValues that reference a  common value for the variable; and convert MappedVar{MultiNodeMapping} to RefVectors that reference the values for the variable in the source organs.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.convert_vars","page":"Internal API","title":"PlantSimEngine.convert_vars","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}","page":"Internal API","title":"PlantSimEngine.convert_vars!","text":"convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)\n\nConverts the types of the variables in a mapping (mapped_vars) using the type_promotion dictionary.\n\nThe mapping should be a dictionary with organ name as keys and a dictionary of variables as values, with variable names as symbols and variable value as value.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.default_variables_from_mapping","page":"Internal API","title":"PlantSimEngine.default_variables_from_mapping","text":"default_variables_from_mapping(mapped_vars, verbose=true)\n\nGet the default values for the mapped variables by recursively searching from the mapping to find the original mapped value.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"Internal API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.draw_panel-NTuple{5, Any}","page":"Internal API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"Internal API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => namedtuple of variables => value.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\njulia> flatten_vars([:process1 => (var1 = -Inf, var2 = -Inf), :process2 => (var3 = -Inf, var4 = -Inf)])\n(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_mapping-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_mapping","text":"get_mapping(m)\n\nGet the mapping of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of pairs of symbols and strings or vectors of strings\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}","page":"Internal API","title":"PlantSimEngine.get_model_nodes","text":"get_model_nodes(dep_graph::DependencyGraph, model)\n\nGet the nodes in the dependency graph implementing a type of model.\n\nArguments\n\ndep_graph::DependencyGraph: the dependency graph.\nmodel: the model type to look for.\n\nReturns\n\nAn array of nodes implementing the model type.\n\nExamples\n\nPlantSimEngine.get_model_nodes(dependency_graph, Beer)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_models-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_models","text":"get_models(m)\n\nGet the models of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of models\n\nExamples\n\njulia> using PlantSimEngine;\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nIf we just give a MultiScaleModel, we get its model as a one-element vector:\n\njulia> models = MultiScaleModel( model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], );\n\njulia> PlantSimEngine.get_models(models)\n1-element Vector{ToyCAllocationModel}:\n ToyCAllocationModel()\n\nIf we give a tuple of models, we get each model in a vector:\n\njulia> models2 = (  MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );\n\nNotice that we provide \"Soil\", not [\"Soil\"] in the mapping because a single value is expected for the mapping here.\n\njulia> PlantSimEngine.get_models(models2)\n2-element Vector{AbstractModel}:\n ToyAssimModel{Float64}(0.2)\n ToyCDemandModel{Float64}(10.0, 200.0)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_multiscale_default_value","page":"Internal API","title":"PlantSimEngine.get_multiscale_default_value","text":"get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])\n\nGet the default value of a variable from a mapping.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nval::Any: the variable to get the default value of.\nmapping_stacktrace::Vector{Any}: the stacktrace of the search for the value in ascendind the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.get_nsteps-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_nsteps","text":"get_nsteps(t)\n\nGet the number of steps in the object.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.get_status-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.get_status","text":"get_status(m)\n\nGet the status of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a Status or nothing.\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.hard_dependencies-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.hard_dependencies","text":"hard_dependencies(models; verbose::Bool=true)\nhard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)\n\nCompute the hard dependencies between models.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internal API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_node_status!","page":"Internal API","title":"PlantSimEngine.init_node_status!","text":"init_node_status!(\n    node, \n    statuses, \n    mapped_vars, \n    reverse_multiscale_mapping,\n    vars_need_init=Dict{String,Any}(),\n    type_promotion=nothing;\n    check=true,\n    attribute_name=:plantsimengine_status)\n)\n\nInitialise the status of a plant graph node, taking into account the multiscale mapping, and add it to the statuses dictionary.\n\nArguments\n\nnode: the node to initialise\nstatuses: the dictionary of statuses by node type\nmapped_vars: the template of status for each node type\nreverse_multiscale_mapping: the variables that are mapped to other scales\nvar_need_init: the variables that are not initialised or computed by other models\nnodes_with_models: the nodes that have a model defined for their symbol\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors (see details)\nattribute_name: the name of the attribute to store the status in the node, by default: :plantsimengine_status\n\nDetails\n\nMost arguments can be computed from the graph and the mapping:\n\nstatuses is given by the first initialisation: statuses = Dict(i => Status[] for i in nodes_with_models)\nmapped_vars is computed using mapped_variables(), see code in init_statuses\nvars_need_init is computed using `varsneedinit = Dict(org => filter(x -> isa(last(x), UninitializedVar), vars) |> keys for (org, vars) in mapped_vars) |>\n\nfilter(x -> length(last(x)) > 0)`\n\nThe check argument is a boolean indicating if variables initialisation should be checked. In the case that some variables need initialisation (partially initialized mapping), we check if the value can be found  in the node attributes (using the variable name). If true, the function returns an error if the attribute is missing, otherwise it uses the default value from the model.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_simulation-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_simulation","text":"init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)\n\nInitialise the simulation. Returns:\n\nthe mtg\na status for each node by organ type, considering multi-scale variables\nthe dependency graph of the models\nthe models parsed as a Dict of organ type => NamedTuple of process => model mapping\nthe pre-allocated outputs\n\nArguments\n\nmtg: the MTG\nmapping::Dict{String,Any}: a dictionary of model mapping\nnsteps: the number of steps of the simulation\noutputs: the dynamic outputs needed for the simulation\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\nverbose: print information about errors in the mapping\n\nDetails\n\nThe function first computes a template of status for each organ type that has a model in the mapping. This template is used to initialise the status of each node of the MTG, taking into account the user-defined  initialisation, and the (multiscale) mapping. The mapping is used to make references to the variables that are defined at another scale, so that the values are automatically updated when the variable is changed at the other scale. Two types of multiscale variables are available: RefVector and MappedVar. The first one is used when the variable is mapped to a vector of nodes, and the second one when it is mapped to a single node. This  is given by the user through the mapping, using a string for a single node (e.g. => \"Leaf\"), and a vector of strings for a vector of nodes (e.g. => [\"Leaf\"] for one type of node or => [\"Leaf\", \"Internode\"] for several). \n\nThe function also computes the dependency graph of the models, i.e. the order in which the models should be called, considering the dependencies between them. The dependency graph is used to call the models in the right order when the simulation is run.\n\nNote that if a variable is not computed by models or initialised from the mapping, it is searched in the MTG attributes.  The value is not a reference to the one in the attribute of the MTG, but a copy of it. This is because we can't reference  a value in a Dict. If you need a reference, you can use a Ref for your variable in the MTG directly, and it will be  automatically passed as is.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.init_statuses","page":"Internal API","title":"PlantSimEngine.init_statuses","text":"init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)\n\nGet the status of each node in the MTG by node type, pre-initialised considering multi-scale variables.\n\nArguments\n\nmtg: the plant graph\nmapping: a dictionary of model mapping\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\ntype_promotion: the type promotion to use for the variables\nverbose: print information when compiling the mapping\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\n\nReturn\n\nA NamedTuple of status by node type, a dictionary of status templates by node type, a dictionary of variables mapped to other scales, a dictionary of variables that need to be initialised or computed by other models, and a vector of nodes that have a model defined for their symbol:\n\n(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}","page":"Internal API","title":"PlantSimEngine.initialise_all_as_hard_dependency_node","text":"initialise_all_as_hard_dependency_node(models)\n\nTake a set of models and initialise them all as a hard dependency node, and  return a dictionary of :process => HardDependencyNode.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}","page":"Internal API","title":"PlantSimEngine.is_graph_cyclic","text":"is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)\n\nCheck if the dependency graph is cyclic.\n\nArguments\n\ndependency_graph::DependencyGraph: the dependency graph to check.\nfull_stack::Bool=false: if true, return the full stack of nodes that makes the cycle, otherwise return only the cycle.\nwarn::Bool=true: if true, print a stylised warning message when a cycle is detected.\n\nReturn a boolean indicating if the graph is cyclic, and the stack of nodes as a vector.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.mapped_variables","page":"Internal API","title":"PlantSimEngine.mapped_variables","text":"mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)\n\nGet the variables for each organ type from a dependency graph, with MappedVars for the multiscale mapping.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.mapped_variables_no_outputs_from_other_scale","page":"Internal API","title":"PlantSimEngine.mapped_variables_no_outputs_from_other_scale","text":"mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))\n\nGet the variables for each organ type from a dependency graph, without the variables that are outputs from another scale.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nDetails\n\nThis function returns a dictionary with the (multiscale-) inputs and outputs variables for each organ type. \n\nNote that this function does not include the variables that are outputs from another scale and not computed by this scale, see mapped_variables_with_outputs_as_inputs for that.\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.model_-Tuple{AbstractModel}","page":"Internal API","title":"PlantSimEngine.model_","text":"model_(m::AbstractModel)\n\nGet the model of an AbstractModel (it is the model itself if it is not a MultiScaleModel).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel for different objects, or false otherwise. \n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over objects, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model T or the whole dependency graph is parallelizable, i.e. if the model can be computed in parallel for different time-steps or objects. The default implementation returns false for all models.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is parallelizable:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable:\n\nparallelizable(MyModel()) # true\n\nOr if we want to be more explicit:\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.pre_allocate_outputs-NTuple{6, Any}","page":"Internal API","title":"PlantSimEngine.pre_allocate_outputs","text":"pre_allocate_outputs(statuses, outs, nsteps; check=true)\n\nPre-allocate the outputs of needed variable for each node type in vectors of vectors. The first level vectors have length nsteps, and the second level vectors have length n_nodes of this type.\n\nNote that we pre-allocate the vectors for the time-steps, but not for each organ, because we don't  know how many nodes will be in each organ in the future (organs can appear or disapear).\n\nArguments\n\nstatuses: a dictionary of status by node type\nouts: a dictionary of outputs by node type\nnsteps: the number of time-steps\ncheck: whether to check the mapping for errors. Default (true) returns an error if some variables do not exist.\n\nIf false and some variables are missing, return an info, remove the unknown variables and continue.\n\nReturns\n\nA dictionary of pre-allocated output of vector of time-step and vector of node of that type.\n\nExamples\n\njulia> using PlantSimEngine, MultiScaleTreeGraph, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nDefine the models mapping:\n\njulia> mapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0, carbon_biomass=1.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0, carbon_biomass=1.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nImporting an example MTG provided by the package:\n\njulia> mtg = import_mtg_example();\n\njulia> statuses, status_templates, reverse_multiscale_mapping, vars_need_init = PlantSimEngine.init_statuses(mtg, mapping);\n\njulia> outs = Dict(\"Leaf\" => (:carbon_assimilation, :carbon_demand), \"Soil\" => (:soil_water_content,));\n\nPre-allocate the outputs as a dictionary:\n\njulia> preallocated_vars = PlantSimEngine.pre_allocate_outputs(statuses, status_templates, reverse_multiscale_mapping, vars_need_init, outs, 2);\n\nThe dictionary has a key for each organ from which we want outputs:\n\njulia> collect(keys(preallocated_vars))\n2-element Vector{String}:\n \"Soil\"\n \"Leaf\"\n\nEach organ has a dictionary of variables for which we want outputs from,  with the pre-allocated empty vectors (one per time-step that will be filled with one value per node):\n\njulia> collect(keys(preallocated_vars[\"Leaf\"]))\n3-element Vector{Symbol}:\n :carbon_assimilation\n :node\n :carbon_demand\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.ref_var-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.ref_var","text":"ref_var(v)\n\nCreate a reference to a variable. If the variable is already a Base.RefValue, it is returned as is, else it is returned as a Ref to the copy of the value, or a Ref to the RefVector (in case v is a RefVector).\n\nExamples\n\njulia> using PlantSimEngine;\n\njulia> PlantSimEngine.ref_var(1.0)\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var([1.0])\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(Base.RefValue(1.0))\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var(Base.RefValue([1.0]))\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))\nBase.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Internal API","title":"PlantSimEngine.reverse_mapping","text":"reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)\nreverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nGet the reverse mapping of a dictionary of model mapping, i.e. the variables that are mapped to other scales, or in other words, what variables are given to other scales from a given scale. This is used for e.g. knowing which scales are needed to add values to others.\n\nArguments\n\nmapping::Dict{String,Any}: A dictionary of model mapping.\nall::Bool: Whether to get all the variables that are mapped to other scales, including the ones that are mapped as single values.\n\nReturns\n\nA dictionary of organs (keys) with a dictionary of organs => vector of pair of variables. You can read the output as: \"for each organ (source organ), to which other organ (target organ) it is giving values for its own variables. Then for each of these source organs, which variable it is giving to the target organ (first symbol in the pair), and to which variable it is mapping the value into the target organ (second symbol in the pair)\".\n\nExamples\n\njulia> using PlantSimEngine\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\njulia> mapping = Dict( \"Plant\" => MultiScaleModel( model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \"Internode\" => ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nNotice we provide \"Soil\", not [\"Soil\"] in the mapping of the ToyAssimModel for the Leaf. This is because we expect a single value for the soil_water_content to be mapped here (there is only one soil). This allows  to get the value as a singleton instead of a vector of values.\n\njulia> PlantSimEngine.reverse_mapping(mapping)\nDict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:\n  \"Soil\"      => Dict(\"Leaf\"=>Dict(:soil_water_content=>:soil_water_content))\n  \"Internode\" => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n  \"Leaf\"      => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"Internal API","title":"PlantSimEngine.save_results!","text":"save_results!(object::GraphSimulation, i)\n\nSave the results of the simulation for time-step i into the  object. For a GraphSimulation object, this will save the results from the status(object) in the outputs(object).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_multiscale_output","text":"search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies at other scales.\norgan::String: the organ for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => [:subprocess => (:var1, :var2)].\nsoft_dep_graphs::Dict{String, ...}: a dict of organ => (softdepgraph, inputs, outputs).\nrev_mapping::Dict{Symbol, Symbol}: a dict of mapped variable => source variable (this is the reverse mapping).\n'harddependenciesfromotherscale' : a vector of HardDependencyNode to provide access to the hard dependencies without traversing the whole graph\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies variables found in outputs of other scales for each process, e.g.:\n\nDict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:\n    \"Internode\" => Dict(:carbon_demand=>[:carbon_demand])\n    \"Leaf\"      => Dict(:carbon_assimilation=>[:carbon_assimilation], :carbon_demand=>[:carbon_demand])\n\nThis means that the variable :carbon_demand is computed by the process :carbon_demand at the scale \"Internode\", and the variable :carbon_assimilation  is computed by the process :carbon_assimilation at the scale \"Leaf\". Those variables are used as inputs for the process that we just passed.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"Internal API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.soft_dependencies","page":"Internal API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}","page":"Internal API","title":"PlantSimEngine.status_from_template","text":"status_from_template(d::Dict{Symbol,Any})\n\nCreate a status from a template dictionary of variables and values. If the values  are already RefValues or RefVectors, they are used as is, else they are converted to Refs.\n\nArguments\n\nd::Dict{Symbol,Any}: A dictionary of variables and values.\n\nReturns\n\nA Status.\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> a, b = PlantSimEngine.status_from_template(Dict(:a => 1.0, :b => 2.0));\n\njulia> a\n1.0\n\njulia> b\n2.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"Internal API","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel over time-steps, or false otherwise.\n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over time-steps, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\nobject_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over objects:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!","text":"transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)\n\nFind variables that are inputs to other scales as a SingleNodeMapping and declare them as MappedVar from themselves in the source scale. This helps us declare it as a reference when we create the template status objects.\n\nThese node are found in the mapping as [:variable_name => \"Plant\"] (notice that \"Plant\" is a scalar value).\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"Internal API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nfunction f(node)\n    node.value\nend\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_multiscale","page":"Internal API","title":"PlantSimEngine.variables_multiscale","text":"variables_multiscale(node, organ, mapping, st=NamedTuple())\n\nGet the variables of a HardDependencyNode, taking into account the multiscale mapping, i.e. defining variables as MappedVar if they are mapped to another scale. The default values are  taken from the model if not given by the user (st), and are marked as UninitializedVar if  they are inputs of the node.\n\nReturn a NamedTuple with the variables and their default values.\n\nArguments\n\nnode::HardDependencyNode: the node to get the variables from.\norgan::String: the organ type, e.g. \"Leaf\".\nvars_mapping::Dict{String,T}: the mapping of the models (see details below).\nst::NamedTuple: an optional named tuple with default values for the variables.\n\nDetails\n\nThe vars_mapping is a dictionary with the organ type as key and a dictionary as value. It is  computed from the user mapping like so:\n\n\n\n\n\n","category":"function"},{"location":"API/API_private/#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}","page":"Internal API","title":"PlantSimEngine.variables_outputs_from_other_scale","text":"variables_outputs_from_other_scale(mapped_vars)\n\nFor each organ in the mapped_vars, find the variables that are outputs from another scale and not computed at this scale otherwise. This function is used with mapped_variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"Internal API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"Internal API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"PlantSimEngine arose out of a perceived need for a new modelling framework for ecophysiological and FSPM simulations.","category":"page"},{"location":"introduction/why_plantsimengine/#Goals","page":"Why PlantSimEngine ?","title":"Goals","text":"","category":"section"},{"location":"introduction/why_plantsimengine/#Existing-FSPM-systems","page":"Why PlantSimEngine ?","title":"Existing FSPM systems","text":"","category":"section"},{"location":"introduction/why_plantsimengine/#Monoliths","page":"Why PlantSimEngine ?","title":"Monoliths","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Often massive codebases Rigid Implicit hypothesis Parameters hard to change","category":"page"},{"location":"introduction/why_plantsimengine/#Distributed-systems","page":"Why PlantSimEngine ?","title":"Distributed systems","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"two-language problem","category":"page"},{"location":"introduction/why_plantsimengine/#other-tools","page":"Why PlantSimEngine ?","title":"other tools","text":"","category":"section"},{"location":"introduction/why_plantsimengine/","page":"Why PlantSimEngine ?","title":"Why PlantSimEngine ?","text":"Architectural primary focus Adding functional and environmental models is less straightforward C++, Java, less accessible User interface Less tailored to autonomous 'researcher-developer', requires a 'developer-modeller'","category":"page"},{"location":"prerequisites/key_concepts/#Key-Concepts","page":"Key Concepts","title":"Key Concepts","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You'll find a brief description of some of the main concepts and terminology related to and used in PlantSimEngine. ","category":"page"},{"location":"prerequisites/key_concepts/#Crop-models","page":"Key Concepts","title":"Crop models","text":"","category":"section"},{"location":"prerequisites/key_concepts/#FSPM","page":"Key Concepts","title":"FSPM","text":"","category":"section"},{"location":"prerequisites/key_concepts/#PlantSimEngine-terminology","page":"Key Concepts","title":"PlantSimEngine terminology","text":"","category":"section"},{"location":"prerequisites/key_concepts/#Processes","page":"Key Concepts","title":"Processes","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"See Implementing a new process for a brief explanation on how to declare a new process.","category":"page"},{"location":"prerequisites/key_concepts/#Models","page":"Key Concepts","title":"Models","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Models are then implemented for a particular process. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"There may be different models that can be used for the same process ; for instance, there are multiple hypotheses and ways of modeling photosynthesis, with different granularity and accuracy. A simple photosynthesis model might apply a simple formula and apply it to the total leaf surface, a more complex one might calculate interception and light extinction. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"The companion package PlantBiophysics.jl provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/Beer.jl.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Models can also be used for ad hoc computations that aren't directly tied to a specific literature-defined physiological process. In PlantSimEngine, everything is a model. There are many instances where a custom model might be practical to aggregate some computations or handle other information. To illustrate, XPalm, the Oil Palm model has a few models that handle the state of different organs, and a mdoel to handle leaf pruning, which you can find here.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"To prepare a simulation, you declare a ModelList with whatever models you wish to make use of. TODO example For multi-scale simulations, a more involved mapping is required, see below. TODO","category":"page"},{"location":"prerequisites/key_concepts/#Variables,-inputs,-outputs,-and-simple-model-coupling","page":"Key Concepts","title":"Variables, inputs, outputs, and simple model coupling","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"A model used in a simulation requires some input data and parameters, and will compute some other data which may be used by other models.  Depending on what models are combined in a simulation, some variables may be inputs of some models, outputs of other models, only be part of intermediary computations, or be a user input to the whole simulation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO exemple avec 2-3 modèles","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO image de graphe illustrant un couplage","category":"page"},{"location":"prerequisites/key_concepts/#Dependency-graphs","page":"Key Concepts","title":"Dependency graphs","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Coupling models together in this fashion creates what is known as a Directed Acyclic Graph or DAG, a type of dependency graph. The order in which models are run is determined by the ordering of these models in that graph.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO image","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine creates this DAG under the hood by plugging the right variables in the right models. Users therefore only need to declare models, they do not need write the code to connect them as PlantSimEngine does that work for them.","category":"page"},{"location":"prerequisites/key_concepts/#hard_dependency_def","page":"Key Concepts","title":"\"Hard\" and \"Soft\" dependencies","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Linking models by finding which output variables are used as input of another model handles many of the coupling situations that can occur (with more situations occurring with multi-scale models and variables), but what if two models are interdependent ? If they need to iterate on some computation and pass variables back and forth ? ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Model couplings that cause simulation to flow both ways break the 'acyclic' assumption of the dependency graph.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine handles this internally by not having those \"heavily-coupled\" models -called \"hard dependencies\" from now on- be part of the main dependency graph. Instead, they are made to be children nodes of the parent/ancestor model, which handles them internally, so they aren't tied to other nodes of the dependency graph. The resulting higher-level graph therefore only links models without any two-way interdependencies, and remains a directed graph, enabling a cohesive simulation order. The simpler couplings in that top-level graph are called \"soft dependencies\".","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This approach does have implications when developing interdependent models : hard dependencies need to be made explicit, and the ancestor needs to call the hard dependency model's run! function explicitely in its own run! function. Hard dependency models therefore must have only one parent model. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"You can find an example TODO","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This makes them slightly more complex to develop and validate, and less versatile than other models. Occasional refactoring may be necessary to handle a hard dependency creeping up when adding new models to a simulation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Note that hard dependencies can also have their own hard dependencies, and some complex couplings are therefore possible. A hard dependency model can have another hard dependency model as a parent.","category":"page"},{"location":"prerequisites/key_concepts/#Weather-data","page":"Key Concepts","title":"Weather data","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"To run a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"In the example below, we also pass in the -optional- incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"More details are available from the package documentation. If you do not wish to make use of this package, you can alternately provide your own data, as long as it respects the Tables.jl interface.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"If you wish to make use of more fine-grained weather data, it will likely require more advanced model creation and MTG manipulation, and more involved work on the modeling side.∂","category":"page"},{"location":"prerequisites/key_concepts/#Organ/Scale","page":"Key Concepts","title":"Organ/Scale","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Plants have different organs with distinct physiological properties and processes. When doing more fine-grained simulations of plant growth, many models will be tied to a particular organ of a plant. Models handling flowering state or root water absorption are such examples. Others, such as carbon allocation and demand, might be reused in slightly different ways for multiple organs of the plant.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"PlantSimEngine documentation tends to use the terms \"organ\" and \"scale\" mostly interchangeably. \"Scale\" is a bit more general and accurate, since some models might not operate at a specific organ level, but (for example) at the scene level, so a \"Scene\" scale might be present in the MTG, and in the user-provided data.","category":"page"},{"location":"prerequisites/key_concepts/#Multiscale-modeling","page":"Key Concepts","title":"Multiscale modeling","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale modeling is the process of simulating a system at multiple levels of detail simultaneously. For example, some models can run at the organ scale while others run at the plot scale. Each model can access variables at its scale and other scales if needed, allowing for a more comprehensive system representation. It can also help identify emergent properties that are not apparent at a single level of detail. ","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"For example, a model of photosynthesis at the leaf scale can be combined with a model of carbon allocation at the plant scale to simulate the growth and development of the plant. Another example is a combination of models to simulate the energy balance of a forest. To simulate it, you need a model for each organ type of the plant, another for the soil, and finally, one at the plot scale, integrating all others.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"When running multi-scale simulations which contain models operating at different organ levels for the plant, extra information needs to be provided by the user to run models. Since some models are reused at different organ levels, it is necessary to indicate which organ level a model operates at.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"This is why multi-scale simulations make use of a 'mapping' : the ModelList in the single-scale examples does not have a way to tie models to plant organs,and the more versatile models could be used in various places. The user must also indicate how models operate with other scales, e.g. if an input variable comes from another scale, it is required to indicate which scale it is mapped from.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO","category":"page"},{"location":"prerequisites/key_concepts/#Multi-scale-Tree-Graphs","page":"Key Concepts","title":"Multi-scale Tree Graphs","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale Tree Graphs (MTG) are a data structure used to represent plants. A more detailed introduction to the format and its attributes can be found in the MultiScaleTreeGraph.jl package documentation.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Multi-scale simulations can operate on MTG objects ; new nodes are added corresponding to new organs created during the plant's growth.","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"Another companion package, PlantGeom.jl, can also create MTG objects from .opf files (corresponding to the Open Plant Format, an alternate means of describing plants computationally).","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO example ? TODO image ? TODO lien avec AMAP ?","category":"page"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO scale, symbol terminology ambiguity","category":"page"},{"location":"prerequisites/key_concepts/#State-machines","page":"Key Concepts","title":"State machines","text":"","category":"section"},{"location":"prerequisites/key_concepts/","page":"Key Concepts","title":"Key Concepts","text":"TODO differences mono/multiscale ?","category":"page"},{"location":"multiscale/multiscale_example_1/#Writing-a-multiscale-simulation","page":"A rudimentary plant simulation","title":"Writing a multiscale simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"TODO change Toy To Example ?","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"This section iteratively walks you through building a multi-scale simulation. ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The actual plant being simulated, as well as some of the ad hoc processes, mostly have no physical meaning and are very much ad hoc (which is why most of them aren't standalone in the examples folder). Similarly, some of the parameter values are pulled out of thin air, and have no ties to research papers or data.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The main purpose here is to showcase PlantSimEngine's multi-scale features and how to structure your models, not accuracy, realism or performance.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"You can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_1/#A-basic-growing-plant","page":"A rudimentary plant simulation","title":"A basic growing plant","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"At minimul, to simulate some kind of fake growth, we need :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"A MultiScale Tree Graph representing the plant\nSome way of adding organs to the plant\nSome kind of temporality to this dynamic","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's have some concept of 'leaves' that capture the (carbon) resource necessary for organ growth, and let's have the organ emergence happen at the 'internode' level, to illustrate multiple organs with different behavior.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We'll make the assumption the internodes make use of carbon from a common pool. We'll also make use of thermal time as a growth delay factor.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"One way of modeling this approach translates into several scales and models : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Scene scale, for thermal time. The ToyDegreeDaysCumulModel() from the examples folder provides thermal time from temperature data \nPlant scale, where we'll define the carbon pool\nInternode scale, which draws from the pool to create new organs\nLeaf scale, which captures carbon","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's also add a very artificial limiting factor : if the total leaf surface area is above a threshold no new organs are created.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We can expect the simulation mapping to look like a more complex version of the following : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => ToyStockComputationModel(),\n\"Internode\" => ToyCustomInternodeEmergence(),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Some of the models will need to gather variables from scales other than their own, meaning they will need to be converted into MultiScaleModels.","category":"page"},{"location":"multiscale/multiscale_example_1/#Implementation","page":"A rudimentary plant simulation","title":"Implementation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/#Carbon-Capture","page":"A rudimentary plant simulation","title":"Carbon Capture","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's start with the simplest model. Leaves continuously capture some constant amount of carbon every timestep. No inputs are required.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # No inputs\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Resource-storage","page":"A rudimentary plant simulation","title":"Resource storage","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The model storing resources for the whole plant needs a couple of inputs : the amount of carbon captured by the leaves, as well as the amount consumed by the creation of new organs. It outputs the current stock.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"TODO","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(carbon_captured=0.0,carbon_organ_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (carbon_stock=-Inf,)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed)\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Organ-creation","page":"A rudimentary plant simulation","title":"Organ creation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"This model is a modified version of the ToyInternodeEmergence() model found in the examples folder. An internode produces two leaves and a new internode.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Let's first define a helper function that iterates across a Multiscale Tree Graph and returns the number of leaves :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"function get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Now that we have that, let's define a few parameters to the model. It requires :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"a thermal time emergence threshold\na carbon cost for organ creation","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We'll also add a couple of other parameters, which could go elsewhere :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"the surface area of a leaf (no variation, no growth stages)\nthe max leaf surface area beyond which organ creation stops","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.@process \"organ_emergence\" verbose = false\n\nstruct ToyCustomInternodeEmergence <: AbstractOrgan_EmergenceModel\n    TT_emergence::Float64\n    carbon_internode_creation_cost::Float64\n    leaf_surface_area::Float64\n    leaves_max_surface_area::Float64\nend\n","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And give them some default values : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"ToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0, leaves_max_surface_area=100.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Our internode model requires thermal time, and the amount of available carbon, and outputs the amount of carbon consumed, as well as the last thermal time where emergence happened (this is useful when new organs can be produced multiple times, which won't be the case here).","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"PlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Finally, the run! function checks that conditions are met for new organ creation :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"thermal time threshold exceeded\ntotal leaf surface area not above limit\ncarbon available\nno organs already created by that internode","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"and then updates the MTG.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"function PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"page"},{"location":"multiscale/multiscale_example_1/#Updated-mapping","page":"A rudimentary plant simulation","title":"Updated mapping","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We can now define the final mapping for this simulation. ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"The carbon capture and thermal time models don't need to be changed from the earlier version.  The organ creation model at the \"Internode\" scale needs the carbon stock from the \"Plant\" scale, as well as thermal time from the \"Scene\" scale. The resource storing model at the \"Plant\" scale needs the carbon captured by every leaf, and the carbon consumed by every internode that created new organs this timestep. This requires mapping vector variables :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mapping=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"as opposed to the single-valued carbon stock mapped variable : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mapping=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And of course, some variables need to be initialized in the status","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapping=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],\n        ),\n        Status(carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapping=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)","category":"page"},{"location":"multiscale/multiscale_example_1/#Running-a-simulation","page":"A rudimentary plant simulation","title":"Running a simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"We only need an MTG, and some weather data, and then we'll be set. Let's create a simple MTG : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":" mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Import some weather data : ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And we're good to go ! ","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"outs = run!(mtg, mapping, meteo_day)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"And that's it. If you query or display the MTG after simulation, you'll see it expanded and grew multiple internodes and leaves :","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"mtg\nget_n_leaves(mtg)","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Feel free to tinker with the parameters and see when things break down, to get a feel for the simulation.","category":"page"},{"location":"multiscale/multiscale_example_1/","page":"A rudimentary plant simulation","title":"A rudimentary plant simulation","text":"Of course, this is a very crude and unrealistic simulation, with many dubious assumptions and parameters. But significantly more complex modelling is possible using the same approach : XPalm runs using a few dozen models spread out over nine scales.","category":"page"},{"location":"working_with_data/inputs/#Input-types","page":"Input types","title":"Input types","text":"","category":"section"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"run! usually takes two inputs: a ModelList and data for the meteorology. The data for the meteorology is usually provided for one time step using an Atmosphere, or for several time-steps using a TimeStepTable{Atmosphere}. The ModelList can also be provided as a singleton, or as a vector or dictionary of.","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"run! knows how to handle these data formats via the PlantSimEngine.DataFormat trait (see this blog post to learn more about traits). For example, we tell PlantSimEngine that a TimeStepTable should be handled like a table by implementing the following trait:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"If you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:MyTableFormat}) = TableAlike()","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"There are two other traits available: SingletonAlike for a data format representing one time-step only, and TreeAlike for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).","category":"page"},{"location":"working_with_data/inputs/#Special-considerations-for-new-input-types","page":"Input types","title":"Special considerations for new input types","text":"","category":"section"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on your use-cases. ","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"For example if you use models that need to get data from a different time step (e.g. a model that needs to get the previous day's temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"To do so, you need to implement the following methods for your structure that defines your rows:","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"Base.parent: return the parent table of the row, e.g. the full DataFrame\nPlantMeteo.rownumber: return the row number of the row in the parent table, e.g. the row number in the DataFrame\n(Optionnally) PlantMeteo.row_from_parent(row, i): return row i from the parent table, e.g. the row i from the DataFrame. This is only needed if you want high performance, the default implementation calls Tables.rows(parent(row))[i].","category":"page"},{"location":"working_with_data/inputs/","page":"Input types","title":"Input types","text":"compat: Compat\nPlantMeteo.rownumber is temporary. It soon will be replaced by DataAPI.rownumber instead, which will be also used by e.g. DataFrames.jl. See this Pull Request.","category":"page"},{"location":"step_by_step/implement_a_process/#Implementing-a-new-process","page":"Processes","title":"Implementing a new process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine\nusing PlantMeteo\nPlantSimEngine.@process growth","category":"page"},{"location":"step_by_step/implement_a_process/#Introduction","page":"Processes","title":"Introduction","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. Let's learn about how to implement a new process with a simple example: implementing a growth model.","category":"page"},{"location":"step_by_step/implement_a_process/#Implement-a-process","page":"Processes","title":"Implement a process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"To implement a new process, we need to define an abstract structure that will help us associate the models to this process. We also need to generate some boilerplate code, such as a method for the process function. Fortunately, PlantSimEngine provides a macro to generate all that at once: @process. This macro takes only one argument: the name of the process.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"For example, the photosynthesis process in PlantBiophysics.jl is declared using just this tiny line of code:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"@process \"photosynthesis\"","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"If we want to simulate the growth of a plant, we could add a new process called growth:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"@process \"growth\"","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"And that's it! Note that the function guides you in the steps you can make after creating a process. Let's break it up here.","category":"page"},{"location":"step_by_step/implement_a_process/#Implement-a-new-model-for-the-process","page":"Processes","title":"Implement a new model for the process","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"Once process implementation is done, you can write a corresponding model implementation. A tutorial page showcasing a light interception model implementation can be found here","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"A full model implementation for this process is available in the example script ToyAssimGrowthModel.jl.","category":"page"},{"location":"step_by_step/implement_a_process/#under_the_hood","page":"Processes","title":"Under the hood","text":"","category":"section"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"The @process macro is just a shorthand reducing boilerplate.","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"You can in its stead directly define a process by hand by defining an abstract type that is a subtype of AbstractModel:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"abstract type AbstractGrowthModel <: PlantSimEngine.AbstractModel end","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"And by adding a method for the process_ function that returns the name of the process:","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.process_(::Type{AbstractGrowthModel}) = :growth","category":"page"},{"location":"step_by_step/implement_a_process/","page":"Processes","title":"Processes","text":"So in the earlier example, a new process was created called growth. This defined a new abstract structure called AbstractGrowthModel, which is used as a supertype of the models. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model.","category":"page"},{"location":"prerequisites/design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to ease the process of modelling and simulation of plants, soil and atmosphere, or really any system (e.g. agroforestry system, agrivoltaics...). PlantSimEngine.jl aims at being the backbone tool for developing Functional-Structural Plant Models (FSPM) and crop models without the hassle of performance and other computer-science considerations.  ","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nrun!(leaf, meteo)","category":"page"},{"location":"prerequisites/design/#Definitions","page":"Design","title":"Definitions","text":"","category":"section"},{"location":"prerequisites/design/#Processes","page":"Design","title":"Processes","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"A process is \"declared\", meaning we just define a process using @process, and then we implement models for its simulation. Declaring a process generates some boilerplate code for its simulation: ","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"an abstract type for the process\na method for the process function, that is used internally","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"For example, the light_interception process is declared using:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"@process light_interception","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Which would generate a tutorial to help the user implement a model for the process.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"The abstract process type is then used as a supertype of all models implementations for the process, and is named Abstract<process_name>Process, e.g. AbstractLight_InterceptionModel.","category":"page"},{"location":"prerequisites/design/#Models-(ModelList)","page":"Design","title":"Models (ModelList)","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/Beer.jl.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Models can use three types of entries:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Parameters are constant values that are used by the model to compute its outputs. Meteorological information are values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. Variables are either used or computed by the model and can optionally be initialized before the simulation. Constants are constant values, usually common between models, e.g. the universal gas constant. And extras are just extra values that can be used by a model, it is for example used to pass the current node of the Multi-Scale Tree Graph to be able to e.g. retrieve children or ancestors values.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Users can choose which model is used to simulate a process using the ModelList structure. ModelList is also used to store the values of the parameters, and to initialize variables.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"For example let's instantiate a ModelList with the Beer-Lambert model of light extinction. The model is implemented with the Beer structure and has only one parameter: the extinction coefficient (k).","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Importing the package:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using PlantSimEngine","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Import the examples defined in the Examples sub-module (light_interception and Beer):","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using PlantSimEngine.Examples","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"And then making a ModelList with the Beer model:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"ModelList(Beer(0.5))","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"What happened here? We provided an instance of the Beer model to a ModelList to simulate the light interception process.","category":"page"},{"location":"prerequisites/design/#Parameters","page":"Design","title":"Parameters","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"A parameter is a constant value that is used by a model to compute its outputs. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer-Lambert model is implemented with the Beer structure, which has only one field: k. We can see that using fieldnames on the model structure:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"fieldnames(Beer)","category":"page"},{"location":"prerequisites/design/#Variables-(inputs,-outputs)","page":"Design","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Variables are either input or outputs (i.e. computed) of models. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"For example, the Beer model needs the leaf area index (LAI, m² m⁻²) to run.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"We can see which variables are needed as inputs using inputs:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"inputs(Beer(0.5))","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"and the outputs of the model using outputs:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"outputs(Beer(0.5))","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"If we instantiate a ModelList with the Beer-Lambert model, we can see that the :status field has two variables: LAI and PPFD. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nkeys(status(m))","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nto_initialize(m)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"(m[:LAI], m[:aPPFD])","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Uninitialized variables are initialized to the value given in the inputs or outputs methods, which is usually equal to typemin(), e.g. -Inf for Float64.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns the variables that are needed by the model to run, but to_initialize returns the variables that are needed by the model to run and that are not initialized in the ModelList. Also to_initialize is more clever when coupling models (see below).","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"We can initialize the variables by providing their values to the status at instantiation:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Or after instantiation using init_status!:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"is_initialized(m)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Some variables are inputs of models, but outputs of other models. When we couple models, PlantSimEngine.jl is clever and only requests the variables that are not computed by other models.","category":"page"},{"location":"prerequisites/design/#Climate-forcing","page":"Design","title":"Climate forcing","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). In our example, we also need the incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"More details are available from the package documentation.","category":"page"},{"location":"prerequisites/design/#Simulation","page":"Design","title":"Simulation","text":"","category":"section"},{"location":"prerequisites/design/#Simulation-of-processes","page":"Design","title":"Simulation of processes","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Making a simulation is rather simple, we simply call the run! method on the ModelList. If some meteorological data is required for models to be simulated over several timesteps, that can be passed in as a parameter as well.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Here is an example:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"run!(model_list, meteo)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"The ModelList should be initialized for the given process before calling the function. See Variables (inputs, outputs) for more details.","category":"page"},{"location":"prerequisites/design/#Example-simulation","page":"Design","title":"Example simulation","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"For example we can simulate the light_interception of a leaf like so:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\noutputs_example = run!(leaf, meteo)\n\noutputs_example[:aPPFD]","category":"page"},{"location":"prerequisites/design/#Outputs","page":"Design","title":"Outputs","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"TODO The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract outputs of the last timestep of a simulation using the status function.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"The actual full output data is returned by the run! function. Data is usually stored in a TimeStepTable structure from PlantMeteo.jl, which is a fast DataFrame-alike structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Let's look at the outputs of our previous simulated leaf:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"outputs_example","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"We can extract the value of one variable by indexing into it, e.g. for the intercepted light:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"outputs_example[:aPPFD]","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Or similarly using the dot syntax:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"outputs_example.aPPFD","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"Another simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"using DataFrames\nconvert_outputs(outputs_example, DataFrame)","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"note: Note\nThe output from this conversion function is adapted to the kind of simulation you did: one row per time-step, and per component models if you simulated several.","category":"page"},{"location":"prerequisites/design/#Model-coupling","page":"Design","title":"Model coupling","text":"","category":"section"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"prerequisites/design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to make model coupling painless for modelers and users. Please see Standard model coupling and Coupling more complex models for more details, or Multiscale coupling considerations TODO for multi-scale specific coupling considerations.","category":"page"},{"location":"multiscale/multiscale_cyclic/#Avoiding-cyclic-dependencies","page":"Handling cyclic dependencies","title":"Avoiding cyclic dependencies","text":"","category":"section"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"When defining a mapping between models and scales, it is important to avoid cyclic dependencies. A cyclic dependency occurs when a model at a given scale depends on a model at another scale that depends on the first model. Cyclic dependencies are bad because they lead to an infinite loop in the simulation (the dependency graph keeps cycling indefinitely).","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"PlantSimEngine will detect cyclic dependencies and raise an error if one is found. The error message indicates the models involved in the cycle, and the model that is causing the cycle will be highlighted in red.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"For example the following mapping will raise an error:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"details: Details\n<summary>Example mapping</summary>mapping_cyclic = Dict(\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n        Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6),\n    ),\n    \"Internode\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(TT=10.0, carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        ToyCBiomassModel(1.2),\n        Status(TT=10.0),\n    )\n)","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"Let's see what happens when we try to build the dependency graph for this mapping:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"julia> dep(mapping_cyclic)\nERROR: Cyclic dependency detected in the graph. Cycle:\n Plant: ToyPlantRmModel\n └ Leaf: ToyMaintenanceRespirationModel\n  └ Leaf: ToyCBiomassModel\n   └ Plant: ToyCAllocationModel\n    └ Plant: ToyPlantRmModel\n\n You can break the cycle using the `PreviousTimeStep` variable in the mapping.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"How can we interpret the message? We have a list of five models involved in the cycle. The first model is the one causing the cycle, and the others are the ones that depend on it. In this case, the ToyPlantRmModel is the one causing the cycle, and the others are inter-dependent. We can read this as follows:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"ToyPlantRmModel depends on ToyMaintenanceRespirationModel, the plant-scale respiration sums up all organs respiration;\nToyMaintenanceRespirationModel depends on ToyCBiomassModel, the organs respiration depends on the organs biomass;\nToyCBiomassModel depends on ToyCAllocationModel, the organs biomass depends on the organs carbon allocation;\nAnd finally ToyCAllocationModel depends on ToyPlantRmModel again, hence the cycle because the carbon allocation depends on the plant scale respiration.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"The models can not be ordered in a way that satisfies all dependencies, so the cycle can not be broken. To solve this issue, we need to re-think how models are mapped together, and break the cycle.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"There are several ways to break a cyclic dependency:","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"Merge models: If two models depend on each other because they need e.g. recursive computations, they can be merged into a third model that handles the computation and takes the two models as hard dependencies. Hard dependencies are models that are explicitly called by another model and do not participate on the building of the dependency graph.\nChange models: Of course models can be interchanged to avoid cyclic dependencies, but this is not really a solution, it is more a workaround.\nPreviousTimeStep: We can break the dependency graph by defining some variables as taken from the previous time step. A very well known example is the computation of the light interception by a plant that depends on the leaf area, which is usually the result of a model that also depends on the light interception. The cyclic dependency is usually broken by using the leaf area from the previous time step in the interception model, which is a good approximation for most cases.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"We can fix our previous mapping by computing the organs respiration using the carbon biomass from the previous time step instead. Let's see how to fix the cyclic dependency in our mapping (look at the leaf and internode scales):","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"details: Details\nmapping_nocyclic = Dict(\n        \"Plant\" => (\n            MultiScaleModel(\n                model=ToyCAllocationModel(),\n                mapping=[\n                    :carbon_demand => [\"Leaf\", \"Internode\"],\n                    :carbon_allocation => [\"Leaf\", \"Internode\"]\n                ],\n            ),\n            MultiScaleModel(\n                model=ToyPlantRmModel(),\n                mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n            ),\n            Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6, carbon_assimilation=5.0),\n        ),\n        \"Internode\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n                mapping=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (first break)\n            ),\n            Status(TT=10.0, carbon_biomass=1.0),\n        ),\n        \"Leaf\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n                mapping=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (second break)\n            ),\n            ToyCBiomassModel(1.2),\n            Status(TT=10.0),\n        )\n    );\nnothing # hide","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"The ToyMaintenanceRespirationModel models are now defined as MultiScaleModel, and the carbon_biomass variable is wrapped in a PreviousTimeStep structure. This structure tells PlantSimEngine to take the value of the variable from the previous time step, breaking the cyclic dependency.","category":"page"},{"location":"multiscale/multiscale_cyclic/","page":"Handling cyclic dependencies","title":"Handling cyclic dependencies","text":"note: Note\nPreviousTimeStep tells PlantSimEngine to take the value of the previous time step for the variable it wraps, or the value at initialization for the first time step. The value at initialization is the one provided by default in the models inputs, but is usually provided in the Status structure to override this default. A PreviousTimeStep is used to wrap the input variable of a model, with or without a mapping to another scale e.g. PreviousTimeStep(:carbon_biomass) => \"Leaf\".","category":"page"},{"location":"step_by_step/model_switching/#Model-switching","page":"Model Switching","title":"Model switching","text":"","category":"section"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine, PlantMeteo, CSV, DataFrames\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n \nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models, meteo_day)\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models2, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"One of the main objective of PlantSimEngine is allowing users to switch between model implementations for a given process without making any change to the PlantSimEngine codebase.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"The package was designed around this idea to make easy changes easy and efficient. Switch models in the ModelList, and call the run! function again. No other changes are required if no new variables are introduced.","category":"page"},{"location":"step_by_step/model_switching/#Example-model-switching","page":"Model Switching","title":"Example model switching","text":"","category":"section"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Let's create a ModelList with several models from the example scripts in the examples folder:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Importing the models from the scripts:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Coupling the models in a ModelList:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"models = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can the simulation by calling the run! function with meteorology data. Here we use an example data set:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"tip: Tip\nFor meteorology data details, you can check the code presented in this section in the FAQ","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can now run the simulation:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"output_initial = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Now what if we want to switch the model that computes growth ? We can do this by simply replacing the model in the ModelList, and PlantSimEngine will automatically update the dependency graph, and adapt the simulation to the new model.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"Let's switch ToyRUEGrowthModel with ToyAssimGrowthModel:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"models2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(), # This was `ToyRUEGrowthModel(0.2)` before\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"ToyAssimGrowthModel is a little bit more complex than ToyRUEGrowthModel, as it also computes the maintenance and growth respiration of the plant, so it has more parameters (we use the default values here). ","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"We can run a new simulation and see that the simultion's results are different from the previous simulation:","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"output_updated = run!(models2, meteo_day)","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"And that's it! We can switch between models without changing the code, and without having to recompute the dependency graph manually. This is a very powerful feature of PlantSimEngine!💪","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nThis was a very standard but easy example. Sometimes other models will require to add other models to the ModelList. For example ToyAssimGrowthModel could have required a maintenance respiration model. In this case PlantSimEngine will tell you that this kind of model is required for the simulation.","category":"page"},{"location":"step_by_step/model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nIn our example we replaced a soft-dependency model, but the same principle applies to hard-dependency models. Hard and Soft dependencies are concepts explained here TODO remove this note ?","category":"page"},{"location":"prerequisites/julia_basics/#Getting-started-with-Julia","page":"Julia language basics","title":"Getting started with Julia","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"PlantSimEngine (as well as its related packages) is written in Julia. The reasons why Julia was chosen are briefly discussed here : The choice of using Julia.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Julia is a language that is gaining traction, but it isn't the most widely used in research and data science. ","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Many elements will be familiar to those with an R, Python or Matlab background, but there are some noteworthy differences, and if you are new to the language, there will be a few hurdles you might have to overcome to be comfortable using the language.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"This section is here to help you with that, and provides a short introduction to the parts of Julia that are most relevant regarding usage of PlantSimEngine.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"It is not meant as a full-fledged Julia tutorial. If you are completely new to programming, you may wish to check some other resources first, such as ones found here.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"If you wish to compare Julia to a specific language, this page will provide you with a quick overview of the differences.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"You can also find a few cheatsheets here as well as a short introductory notebook along with install instructions","category":"page"},{"location":"prerequisites/julia_basics/#Installing-Julia","page":"Julia language basics","title":"Installing Julia","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Installing-PlantSimEngine-and-its-dependencies","page":"Julia language basics","title":"Installing PlantSimEngine and its dependencies","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Julia-environments","page":"Julia language basics","title":"Julia environments","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Running-an-environment","page":"Julia language basics","title":"Running an environment","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Once your environment is set up, you can launch a command prompt and type 'julia'. This will launch Julia, and you should see julia>  in the command prompt.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"You can always type '?' from there to enter help mode, and type the name of a function or language feature you wish to know more about.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"You can find out which directory you are in by typing pwd() in a Julia session.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Handling environments and dependencies is done in Julia through a specific Package called Pkg, which comes with the base install. You can either call Pkg features the same way you would for another package, or enter Pkg mode by typing ']', which will change the display from  julia> to something like (@v1.11) pkg>, indicating your current environment (in this case, the default julia environment, which we don't recommend bloating).","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Once in Pkg mode, you can choose to create an environment by typing 'activate path/to/environemnt'. ","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"You can then add packages that have been added to Julia's online global registry by typing add packagename and you can remove them by typing remove packagename. Typing status or st will indicate what your current environment is comprised of. To update packages in need of updating (a '^' symbol will display next to their name), type update or up.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"If you are editing/developing a package or using one locally, typing develop path/to/package source/ (or dev path/to/package/source) will cause your environment to use that version instead of the registered one.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Typing instantiate will download all the packages declared in the manifest file (if it exists) of an environment.","category":"page"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"For instance, PlantSimEngine has a test folder used in development. If you wanted to run tests, you would type ']' 'activate ../path/to/PlantSimEngine/test' 'instantiate' and then you would be ready to go.","category":"page"},{"location":"prerequisites/julia_basics/#Variables,-functions-and-arrays-See-the-palmstudio-basic-syntax-page,-or-the-diff-eq-notebook-?","page":"Julia language basics","title":"Variables, functions and arrays -> See the palmstudio basic syntax page, or the diff eq notebook ?","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Really-noteworthy-differences-:","page":"Julia language basics","title":"Really noteworthy differences :","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"Array indexing starts at 1.","category":"page"},{"location":"prerequisites/julia_basics/#Typing","page":"Julia language basics","title":"Typing","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Custom-types","page":"Julia language basics","title":"Custom types","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Dictionaries","page":"Julia language basics","title":"Dictionaries","text":"","category":"section"},{"location":"prerequisites/julia_basics/","page":"Julia language basics","title":"Julia language basics","text":"PlantSimEngine makes use of dictionaries to declare and store data, indexed by scale/organ. For example : ","category":"page"},{"location":"prerequisites/julia_basics/#Functions","page":"Julia language basics","title":"Functions","text":"","category":"section"},{"location":"prerequisites/julia_basics/#Function-arguments-and-kwargs","page":"Julia language basics","title":"Function arguments and kwargs","text":"","category":"section"},{"location":"prerequisites/julia_basics/#NamedTuples","page":"Julia language basics","title":"NamedTuples","text":"","category":"section"},{"location":"step_by_step/implement_a_model/#model_implementation_page","page":"Implementing a model","title":"Model implementation in 5 minutes","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"using PlantSimEngine\n@process \"light_interception\" verbose = false\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"You'll probably want to move beyond simple usage at some point and implement your own models.","category":"page"},{"location":"step_by_step/implement_a_model/#Quick-version","page":"Implementing a model","title":"Quick version","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare a new process : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare your model struct, and its parameters : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Declare the inputs_ and outputs_ methods for that model (note the '_', these methods are distinct from inputs and outputs)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Write the run! function that operates on a single timestep : ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Determine if parallelization is possible, and which traits to declare :","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"And that is all you need to get going, for this simple example with a single parameter and no interdependencies. ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The @process macro does some boilerplate work described here","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If you have more than one parameter, then type conversion utility functions might also be interesting to implement. See here TODO If you need to deal with more complex couplings, the hard dependency section will detail","category":"page"},{"location":"step_by_step/implement_a_model/#Detailed-version","page":"Implementing a model","title":"Detailed version","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.","category":"page"},{"location":"step_by_step/implement_a_model/#Inspiration","page":"Implementing a model","title":"Inspiration","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If you want to implement a new model, the best way to do it is to start from another implementation.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For a complete example, you can look at the code in PlantBiophysics.jl, were you will find e.g. a photosynthesis model, with the implementation of the FvCB model in this Julia file: src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine also provide toy models that can be used as a base to better understand how to implement a new model: ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The Beer model for light interception in examples/Beer.jl\nA toy LAI development in examples/ToyLAIModel.jl","category":"page"},{"location":"step_by_step/implement_a_model/#Requirements","page":"Implementing a model","title":"Requirements","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"In those files, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see Implementing a new process).","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"In this page, we'll just implement a model for a process that already exists: the light interception. This process is defined in PlantBiophysics.jl, and also made available as an example model from the Examples sub-module. You can access the script from here: examples/Beer.jl.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We can import the model like so:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"But instead of just using it, we will review the script line by line.","category":"page"},{"location":"step_by_step/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Implementing a model","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"step_by_step/implement_a_model/#The-process","page":"Implementing a model","title":"The process","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We declare the light interception process at l.7 using @process: ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"See Implementing a new process for more details on how that works and how to use the process.","category":"page"},{"location":"step_by_step/implement_a_model/#The-structure","page":"Implementing a model","title":"The structure","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"hold the parameter values\ndispatch to the right run! method when calling it","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The structure of the model (or type) is defined as follows:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The first line defines the name of the model (Beer), which is completely free, except it is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. ","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"We also can see that we define the Beer structure as a subtype of AbstractLight_InterceptionModel. This step is very important as it tells to the package what kind of process the model simulates. AbstractLight_InterceptionModel is automatically created when defining the process \"light_interception\".","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"In our case, it tells us that Beer is a model to simulate the light interception process.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Then comes the parameters names, and their types. The type of parameters is given by the user at instantiation in our example. This is done using the T notation as follows:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"we say that our structure Beer is a parameterized struct by putting T in between brackets after the name of the struct\nWe put ::T after our parameter name in the struct. This way Julia knows that our parameter will be of type T.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The T is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct YourStruct{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"But why not force the type ? Such as in the following example :","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Well, you can do that. But you'll lose a lot of the magic Julia has to offer this way.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For example a user could use the Particles type from MonteCarloMeasurements.jl to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.","category":"page"},{"location":"step_by_step/implement_a_model/#The-method","page":"Implementing a model","title":"The method","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The models are implemented by adding a method for its type to the run! function. The exclamation point at the end of the function name is used in Julia to tell users that the function is mutating, i.e. it modifies its input.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The function takes six arguments:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"the type of your model\nmodels: a ModelList object, which contains all the models of the simulation\nstatus: a Status object, which contains the current values (i.e. state) of the variables for one time-step (e.g. the value of the plant LAI at time t)\nmeteo: (usually) an Atmosphere object, or a row of the meteorological data, which contains the current values of the meteorological variables for one time-step (e.g. the value of the PAR at time t)\nconstants: a Constants object, or a NamedTuple, which contains the values of the constants for the simulation (e.g. the value of the Stefan-Boltzmann constant)\nextras: any other object you want to pass to your model. This is for advanced users, and is not used in this example. Note that it is used to pass the Node when simulating a MultiScaleTreeGraph.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Your implementation can use any variables or parameters in these objects. The only thing you have to do is to make sure that the variables you use are defined in the Status object, the meteorology, and the Constants object.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The variables you use from the Status must be declared as inputs of your model. And the ones you modify must be declared as outputs. We'll that below.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"warning: Warning\nModels implementations are done for one time-step by design. The values of the previous time-step is always available in the status (e.g. status.biomass) as long as the variable is an output of your model. This is because at the end of a time-step, the Status object is recycled for the next time-step and so the latest computed values are always available. This is why it is possible to increment a value every time-step using e.g. status.biomass += 1.0. By design models don't have access to values prior to the one before. If you're not convinced by this approach, ask yourself how the plant knows the value of e.g. LAI from 15 days ago. It doesn't. It only knows its current state. Most of the time-sensitive variables really are just an accumulation of values until a threshold anyway. BUt if you really need to use values from the past (e.g. 15 time-steps before), you can add a variable to the Status object that is uses like a queue (see e.g. DataStructures.jl).","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine then automatically deals with every other detail, such as checking that the object is correctly initialized, applying the computations over objects and time-steps. This is nice because as a developer you don't have to deal with those details, and you can just concentrate on your model implementation.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"warning: Warning\nYou need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"So let's do it! Here is our own implementation of the light interception for a ModelList component models:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The first argument (::Beer) means this method will only execute when the function is called with a first argument that is of type Beer. This is our way of telling Julia that this method implements the Beer model for the light interception process.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"An important thing to note is that the model parameters are available from the ModelList that is passed via the models argument. Then parameters are found in field called by the process name, and the parameter name. For example, the k parameter of the Beer model is found in models.light_interception.k.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"One last thing to do is to define the inputs and outputs of our model. This is done by adding a method for the inputs and outputs functions. These functions take the type of the model as argument, and return a NamedTuple with the names of the variables as keys, and their default values as values.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"In our case, the Beer model has one input and one output:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Inputs: :LAI, the leaf area index (m² m⁻²)\nOutputs: :aPPFD, the photosynthetic photon flux density (μmol m⁻² s⁻¹)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Here is how we communicate that to PlantSimEngine:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Note that both functions end with an \"_\". This is because these functions are internal, they will not be called by the users directly. Users will use inputs and outputs instead, which call inputs_ and outputs_, but stripping out the default values.","category":"page"},{"location":"step_by_step/implement_a_model/#The-utility-functions","page":"Implementing a model","title":"The utility functions","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Before running a simulation, you can do a little bit more for your implementation (optional).","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"First, you can add a method for type promotion. It wouldn't make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"struct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To add type promotion to Beer2 we would do:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"function Beer2(k,x)\n    Beer2(promote(k,x))\nend","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Beer2(0.6,2)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"You don't see a problem? Well your users won't either. But there's one: Beer2 is a parametric type, so all fields share the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this force the user to give all parameters with the same type.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"And in our example above, the user provides 0.6 for k, which is a Float64, and 2 for x, which is an Int. ANd if you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert 2 to 2.0.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of k. So we can provide a default value like so:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Beer() = Beer(0.6)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Now the user can call Beer with zero value, and k will default to 0.6.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Another useful thing is the ability to instantiate your model type with keyword arguments, i.e. naming the arguments. You can do it by adding the following method:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Beer(;k) = Beer(k)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Did you notice the ; before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call Beer like this:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Beer(k = 0.7)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"The last optional thing to implement is a method for the eltype function:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Base.eltype(x::Beer{T}) where {T} = T","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"This one helps Julia know the type of the elements in the structure, and make it faster.","category":"page"},{"location":"step_by_step/implement_a_model/#Traits","page":"Implementing a model","title":"Traits","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (i.e. objects) and/or time (i.e. time-steps).","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"By default, all models are assumed to be not parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"For example, if we want to add the trait for parallelization over objects to our Beer model, we would do:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"And if we want to add the trait for parallelization over time-steps to our Beer model, we would do:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"note: Note\nA model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"OK that's it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue.","category":"page"},{"location":"step_by_step/implement_a_model/#Dependencies","page":"Implementing a model","title":"Dependencies","text":"","category":"section"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"To do so, we can add a method to the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"step_by_step/implement_a_model/","page":"Implementing a model","title":"Implementing a model","text":"You can read more about hard dependencies in Coupling more complex models.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Tips-and-workarounds","page":"Tips and Workarounds","title":"Tips and workarounds","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#PlantSimEngine-is-actively-being-developed","page":"Tips and Workarounds","title":"PlantSimEngine is actively being developed","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"PlantSimEngine, despite the somewhat abstract codebase and generic simulation ambitions, is quite grounded in reality. There IS a desire to accomodate for a wide range of possible simulations, without constraining the user too much, but most features are developed on an as-needed basis, and grow out of necessity, partly from the requirements of an increasingly complex and refined implementation of an oil palm model, XPalm.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Since the oil palm model is actively being developed, and some features aren't ready in PlantSimEngine, or require a lot of rewriting that we're not certain would be worth it (especially if it ends up constraining the codebase or what the user can do), some workarounds and shortcuts are occasionally used to circumvent a limitation. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"There are also a couple of features that are quick hacks or that are meant for quick and dirty prototyping, not for production. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"We'll list a few of them here, and will likely add some entry in the future listing some built-in limitations or implicit expectations of the package.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Making-use-of-past-states-in-multi-scale-simulations","page":"Tips and Workarounds","title":"Making use of past states in multi-scale simulations","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It is possible to make use of the value of a variable in the past simulation timestep via the PreviousTimeStep mechanism in the mapping API (In fact, as mentioned elsewhere, it is the default way to break undesirable cyclic dependencies that can come up when coupling models, see : Avoiding cyclic dependencies).","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"However, it is not possible to go beyond that through the mapping API. Something like PreviousTimeStep(PreviousTimeStep(PreviousTimeStep(:carbon_biomass))) is not supported. Don't do that.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One way to access prior variable states is simply to write an ad hoc model that stores a few values into an array or however many variables you might need, which you can then update every timestep and feed into other models that might need it.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Having-a-variable-simultaneously-as-input-and-output-of-a-model","page":"Tips and Workarounds","title":"Having a variable simultaneously as input and output of a model","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One current limitation of PlantSimEngine that can be occasionally awkward is that using the same variable name as input and output in a single model is unsupported. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"(On a related note : it is not possible to have two variables with the same name in the same scale. They are considered as the same variable.)","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"The reason being that it is usually impossible to automatically determine how the coupling is supposed to work out, when other dependencies latch onto such a model. The user would have to explicitely declare some order of simulation between several models, and some amount of programmer work would also be necessary to implement that extra API feature into PlantSimEngine.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"We haven't found an approach that was fully satisfactory from both a code simplicity and an API convenience POV. Especially when prototyping and adding in new models, as that might require redeclaring the simulation order for those specific variables.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"There are two workarounds : ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"One awkward approach is to rename one of the variables. It is not ideal, of course, as it means you might not be able to use a predefined model 'out of the box', but it does not have any of the tradeoffs and constrained mentioned above.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"In many other situations one can work with what PlantSimEngine already provides.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"For example, one model in XPalm.jl handles leaf pruning, affecting biomass. A straightforward implementation would be to have a leaf_biomass variable as both input and output. The workaround is to instead output a variable leaf_biomass_pruning_loss and to have that as input in the next timestep to compute the new leaf biomass.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Passing-in-a-vector-in-a-mapping-status-at-a-specific-scale","page":"Tips and Workarounds","title":"Passing in a vector in a mapping status at a specific scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"You may have noticed that sometimes a vector (1-dimensional array) variable is passed into the status component of a ModelList in documentation examples (An example here with cumulative thermal time : Model switching).","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"This is practical for simple simulations, or when quickly prototyping, to avoid having to write a model specifically for it. Whatever models make use of that variable are provided with one element corresponding to the current timestep every iteration.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"In multi-scale simulations, this feature is also supported, though not part of the main API. The way outputs and statuses work is a little different, so that little convenience feature is not as straightforward. ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It is more brittle, makes use of not-recommended Julia metaprogramming features (eval()), fiddles with global variables, might not work outside of a REPL environment and is not tested for more complex interactions, so it may interact badly with variables that are mapped to different scales or in bizarre dependency couplings.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Due to, uh, implementation quirks, the way to use this is as follows : ","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Call the function replace_mapping_status_vectors_with_generated_models(mapping_with_vectors_in_status, timestep_model_organ_level, nsteps)on your mapping.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"It will parse your mapping, generate custom models to store and feed the vector values each timestep, and return the new mapping you can then use for your simulation. It also slips in a couple of internal models that provide the timestep index to these models (so note that symbols :current_timestep and :next_timestep will be declared for that mapping). You can decide which scale/organ level you want those models to be in via the timestep_model_organ_levelparameter. nstepsis used as a sanity check, and expects you to provide the amount of simulation timesteps.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"note: Note\nOnly subtypes of AbstractVector present in statuses will be affected. In some cases, meteo values might need a small conversion. For instance : meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18) status(TT_cu=cumsum(meteo_day.TT),)cumsum(meteoday.TT) actually returns a CSV.SentinelArray.ChainedVectors{T, Vector{T}}, which is not a subtype of AbstractVector.  Replacing it with Vector(cumsum(meteoday.TT)) will provide an adequate type.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"This feature is likely to break in simulations that make use of planned future features (such as mixing models with different timesteps), without guarantee of a fix on a short notice. Again, bear in mind it is mostly a convenient shortcut for prototyping, when doing multi-scale simulations.","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"TODO examples of other ad hoc models TODO state machines ? TODO workaround status initialisation bug ?","category":"page"},{"location":"troubleshooting_and_testing/tips_and_workarounds/#Cyclic-dependencies-in-single-scale-simulations","page":"Tips and Workarounds","title":"Cyclic dependencies in single-scale simulations","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds/","page":"Tips and Workarounds","title":"Tips and Workarounds","text":"Cyclic dependencies can happen in single-scale simulations, but the PreviousTimestep feature currently isn't available. Hard dependencies are one way to deal with them, creating a multi-scale simulation with a single effective scale is also an option.","category":"page"},{"location":"multiscale/multiscale/#Multi-scale-modeling","page":"Detailed example","title":"Multi-scale modeling","text":"","category":"section"},{"location":"multiscale/multiscale/#Moving-to-multi-scale","page":"Detailed example","title":"Moving to multi-scale","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"PlantSimEngine provides a framework for multi-scale modeling to seamlessly integrate models at different scales, keeping all nice functionalities provided at one scale. A nice feature is that many models do not need to be aware of the scale at which they are running, nor about the scales at which their inputs are computed, or outputs will be given, which means those models can be reused at different scales or in single-scale simulations.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"PlantSimEngine automatically computes the dependency graph between mono and multi-scale models, considering every combination of models at any scale, to determine the order of model execution. This means that the user does not need to worry about the order of model execution and can focus on the model definition and the mapping between models and scales.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Using PlantSimEngine for multi-scale modeling is relatively easy and mostly follows the same rules as mono-scale models. Let's dive into the details with a short tutorial.","category":"page"},{"location":"multiscale/multiscale/#Simple-mapping-between-models-and-scales","page":"Detailed example","title":"Simple mapping between models and scales","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"To get started, we have to define a mapping between models and scales.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Let's import the PlantSimEngine package and example models we will use in this tutorial:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"using PlantSimEngine\nusing PlantSimEngine.Examples # Import some example models","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"note: Note\nThe Examples submodule exports a few simple models we will use in this tutorial. The models are also found in the examples folder of the package.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"We now have access to models for the simulation of different processes. We can associate each model with a scale by defining a mapping between models and scales. The mapping is a dictionary with the name of the scale as the key and the model as the value. For example, we can define a mapping to simulate the assimilation process at the leaf scale with ToyAssimModel as follows:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"mapping = Dict(\"Leaf\" => ToyAssimModel())","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"In this example, the dictionary's key is the name of the scale (\"Leaf\"), and the value is the model. The model is an example model provided by PlantSimEngine, so we must prefix it with the module name.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"We can check if the mapping is valid by calling to_initialize:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"The to_initialize function checks if models from any scale need further initialization before simulation. This is the case when some input variables of the model are not computed by another model. In this example, the ToyAssimModel needs :aPPFD and :soil_water_content as inputs. To run a simulation, we must provide a value for the variables or a model that simulates them.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"The initialization values for the variables can be provided using the Status type along with the model, e.g.:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"mapping = Dict(\n    \"Leaf\" => (\n        ToyAssimModel(),\n        Status(aPPFD=1300.0, soil_water_content=0.5),\n    ),\n)","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"note: Note\nThe model and the Status are provided as a Tuple to the \"Leaf\" scale.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"If we re-execute to_initialize, we get an empty dictionary, meaning the mapping is valid, and we can start the simulation:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/#Multiscale-mapping-between-models-and-scales","page":"Detailed example","title":"Multiscale mapping between models and scales","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"In our previous example, we provided the value for the soil_water_content variable. However, we could also provide a model that simulates it at the soil scale. The only difference now is that we have to tell PlantSimEngine that our  ToyAssimModel is now multiscale and takes the soil_water_content variable from the \"Soil\" scale. We can do that by wrapping the ToyAssimModel in a MultiScaleModel:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"mapping = Dict(\n    \"Soil\" => ToySoilWaterModel(),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\" => :soil_water_content,],\n        ),\n        Status(aPPFD=1300.0),        \n    ),\n);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"The MultiScaleModel takes two arguments: the model and the mapping between the model and the scales. The mapping is a vector of pairs of pairs mapping the variable's name with the name of the scale its value comes from, and the name of the variable at that scale. In this example, we map the soil_water_content variable at scale \"Leaf\" to the soil_water_content variable at the \"Soil\" scale. If the name of the variable is the same between both scales, we can omit the variable name at the origin scale, e.g. [:soil_water_content => \"Soil\"].","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"note: Note\nThe variable aPPFD is still provided in the Status type as a constant value.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"We can check again if the mapping is valid by calling to_initialize:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"to_initialize(mapping)","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"to_initialize returns an empty dictionary, meaning the mapping is valid.","category":"page"},{"location":"multiscale/multiscale/#More-on-MultiScaleModel","page":"Detailed example","title":"More on MultiScaleModel","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"MultiScaleModel is a wrapper around a model that allows it to take inputs or give outputs from other scales. It takes two arguments: the model and the mapping between the model and the scales. The mapping is a vector of pairs of pairs mapping the variable's name with the name of the scale its value comes from, and its name at that scale.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"The variable can map a single value if there is only one node to map to or a vector of values if there are several. It can also map to several types of nodes at the same time.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Let's take a look at a more complex example of a mapping:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapping=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\", :aPPFD => \"Plant\"],\n        ),\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=0.5),\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"In this example, we expect to make a simulation at five different scales: \"Scene\", \"Plant\", \"Internode\", \"Leaf\", and \"Soil\". The \"Scene\" scale represents the whole scene, where one or several plants can live. The \"Plant\" scale is, well, the whole plant scale, \"Internode\" and \"Leaf\" are organ scales, and \"Soil\" is the soil scale. This mapping is used to compute the carbon allocation (ToyCAllocationModel) to the different organs of the plant (\"Leaf\" and \"Internode\") from the assimilation at the \"Leaf\" scale (i.e. the offer) and their carbon demand (ToyCDemandModel). The \"Soil\" scale is used to compute the soil water content (ToySoilWaterModel), which is needed to calculate the assimilation at the \"Leaf\" scale (ToyAssimModel). We also can note that we compute the maintenance respiration at the \"Leaf\" and \"Internode\" scales (ToyMaintenanceRespirationModel), which is summed up to compute the total maintenance respiration at the \"Plant\" scale (ToyPlantRmModel). ","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"We see that all scales are interconnected, with computations at the organ scale that may depend on the soil scale and at the plant scale that depends on the organ scale and scene scale.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Something important to note here is that we have different ways to define the mapping for the MultiScaleModel. For example, we have :carbon_assimilation => [\"Leaf\"] at the plant scale for ToyCAllocationModel. This mapping means that the variable carbon_assimilation is mapped to the \"Leaf\" scale. However, we could also have :carbon_assimilation => \"Leaf\", which is not completely equivalent.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"note: Note\nNote the difference between :carbon_assimilation => [\"Leaf\"] and :carbon_assimilation => \"Leaf\" is that \"Leaf\" is given as a vector in the first definition, and as a scalar in the second one.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"The difference is that the first one maps to a vector of values, while the second one maps to a single value. The first one is useful when we don't know how many nodes there will be in the plant of type \"Leaf\". In this case, the values are available as a vector in the carbon_assimilation variable of the status inside the model. The second one should only be used if we are sure that there will be only one node at this scale, and in this case, the one and single value is given as a scalar in the carbon_assimilation variable of the status inside the model.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"A third form for the mapping would be :carbon_assimilation => [\"Leaf\", \"Internode\"]. This form is useful when we need values for a variable from several scales simultaneously. In this case, the values are available as a vector in the carbon_assimilation variable of the status inside the model, sorted in the same order as nodes are traversed in the graph.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"A last form is to map to a specific variable name at the target scale, e.g. :Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]. This form is useful when the variable name is different between scales, and we want to map to a specific variable name at the target scale. In this example, the variable Rm_organs at plant scale takes its values (is mapped) from the variable Rm at the \"Leaf\" and \"Internode\" scales.","category":"page"},{"location":"multiscale/multiscale/#Running-a-simulation","page":"Detailed example","title":"Running a simulation","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Now that we have a valid mapping, we can run a simulation. Running a multiscale simulation requires two more things compared to what we saw previously: a plant graph and the definition of the output variables we want dynamically for each scale.","category":"page"},{"location":"multiscale/multiscale/#Plant-graph","page":"Detailed example","title":"Plant graph","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"We can import an example multi-scale tree graph like so:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"mtg = import_mtg_example()","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"note: Note\nYou can use import_mtg_example only if you previously imported the Examples sub-module of PlantSimEngine, i.e. using PlantSimEngine.Examples.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"This graph has a root node that defines a scene, then a soil, and a plant with two internodes and two leaves.","category":"page"},{"location":"multiscale/multiscale/#Output-variables","page":"Detailed example","title":"Output variables","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Models can access only one time step at a time, so the output at the end of a simulation is only the last time step. However, we can define a list of variables we want to get dynamically for each time step and each scale. This list is given as a dictionary with the name of the scale as the key and a vector of variables as the value. For example, we can define a list of variables we want to get at each time step for different scales as follows:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"outs = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"These variables will be available in the output returned by run!, with a value for each time step. ","category":"page"},{"location":"multiscale/multiscale/#Meteorological-data","page":"Detailed example","title":"Meteorological data","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"As for mono-scale models, we need to provide meteorological data to run a simulation. We can use the PlantMeteo package to generate some dummy data for two time steps:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f = 200.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f = 180.0)\n]\n)","category":"page"},{"location":"multiscale/multiscale/#Simulation","page":"Detailed example","title":"Simulation","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Let's make a simulation using the graph and outputs we just defined:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"outputs_sim = run!(mtg, mapping, meteo, tracked_outputs = outs);\nnothing # hide","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"And that's it! We can now access the outputs for each scale as a dictionary of vectors of values per variable and scale.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"Or as a DataFrame using the DataFrames package:","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"using DataFrames\nconvert_outputs(outputs_sim, DataFrame)","category":"page"},{"location":"multiscale/multiscale/#Wrapping-up","page":"Detailed example","title":"Wrapping up","text":"","category":"section"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"In this section, we saw how to define a mapping between models and scales, run a simulation, and access the outputs.","category":"page"},{"location":"multiscale/multiscale/","page":"Detailed example","title":"Detailed example","text":"This is just a simple example, but PlantSimEngine can be used to define and combine much more complex models at multiple scales of detail. With its modular architecture and intuitive API, PlantSimEngine is a powerful tool for multi-scale plant growth and development modeling.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Quick-examples","page":"Quick examples","title":"Quick examples","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"This page is meant for people who have set up their environment and just want to copy-paste an example or two, see what the REPL returns and start tinkering. ","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"If you are less comfortable with Julia, or need to set up an environment first, see this page : Getting started with Julia. If you wish for a more detailed rundown of the examples, you can instead have a look at the [step by step][#stepbystep] section, which will go into more detail.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"These examples are all for single-scale simulations. For multi-scale modelling tutorials and examples, refer to [this section][#multiscale]","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"You can find the implementation for these example models, as well as other toy models in the examples folder.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Example-with-a-single-light-interception-model-and-a-single-weather-timestep","page":"Quick examples","title":"Example with a single light interception model and a single weather timestep","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout = run!(leaf, meteo)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-model-with-a-Leaf-Area-Index-model","page":"Quick examples","title":"Coupling the light interception model with a Leaf Area Index model","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"The weather data in this example contains data over 365 days, meaning the simulation will have as many timesteps.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine\nusing PlantMeteo, CSV\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Coupling-the-light-interception-model-with-a-Leaf-Area-Index-model-2","page":"Quick examples","title":"Coupling the light interception model with a Leaf Area Index model","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantSimEngine\nusing PlantMeteo, CSV\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/#Example-using-PlantBioPhysics","page":"Quick examples","title":"Example using PlantBioPhysics","text":"","category":"section"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"A companion package, PlantBioPhysics, uses PlantSimEngine, and contains other models used in ecophysiological simulations.","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"You can have a look at its documentation here","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"Several example simulations are provided there. Here's one taken from this page : ","category":"page"},{"location":"step_by_step/quick_and_dirty_examples/","page":"Quick examples","title":"Quick examples","text":"using PlantBiophysics, PlantSimEngine\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        Monteith(),\n        Fvcb(),\n        Medlyn(0.03, 12.0),\n        status = (Ra_SW_f = 13.747, sky_fraction = 1.0, aPPFD = 1500.0, d = 0.03)\n    )\n\nout = run!(leaf,meteo)","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Include the model definition from the examples folder:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nsim_outputs = run!(model, meteo_day)\n","category":"page"},{"location":"working_with_data/visualising_outputs/#Visualizing-outputs","page":"Visualizing outputs","title":"Visualizing outputs","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"TODO example environment ?","category":"page"},{"location":"working_with_data/visualising_outputs/#Output-structure","page":"Visualizing outputs","title":"Output structure","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"PlantSimEngine's run! functions return for each timestep the state of the variables that were requested using the tracked_outputs kwarg (or the state of every variable if this kwarg was left unspecified). Multi-scale simulations also indicate which organ and MTG node these state variables are related to.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"Here's an example indicating how to plot output data using CairoMakie, a package used for plotting.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Include the model definition from the examples folder:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nsim_outputs = run!(model, meteo_day)\n","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"The output data is displayed as :","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"TimeStepTable{Status{(:TT_cu, :LAI...}(365 x 3):\n╭─────┬────────────────┬────────────┬───────────╮\n│ Row │ TT_cu │        LAI │     aPPFD │\n│     │        Float64 │    Float64 │   Float64 │\n├─────┼────────────────┼────────────┼───────────┤\n│   1 │            0.0 │ 0.00554988 │ 0.0476221 │\n│   2 │            0.0 │ 0.00554988 │ 0.0260688 │\n│   3 │            0.0 │ 0.00554988 │ 0.0377774 │\n│   4 │            0.0 │ 0.00554988 │ 0.0468871 │\n│   5 │            0.0 │ 0.00554988 │ 0.0545266 │\n│  ⋮  │       ⋮        │     ⋮      │     ⋮     │\n╰─────┴────────────────┴────────────┴───────────╯\n                                 360 rows omitted","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"And using CairoMakie, one can plot out selected variables :","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"# Plot the results:\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, model[:TT_cu], model[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, model[:TT_cu], model[:aPPFD], color=:firebrick1)\n\nfig","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"TODO ! LAI Growth and light interception ../examples/LAI_growth2.png","category":"page"},{"location":"working_with_data/visualising_outputs/#TimeStepTables-and-DataFrames","page":"Visualizing outputs","title":"TimeStepTables and DataFrames","text":"","category":"section"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"The output data is usually stored in a TimeStepTable structure defined in PlantMeteo.jl, which is a fast DataFrame-alike structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. Weather data is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"TODO example extracting specific variables","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"Another simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"using DataFrames\nPlantSimEngine.convert_outputs(sim_outputs, DataFrame)","category":"page"},{"location":"working_with_data/visualising_outputs/","page":"Visualizing outputs","title":"Visualizing outputs","text":"TODO other examples ?","category":"page"},{"location":"multiscale/multiscale_example_2/#Expanding-on-the-multiscale-simulation","page":"Expanding the plant simulation","title":"Expanding on the multiscale simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Let's build on the previous example and add some other organ growth, as well as some very mild coupling between the two.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"You can find the full script for this simulation in the ToyMultiScalePlantModel subfolder of the examples folder.","category":"page"},{"location":"multiscale/multiscale_example_2/#Adding-roots-to-our-plant","page":"Expanding the plant simulation","title":"Adding roots to our plant","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"We'll add a root that extracts water and adds it to the stock. Initial water stocks are low, so root growth is prioritized, then the plant also grows leaves and a new internode like it did before. Roots only grow up to a certain point, and don't branch.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"This leads to adding a new scale, \"Root\" to the mapping, as well as two more models, one for water absorption, the other for root growth. Other models are updated here and there to account for water. The carbon capture model remains unchanged.","category":"page"},{"location":"multiscale/multiscale_example_2/#Root-models","page":"Expanding the plant simulation","title":"Root models","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Water-absorption","page":"Expanding the plant simulation","title":"Water absorption","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Let's implement a very fake model of root water absorption. It'll capture the amount of precipitation in the weather data multiplied by some assimilation factor.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"PlantSimEngine.@process \"water_absorption\" verbose = false\n\nstruct ToyWaterAbsorptionModel <: AbstractWater_AbsorptionModel\nend\n\nPlantSimEngine.inputs_(::ToyWaterAbsorptionModel) = (root_water_assimilation=1.0,)\nPlantSimEngine.outputs_(::ToyWaterAbsorptionModel) = (water_absorbed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyWaterAbsorptionModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_absorbed = meteo.Precipitations * status.root_water_assimilation\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Root-growth","page":"Expanding the plant simulation","title":"Root growth","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The root growth model is similar to the internode growth one : it checks for a water threshold and that there is enough carbon, and adds a new organ to the MTG if the maximum length hasn't been reached.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"It also makes use of a couple of helper functions to find the end root and compute root length : ","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"function get_root_end_node(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\", filter_fun = MultiScaleTreeGraph.isleaf)\nend\n\nfunction get_roots_count(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return length(MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\"))\nend\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel <: AbstractRoot_GrowthModel\n    water_threshold::Float64\n    carbon_root_creation_cost::Float64\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = (water_stock=0.0,carbon_stock=0.0,)\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        \n        root_end = get_root_end_node(status.node)\n        \n        if length(root_end) != 1 \n            throw(AssertionError(\"Couldn't find MTG leaf node with symbol \\\"Root\\\"\"))\n        end\n        root_len = get_roots_count(root_end[1])\n        if root_len < m.root_max_len\n            st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n            status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n        end\n    else\n        status.carbon_root_creation_consumed = 0.0\n    end\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Updating-other-models-to-account-for-water","page":"Expanding the plant simulation","title":"Updating other models to account for water","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/#Resource-storage","page":"Expanding the plant simulation","title":"Resource storage","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Water absorbed must now be accumulated, and root carbon creation costs taken into account.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"PlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(water_absorbed=0.0,carbon_captured=0.0,carbon_organ_creation_consumed=0.0,carbon_root_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (water_stock=-Inf,carbon_stock=-Inf)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_stock += sum(status.water_absorbed)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed) - sum(status.carbon_root_creation_consumed)\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Internode-creation","page":"Expanding the plant simulation","title":"Internode creation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The minor chagne is that new organs are now created only if the water stock is above a given threshold.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"struct ToyCustomInternodeEmergence <: AbstractOrgan_EmergenceModel\n    TT_emergence::Float64\n    carbon_internode_creation_cost::Float64\n    leaf_surface_area::Float64\n    leaves_max_surface_area::Float64\n    water_leaf_threshold::Float64\nend\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0,leaves_max_surface_area=100.0,\nwater_leaf_threshold=30.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area, water_leaf_threshold)\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0,water_stock=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if water levels are low, prioritise roots\n    if status.water_stock < m.water_leaf_threshold\n        return nothing\n    end\n\n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"page"},{"location":"multiscale/multiscale_example_2/#Updating-the-mapping","page":"Expanding the plant simulation","title":"Updating the mapping","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"The resource storage and internode emergence models now need a couple of extra water-related mapped variables.  The \"Root\" organ is added to the mapping with its own models. New parameters need to be initialized.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"mapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapping=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>[\"Root\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),\n            mapping=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:water_stock)=>\"Plant\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" => ( MultiScaleModel(\n            model=ToyRootGrowthModel(10.0, 50.0, 10),\n            mapping=[PreviousTimeStep(:carbon_stock)=>\"Plant\",\n            PreviousTimeStep(:water_stock)=>\"Plant\"],\n        ),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)","category":"page"},{"location":"multiscale/multiscale_example_2/#Running-the-simulation","page":"Expanding the plant simulation","title":"Running the simulation","text":"","category":"section"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Running this new simulation is almost the same as before. The weather data is unchanged, but a new \"Root\" node was added to the MTG.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    plant_root_start = MultiScaleTreeGraph.Node(\n        plant, \n        MultiScaleTreeGraph.NodeMTG(\"+\", \"Root\", 1, 3), \n    )\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    \nouts = run!(mtg, mapping, meteo_day)","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"And that's it ! We now have a plant with two different growth directions. Roots are added at the beginning, until water is considered abundant enough.","category":"page"},{"location":"multiscale/multiscale_example_2/","page":"Expanding the plant simulation","title":"Expanding the plant simulation","text":"Of course, there are several design issues with this implementation. It is as utterly unrealistic as the previous one, and doesn't even consume water. ","category":"page"},{"location":"step_by_step/simple_model_coupling/#Standard-model-coupling","page":"Coupling","title":"Standard model coupling","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\nusing DataFrames\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nnothing","category":"page"},{"location":"step_by_step/simple_model_coupling/#ModelList","page":"Coupling","title":"ModelList","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"The ModelList is a container that holds a list of models, their parameter values, and the status of the variables associated to them.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"If one looks at prior examples, the Modellists so far have only contained a single model, whose input variables are initialised in the Modellist status keyword argument. ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Example models are all taken from the example scripts in the examples folder.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a first ModelList declaration with a light interception model, requiring input Leaf Area Index : ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"leaf = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a second one with a Leaf Area Index model, with some example Cumulated Thermal Time as input. (This TT_cu is usually computed from weather data):","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"model = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)","category":"page"},{"location":"step_by_step/simple_model_coupling/#Combining-models","page":"Coupling","title":"Combining models","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Suppose we want our ToyLAIModel() to compute the LAI for the light interception model. ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"We can couple the two models by having them be part of a single ModelList. The LAI variable will then be a coupled output-input and no longer will need to be declared.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Here's a first attempt : ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=1.0:2000.0,),\n)\n\nrun!(models)","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Oops, we get an error related to the weather data : ","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"ERROR: type NamedTuple has no field Ri_PAR_f\nStacktrace:\n  [1] getindex(mnt::Atmosphere{(), Tuple{}}, i::Symbol)\n    @ PlantMeteo ~/Documents/CIRAD/dev/PlantMeteo/src/structs/atmosphere.jl:147\n  [2] getcolumn(row::PlantMeteo.TimeStepRow{Atmosphere{(), Tuple{}}}, nm::Symbol)\n    @ PlantMeteo ~/Documents/CIRAD/dev/PlantMeteo/src/structs/TimeStepTable.jl:205\n    ...","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"The Beer() model requires a specific meteorological parameter. Let's fix that by importing the example weather data :","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"using PlantSimEngine\n\n# PlantMeteo and CSV packages are now used\nusing PlantMeteo, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import example weather data\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# A ModelList with two coupled models\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),), # We can now compute a genuine cumulative thermal time from the weather data\n)\n\n# Add the weather data to the run! call\noutputs_coupled = run!(models, meteo_day)\n","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"And there you have it. The light interception model made its computations using the Leaf Area Index computed by ToyLAIModel.","category":"page"},{"location":"step_by_step/simple_model_coupling/#Further-coupling","page":"Coupling","title":"Further coupling","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"Of course, one can keep adding models. Here's an example ModelList with another model, ToyRUEGrowthModel, which computes the carbon biomass increment caused by photosynthesis.","category":"page"},{"location":"step_by_step/simple_model_coupling/","page":"Coupling","title":"Coupling","text":"models = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"model_execution/#Model-execution","page":"Execution","title":"Model execution","text":"","category":"section"},{"location":"model_execution/#Simulation-order","page":"Execution","title":"Simulation order","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the ModelList to automatically compute a dependency graph between the models and run the simulation in the correct order. When running a simulation with run!, the models are then executed following this simple set of rules:","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Independent models are run first. A model is independent if it can be run independently from other models, only using initializations (or nothing). \nThen, models that have a dependency on other models are run. The first ones are the ones that depend on an independent model. Then the ones that are children of the second ones, and then their children ... until no children are found anymore. There are two types of children models (i.e. dependencies): hard and soft dependencies:\nHard dependencies are always run before soft dependencies. A hard dependency is a model that list dependencies in their own method for dep. See this example that shows Process2Model defining a hard dependency on any model that simulate process1. Inner hard dependency graphs (i.e. consecutive hard-dependency children) are considered as a single soft dependency.\nSoft dependencies are then run sequentially. A model has a soft dependency on another model if one or more of its inputs is computed by another model. If a soft dependency has several parent nodes (e.g. two different models compute two inputs of the model), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"},{"location":"multiscale/multiscale_coupling/#Handling-dependencies-in-a-multiscale-context","page":"Multiscale coupling considerations","title":"Handling dependencies in a multiscale context","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/#Scalar-and-vector-variable-mappings","page":"Multiscale coupling considerations","title":"Scalar and vector variable mappings","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the detailed example discussed previously (TODO), there were several instances of mapping a variable from one scale to another. Here's a relevant exerpt from the mapping : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"\"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapping=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        ...\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        ...\n    ),","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"For flexibility reasons, instead of explicitely linking most models from different scales together, one only declares which variables are meant to be taken from another scale (or more accurately, a model at a different scale outputting those variables). This keeps the convenience of switching models while making few changes to the mapping. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"However, PlantSimEngine cannot infer which scales have multiple instances, and which are single-instance, as the scale names are user-defined.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the above example, there is only one scene at the \"Scene\", and one plant at the \"Plant\" scale, meaning the TT_cu variable mapped between the two has a one-to-one scalar-to-scalar correspondance.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"On the other hand, the carbon_assimilation variable is computed for every leaf, of which there could be hundreds, or thousands, giving a scalar-to-vector correspondance. The carbon assimilation model runs many times every timestep, whereas the carbon allocation model only runs once per timestep. There may be initially be only a single leaf, though, meaning PlantSimEngine cannot currently guess from the initial configuration that there might be multiple leaves created during the simulation.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Hence the difference in mapping declaration :  TT_cuis declared as a scalar correspondence : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":":TT_cu => \"Scene\",","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"whereas carbon_assimilation (and other variables) will be declared as a vector correspondence :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":":carbon_assimilation => [\"Leaf\"],","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Note that there may be instances where you might wish to write your own model to aggregate a variable from a multi-instance scale.","category":"page"},{"location":"multiscale/multiscale_coupling/#Hard-dependencies-between-models-at-different-scale-levels","page":"Multiscale coupling considerations","title":"Hard dependencies between models at different scale levels","text":"","category":"section"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"If a model requires some input variable that is computed at another scale, then providing the appropriate mapping for that variable will resolve name conflicts and enable that model to run with no further steps for the user or the modeler when the coupling is a 'soft dependency'.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the case of a hard dependency that operates at the same scale as its parent, declaring the hard dependency is exactly the same as in single-scale simulations and there are also no new extra steps on the user-side. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"On the other hand, modelers do need to bear in mind a couple of subtleties when developing models that possess hard dependencies that operate at a different organ level from their parent : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The parent model directly handles the call to its hard dependency model(s), meaning they are not explicitely managed by the top-level dependency graph.  Therefore only the owning model of that dependency is visible in the graph, and its hard dependency nodes are internal.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"When the caller (or any downstream model that requires some variables from the hard dependency) operates at the same scale, variables are easily accessible, and no mapping is required. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"If an inner model operates at a different scale/organ level, a modeler must declare hard dependencies with their respective organ level, similarly to the way the user provides a mapping. ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Conceptually :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":" PlantSimEngine.dep(m::ParentModel) = (\n    name_provided_in_the_mapping=AbstractHardDependencyModel => [\"Organ_Name_1\",],\n)","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Here's a concrete example in XPalm, an oil palm model developed on top of PlantSimEngine.   Organs are produced at the phytomer scale, but need to run an age model and a biomass model at the reproductive organs' scales.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":" PlantSimEngine.dep(m::ReproductiveOrganEmission) = (\n    initiation_age=AbstractInitiation_AgeModel => [m.male_symbol, m.female_symbol],\n    final_potential_biomass=AbstractFinal_Potential_BiomassModel => [m.male_symbol, m.female_symbol],\n)","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The user-mapping includes the required models at specific organ levels. Here's the relevant portion of the mapping for the male reproductive organ :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"mapping = Dict(\n    ...\n    \"Male\" =>\n    MultiScaleModel(\n        model=XPalm.InitiationAgeFromPlantAge(),\n        mapping=[:plant_age => \"Plant\",],\n    ),\n    ...\n    XPalm.MaleFinalPotentialBiomass(\n        p.parameters[:male][:male_max_biomass],\n        p.parameters[:male][:age_mature_male],\n        p.parameters[:male][:fraction_biomass_first_male],\n    ),\n    ...\n)","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"The model's constructor provides convenient default names for the scale corresponding to the reproductive organs. A user may override that if their naming schemes or MTG attributes differ.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"function ReproductiveOrganEmission(mtg::MultiScaleTreeGraph.Node; phytomer_symbol=\"Phytomer\", male_symbol=\"Male\", female_symbol=\"Female\")\n    ...\nend","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"But how does a model M calling a hard dependency H provide H's variables when calling H's run! function ? The status the user provides M operates at M's organ level, so if used to call H's run! function any required variable for H will be missing.    ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"PlantSimEngine provides what are called Status Templates in the simulation graph. Each organ level has its own Status template listing the available variables at that scale. So when a model M calls a hard dependency H's run! function, any required variables can be accessed through the status template of H's organ level.","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"Using the same example in XPalm : ","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"# Note that the function's 'status' parameter does NOT contain the variables required by the hard dependencies as the calling model's organ level is \"Phytomer\", not \"Male\" or \"Female\"\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n    ...\n    status.graph_node_count += 1\n\n    # Create the new organ as a child of the phytomer:\n    st_repro_organ = add_organ!(\n        status.node[1], # The phytomer's internode is its first child \n        sim_object,  # The simulation object, so we can add the new status \n        \"+\", status.sex, 4;\n        index=status.phytomer_count,\n        id=status.graph_node_count,\n        attributes=Dict{Symbol,Any}()\n    )\n\n    # Compute the initiation age of the organ:\n    PlantSimEngine.run!(sim_object.models[status.sex].initiation_age, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\n    PlantSimEngine.run!(sim_object.models[status.sex].final_potential_biomass, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\nend","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"In the above example the organ and its status template are created on the fly. When that isn't the case, the status template can be accessed through the simulation graph :","category":"page"},{"location":"multiscale/multiscale_coupling/","page":"Multiscale coupling considerations","title":"Multiscale coupling considerations","text":"function PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n\n    ...\n\n    if status.sex == \"Male\"\n\n        status_male = sim_object.statuses[\"Male\"][1]\n        run!(sim_object.models[\"Male\"].initiation_age, models, status_male, meteo, constants, sim_object)\n        run!(sim_object.models[\"Male\"].final_potential_biomass, models, status_male, meteo, constants, sim_object)\n    else\n        # Female\n        ...\n    end\nend","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/#Automated-tests-:-downstream-dependency-checking","page":"Automated testing","title":"Automated tests : downstream dependency checking","text":"","category":"section"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"PlantSimEngine is open sourced on Github, and so are its other companion packages, PlantGeom.jl, PlantMeteo.jl, PlantBioPhysics.jl, MultiScaleTreeGraph.jl, and XPalm.","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"One handy CI (Continuous Integration) feature implemented for these packages is automated integration and downstream testing : after changes to a package, its known downstream dependencies are tested to ensure no breaking changes were introduced. For instance, PlantBioPhysics is used in PlantSimEngine, so an integration test ensures that PlantBioPhysics doesn't break in an unforeseen manner after a new PlantSimEngine release.","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/","page":"Automated testing","title":"Automated testing","text":"This is something you can take advantage of if you wish to develop using PlantSimEngine, by providing us with your package name (or adding it to the CI yml file in a Pull Request) ; we can then add it to the list of downstream packages to test, and generate PR when breaking changes are introduced.","category":"page"},{"location":"troubleshooting_and_testing/downstream_tests/#Help-improve-our-documentation-!","page":"Automated testing","title":"Help improve our documentation !","text":"","category":"section"},{"location":"step_by_step/advanced_coupling/#Coupling-more-complex-models","page":"Advanced coupling and hard dependencies","title":"Coupling more complex models","text":"","category":"section"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"When two or more models have a two-way interdependency (rather than variables flowing out only one-way from one model into the next), we describe it as a hard dependency.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"This kind of interdependency requires a little more work from the user/modeler for PlantSimEngine to be able to automatically create the dependency graph.","category":"page"},{"location":"step_by_step/advanced_coupling/#Declaring-hard-dependencies","page":"Advanced coupling and hard dependencies","title":"Declaring hard dependencies","text":"","category":"section"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"A model that explicitly and directly calls another process in its run! function is part of a hard dependency, or a hard-coupled model. ","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"Let's go through the example processes and models from a script provided by the package here examples/dummy.jl","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"In this script, we declare seven processes and seven models, one for each process. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model...","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"When run, Process2Model calls another process's run! function which requires defining that process as a hard-dependency of Process2Model :","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"function PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # computing var3 using process1:\n    run!(models.process1, models, status, meteo, constants)\n    # computing var4 and var5:\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"We see that coupling a model (Process2Model) to another process (process1) is done by calling the run! function again. The run! function is called with the same arguments as the run! function of the model that calls it, except that we pass the process we want to simulate as the first argument.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"note: Note\nWe don't enforce any type of model to simulate process1. This is the reason why we can switch so easily between model implementations for any process, by just changing the model in the ModelList.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"A hard-dependency must always be declared to PlantSimEngine. This is done by adding a method to the dep function when implementing the model. For example, the hard-dependency to process1 into Process2Model is declared as follows:","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"PlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"This way PlantSimEngine knows that Process2Model needs a model for the simulation of the process1 process. To avoid imposing a specific model to be coupled with Process2Model, the dependency only requires a model that is a subtype of the abstract parent type AbstractProcess1Model. This avoids constraining to the specific Process1Model implementation, meaning an alternate model computing the same variables for the same process is still interchangeable with Process1Model.","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"While not encouraged, if you have a valid reason to force the coupling with a particular model, you can force the dependency to require that model specifically. For example, if we want to use only Process1Model for the simulation of process1, we would declare the dependency as follows:","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"PlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"## ","category":"page"},{"location":"step_by_step/advanced_coupling/","page":"Advanced coupling and hard dependencies","title":"Advanced coupling and hard dependencies","text":"There are examples in PlantBioPhysics of such models TODO. ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Troubleshooting-error-messages","page":"Troubleshooting","title":"Troubleshooting error messages","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"PlantSimEngine attempts to be as comfortable and easy to use as possible for the user, and many kinds of user error will be caught and explanations provided to resolve them, but there are still blind spots, as well as syntax errors that will often generate a Julia error (which can be less intuitive to decrypt) rather than a PlantSimEngine error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"To help people newer to Julia with troubleshooting, here are a few common 'easy-to-make' mistakes with the current API that might not be obvious to interpret, and pointers on how to fix them.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"They are listed by 'nature of error', rather than by error message, so you may need to search the page to find your specific error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you need more help to decode Julia errors, you can find help on the Julia Discourse forums. If you need some advice on the FSPM side, the research community has its own discourse forum.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If the issue seems PlantSimEngine-related, or you have questions regarding modeling or have suggestions, you can also file an issue on Github.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Tips-and-workflow","page":"Troubleshooting","title":"Tips and workflow","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Some errors are very specific as to their cause, and the PlantSimEngine errors tend to be explicit about which parameter / variable / organ is causing the error, helping narrow down its origin.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Some generic-looking errors usually do contain some extra information to help focus the debugging hunt. For instance, a dispatch failure on run! caused by some issue with args/kwargs may highlight explicitely indicate which arguments are currently causing conflict. In VSCode, such arguments are highlighted in red (the first and last arguments in the example below) : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = 1\nrun!(a, simple_mtg, mapping, meteo_day, a)\n\nERROR: MethodError: no method matching run!(::Int64, ::Node{NodeMTG, Dict{…}}, ::Dict{String, Tuple{…}}, ::DataFrame, ::Int64)\nThe function `run!` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyPlantLeafSurfaceModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ PlantSimEngine /PlantSimEngine/examples/ToyLeafSurfaceModel.jl:75\n   ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you wish to search for a specific error in the current page, copy the part of the description that is not specific to your script, and Ctrl+F it here. In the above example, the generic part would be : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: MethodError: no method matching","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Common-Julia-errors","page":"Troubleshooting","title":"Common Julia errors","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#NamedTuples-with-a-single-value-require-a-comma-:","page":"Troubleshooting","title":"NamedTuples with a single value require a comma :","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This one is easy to miss.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Empty NamedTuple objects are initialised with x = NamedTuple(). Ones with more than one variable can be initialised like this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0, var2 = 0)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"or like this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0, var2 = 0,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The second comma being optional.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"However, if there is only a single variable, notation has to be : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The comma is compulsory. If it is forgotten : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"a = (var1 = 0)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"the line will be interpreted as setting the variable a to the value var1 is set to, hence a will be an Int64 of value 0.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This is a liability when writing custom models as some functions work with NamedTuples : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"function PlantSimEngine.inputs_(::HardDepSameScaleAvalModel)\n    (e2 = -Inf,)\nend","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The error returned will likely be a Julia error along the lines of : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[ERROR: MethodError: no method matching merge(::Float64, ::@NamedTuple{g::Float64})\n\nClosest candidates are:\nmerge(::NamedTuple{()}, ::NamedTuple)\n@ Base namedtuple.jl:337\nmerge(::NamedTuple{an}, ::NamedTuple{bn}) where {an, bn}\n@ Base namedtuple.jl:324\nmerge(::NamedTuple, ::NamedTuple, NamedTuple...)\n@ Base namedtuple.jl:343\n\nStacktrace:\n[1] variables_multiscale(node::PlantSimEngine.HardDependencyNode{…}, organ::String, vars_mapping::Dict{…}, st::@NamedTuple{})\n...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"It is sometimes properly detected and explained on PlantSimEngine's side (when passing in tracked_outputs, for instance), but may also occur when declaring statuses.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Incorrectly-declaring-empty-inputs-or-outputs","page":"Troubleshooting","title":"Incorrectly declaring empty inputs or outputs","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The syntax for an empty NamedTuple is NamedTuple(). If instead one types () or (,)an error returned respectively by PlantSimEngine or Julia will be returned.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Forgetting-a-kwarg-when-declaring-a-MultiScaleModel","page":"Troubleshooting","title":"Forgetting a kwarg when declaring a MultiScaleModel","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A MultiScaleModel requires two kwargs, model and mapping : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        model=ToyLAIModel(),\n        mapping=[:TT_cu => \"Scene\",],\n    )","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting 'model=' :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        ToyLAIModel(),\n        mapping=[:TT_cu => \"Scene\",],\n    )\nERROR: MethodError: no method matching MultiScaleModel(::ToyLAIModel; mapping::Vector{Pair{Symbol, String}})\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n    \nClosest candidates are:\n    MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"mapping\"\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:188\n    MultiScaleModel(; model, mapping)\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Forgetting 'mapping=' :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"models = MultiScaleModel(\n        model=ToyLAIModel(),\n        [:TT_cu => \"Scene\",],\n    )\n\nERROR: MethodError: no method matching MultiScaleModel(::Vector{Pair{Symbol, String}}; model::ToyLAIModel)\nThe type `MultiScaleModel` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  MultiScaleModel(; model, mapping)\n   @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n  MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"model\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The message 'got unsupported keyword argument \"model\"' can be misleading, as in the error in this case is not that a kwarg is unsupported, but rather that a keyword argument is missing.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#MultiScaleModel-:-variable-not-defined-in-Module","page":"Troubleshooting","title":"MultiScaleModel : variable not defined in Module","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"A possible cause for this error is that a variable was declared instead of a symbol in a mapping for a multiscale model :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"mapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapping = [should_be_symbol => \"Other_Scale\"] # should_be_symbol is a variable, likely not found in the current module \n),\n...\n),","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here's the correct version : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"mapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapping = [:should_be_symbol => \"Other_Scale\"] # should_be_symbol is now a symbol\n),\n...\n),","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Kwarg-and-arg-parameter-issues-when-calling-run!","page":"Troubleshooting","title":"Kwarg and arg parameter issues when calling run!","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"There are, unfortunately, multiple ways of passing in arguments to the run! functions that will confuse dynamic dispatch. Some of it is due to imperfections in type declarations on PlantSimEngine's end and may be improved upon in the future. ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here are a few examples when modifying the usual multiscale run! call in this working example : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"    meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\n    var1 = 15.0\n\n    mapping = Dict(\n        \"Leaf\" => (\n            Process1Model(1.0),\n            Process2Model(),\n            Process3Model(),\n            Status(var1=var1,)\n        )\n    )\n\n    outs = Dict(\n        \"Leaf\" => (:var1,), # :non_existing_variable is not computed by any model\n    )\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The exact signature is this : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"function run!(\n    object::MultiScaleTreeGraph.Node,\n    mapping::Dict{String,T} where {T},\n    meteo=nothing,\n    constants=PlantMeteo.Constants(),\n    extra=nothing;\n    nsteps=nothing,\n    tracked_outputs=nothing,\n    check=true,\n    executor=ThreadedEx()","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Arguments after the mtg and mapping all have a default value and are optional, and arguments after the ';' delimiter are kwargs and need to be named.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If one forgets the mtg, a flaw in the way run! is defined will lead to this error :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching check_dimensions(::PlantSimEngine.TableAlike, ::Tuple{…}, ::DataFrame)\nThe function `check_dimensions` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  check_dimensions(::Any, ::Any)\n   @ PlantSimEngine PlantSimEngine/src/checks/dimensions.jl:43\n ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If one forgets the necessary 'tracked_outputs=' in the definition, outs will be interpreted as the 'extra' arg instead of a kwarg. 'extra' usually defaults to nothing, and is reserved in multiscale mode, leading to the following error :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mtg, mapping, meteo_day, PlantMeteo.Constants(), outs)\n\nERROR: Extra parameters are not allowed for the simulation of an MTG (already used for statuses).\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] run!(::PlantSimEngine.TreeAlike, object::PlantSimEngine.GraphSimulation{…}, meteo::DataFrames.DataFrameRows{…}, constants::Constants{…}, extra::Dict{…}; tracked_outputs::Nothing, check::Bool, executor::ThreadedEx{…})","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In case of a more generic error that returns a  For example, if one does the opposite and adds a non-existent kwarg, the generic dispatch failure has some more specific information :  got unsupported keyword argument \"constants\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"run!(mtg, mapping, meteo_day, constants=PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching run!(::Node{…}, ::Dict{…}, ::DataFrame, ::Dict{…}, ::Nothing; constants::Constants{…})\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\nClosest candidates are:\n  run!(::Node, ::Dict{String}, ::Any, ::Any, ::Any; nsteps, tracked_outputs, check, executor) got unsupported keyword argument \"constants\"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Hard-dependency-process-not-present-in-the-mapping","page":"Troubleshooting","title":"Hard dependency process not present in the mapping","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Another weakness in the current error checking leads to an unclear Julia error if a model A is present in a mapping and has a hard dependency on a model B, but B is absent from the mapping.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"In the following example, A corresponds to Process3Model, which requires a model B implementing 'Process2Model' and referred to as 'process2'.  Looking at the source code for Process3Model, the hard dependency is declared here : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"PlantSimEngine.dep(::Process3Model) = (process2=Process2Model,)","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"However, the model provided in the examples, Process2Model is absent from the mapping :","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"    simple_mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\n    mapping = Dict(\n        \"Leaf\" => (\n            Process3Model(),\n            Status(var5=15.0,)\n        )\n    )\n    outs = Dict(\n        \"Leaf\" => (:var5,),\n    )\nrun!(simple_mtg, mapping, meteo_day, tracked_outputs=outs)\n\nERROR: type NamedTuple has no field process2\nStacktrace:\n [1] getproperty(x::@NamedTuple{process3::Process3Model}, f::Symbol)\n   @ Base ./Base.jl:49\n [2] run!(::Process3Model, models::@NamedTuple{…}, status::Status{…}, meteo::DataFrameRow{…}, constants::Constants{…}, extra::PlantSimEngine.GraphSimulation{…})\n ...\n ```\n\nThe fix is to add Process2Model() -or an other model for the same process- to the mapping.\n\n### Status kwargs ?\nTODO\n\n## Forgetting to declare a scale in the mapping but having variables point to it\n\nIf there is a need to collect variables at two different scales, and one scale is completely absent from the mapping, the error currently occurs on the Julia side :\n","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia \"E2\" => (         MultiScaleModel(         model = HardDepSameScaleEchelle2Model(),         mapping = [:c => \"E1\" => :c, :e3 => \"E3\" => :e3, :f3 => \"E3\" => :f3,],          ),     ),","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#No-E3-in-the-mapping-!","page":"Troubleshooting","title":"No E3 in the mapping !","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Exception has occurred: KeyError","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"KeyError: key \"E3\" not found Stacktrace: [1] harddependencies(mapping::Dict{String, Tuple{Any, Any}}; verbose::Bool) @ PlantSimEngine ......./src/dependencies/harddependencies.jl:175 ...","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\n### Parenthesis placement when declaring a mapping\n\nAn unintuitive error encountered in the past when defining a mapping : \n","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia ERROR: ArgumentError: AbstractDict(kv): kv needs to be an iterator of 2-tuples or pairs","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"may occur when forgetting the parenthesis after '=>' in a mapping declaration, and combining it with another parenthesis error.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia mapping = Dict( \"Scale\" => (ToyAssimGrowthModel(0.0, 0.0, 0.0), ToyCAllocationModel(), Status( TTcu=Vector(cumsum(meteoday.TT))), ), )","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\nOther errors such as : ","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia ERROR: MethodError: no method matching Dict(::Pair{String, ToyAssimGrowthModel{Float64}}, ::ToyCAllocationModel, ::Status{(:TT_cu,), Tuple{Base.RefValue{…}}}) The type Dict exists, but no method is defined for this combination of argument types when trying to construct it.","category":"page"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Closest candidates are:   Dict(::Pair{K, V}...) where {K, V} ``` often indicate a likely syntax error somewhere in the mapping definition.","category":"page"},{"location":"FAQ/translate_a_model/#I-want-to-use-PlantSimEngine-for-my-model","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using PlantSimEngine\nusing CairoMakie\nusing CSV, DataFrames\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n# Note: meteo_day is defined below if you want to reproduce it, then use this to write it:\n# PlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If you already have a model, you can easily use PlantSimEngine to couple it with other models with minor adjustments.","category":"page"},{"location":"FAQ/translate_a_model/#Toy-LAI-Model","page":"I want to use PlantSimEngine for my model","title":"Toy LAI Model","text":"","category":"section"},{"location":"FAQ/translate_a_model/#Model-description","page":"I want to use PlantSimEngine for my model","title":"Model description","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Let's take an example with a simple LAI model that we define below:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"\"\"\"\nSimulate leaf area index (LAI, m² m⁻²) for a crop based on the amount of degree-days since sowing with a simple double-logistic function.\n\n# Arguments\n\n- `TT_cu`: degree-days since sowing\n- `max_lai=8`: Maximum value for LAI\n- `dd_incslope=500`: degree-days at which we get the maximal increase in LAI\n- `inc_slope=5`: slope of the increasing part of the LAI curve\n- `dd_decslope=1000`: degree-days at which we get the maximal decrease in LAI\n- `dec_slope=2`: slope of the decreasing part of the LAI curve\n\"\"\"\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This model takes the number of days since sowing as input and returns the simulated LAI. We can plot the simulated LAI for a year:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"FAQ/translate_a_model/#Changes-for-PlantSimEngine","page":"I want to use PlantSimEngine for my model","title":"Changes for PlantSimEngine","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"The model can be implemented using PlantSimEngine as follows:","category":"page"},{"location":"FAQ/translate_a_model/#Define-a-process","page":"I want to use PlantSimEngine for my model","title":"Define a process","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If the process of LAI dynamic is not implemented yet, we can define it like so:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"@process LAI_Dynamic","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model","page":"I want to use PlantSimEngine for my model","title":"Define the model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We have to define a structure for our model that will contain the parameters of the model:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"struct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We can also define default values for the parameters by defining a method with keyword arguments:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"ToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This way users can create a model with default parameters just by calling ToyLAIModel(), or they can specify only the parameters they want to change, e.g. ToyLAIModel(inc_slope=80.0)","category":"page"},{"location":"FAQ/translate_a_model/#Define-inputs-/-outputs","page":"I want to use PlantSimEngine for my model","title":"Define inputs / outputs","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define the inputs and outputs of the model, and the default value at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"PlantSimEngine.inputs_(::ToyLAIModel) = (TT_cu=-Inf,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we use -Inf for the default value, it is the recommended value for Float64 (-999 for Int), as it is a valid value for this type, and is easy to catch in the outputs if not properly set because it propagates nicely. You can also use NaN instead.","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model-function","page":"I want to use PlantSimEngine for my model","title":"Define the model function","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Finally, we can define the model function that will be called at each time step:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"function PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.TT_cu) / model.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.TT_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we don't return the value of the LAI in the definition of the function. This is because we rather update its value in the status directly. The status is a structure that efficiently stores the state of the model at each time step, and it contains all variables either declared as inputs or outputs of the model. This way, we can access the value of the LAI at any time step by calling status.LAI.","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nThe function is defined for one time step only, and is called at each time step automatically by PlantSimEngine. This means that we don't have to loop over the time steps in the function.","category":"page"},{"location":"FAQ/translate_a_model/#defining_the_meteo","page":"I want to use PlantSimEngine for my model","title":"Running a simulation","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Now that we have everything set up, we can run a simulation. The first step here is to define the weather:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"# Import the packages we need:\nusing PlantMeteo, Dates, DataFrames\n\n# Define the period of the simulation:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# Get the weather data for CIRAD's site in Montpellier, France:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# Compute the degree-days with a base temperature of 10°C:\nmeteo.TT = max.(meteo.T .- 10.0, 0.0)\n\n# Aggregate the weather data to daily values:\nmeteo_day = to_daily(meteo, :TT => (x -> sum(x) / 24) => :TT)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define our list of models, passing the values for TT_cu in the status at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"m = ModelList(\n    ToyLAIModel(),\n    status = (TT_cu = cumsum(meteo_day.TT),),\n)\n\noutputs_sim = run!(m)\n\nlines(outputs_sim[:TT_cu], outputs_sim[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Roadmap","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"more examples ? reworked mapping API, and other API changes","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Handling varying timesteps CI/downstream multi-species","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"better tracking of memory usage and type stability","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"meteo required variables checking","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"avoid printing the whole shebang by default","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"Better dependency graph visualisation Improving user errors MTG couple of new features #106, other bugs other bugs cyclic management for modellists dependency graph traversal","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"run! unrolling Improved parallelisation ?","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"state machine checker graph fuzzing","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"iteratively build and validate mappings and modellists ? documenting FP errors, more examples for fitting/type conversion/error propagation Improve multiscale dependency API ?","category":"page"},{"location":"planned_features/","page":"Planned features","title":"Planned features","text":"other package planned features ?","category":"page"},{"location":"step_by_step/parallelization/#Parallel-execution","page":"Parallelization","title":"Parallel execution","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"note: Note\nThis section is likely to change and become outdated. In any case, parallel execution only currently applies to single-scale simulations (multi-scale simulations' changing MTGs and extra complexity don't allow for straightforward parallelisation)","category":"page"},{"location":"step_by_step/parallelization/#FLoops","page":"Parallelization","title":"FLoops","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.jl uses the Floops package to run the simulation in sequential, parallel (multi-threaded) or distributed (multi-process) computations over objects, time-steps and independent processes. ","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"That means that you can provide any compatible executor to the executor argument of run!. By default, run! uses the ThreadedEx executor, which is a multi-threaded executor. You can also use the SequentialExfor sequential execution (non-parallel), or DistributedEx for distributed computations.","category":"page"},{"location":"step_by_step/parallelization/#Parallel-traits","page":"Parallelization","title":"Parallel traits","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.jl uses Holy traits to define if a model can be run in parallel.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"note: Note\nA model is executable in parallel over time-steps if it does not uses or set values from other time-steps, and over objects if it does not uses or set values from other objects.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"You can define a model as executable in parallel by defining the traits for time-steps and objects. For example, the ToyLAIModel model from the examples folder can be run in parallel over time-steps and objects, so it defines the following traits:","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"By default all models are considered not executable in parallel, because it is the safest option to avoid bugs that are difficult to catch, so you only need to define these traits if it is executable in parallel for them.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"tip: Tip\nA model that is defined executable in parallel will not necessarily will. First, the user has to pass a parallel executor to run! (e.g. ThreadedEx). Second, if the model is coupled with another model that is not executable in parallel, PlantSimEngine will run all models in sequential.","category":"page"},{"location":"step_by_step/parallelization/#Further-executors","page":"Parallelization","title":"Further executors","text":"","category":"section"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"You can also take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.","category":"page"},{"location":"step_by_step/parallelization/","page":"Parallelization","title":"Parallelization","text":"Finally, you can take a look into Transducers.jl's documentation for more information, for example if you don't know what is an executor, you can look into this explanation.","category":"page"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF","page":"Reducing DoF","title":"Reducing the DoF","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"working_with_data/reducing_dof/#Introduction","page":"Reducing DoF","title":"Introduction","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Why-reduce-the-degrees-of-freedom","page":"Reducing DoF","title":"Why reduce the degrees of freedom","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Reducing the degrees of freedom in a model, by forcing certain variables to measurements, can be useful for several reasons:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It can prevent overfitting by constraining the model and making it less complex.\nIt can help to better calibrate the other components of the model by reducing the co-variability of the variables (see Parameter degeneracy).\nIt can lead to more interpretable models by identifying the most important variables and relationships.\nIt can improve the computational efficiency of the model by reducing the number of variables that need to be estimated.\nIt can also help to ensure that the model is consistent with known physical or observational constraints and improve the credibility of the model and its predictions.\nIt is important to note that over-constraining a model can also lead to poor fits and false conclusions, so it is essential to carefully consider which variables to constrain and to what measurements.","category":"page"},{"location":"working_with_data/reducing_dof/#Parameter-degeneracy","page":"Reducing DoF","title":"Parameter degeneracy","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"The concept of \"degeneracy\" or \"parameter degeneracy\" in a model occurs when two or more variables in a model are highly correlated, and small changes in one variable can be compensated by small changes in another variable, so that the overall predictions of the model remain unchanged. Degeneracy can make it difficult to estimate the true values of the variables and to determine the unique solutions of the model. It also makes the model sensitive to the initial conditions (e.g. the parameters) and the optimization algorithm used.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Degeneracy is related to the concept of \"co-variability\" or \"collinearity\", which refers to the degree of linear relationship between two or more variables. In a degenerate model, two or more variables are highly co-variate, meaning that they are highly correlated and can produce similar predictions. By fixing one variable to a measured value, the model will have less flexibility to adjust the other variables, which can help to reduce the co-variability and improve the robustness of the model.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"This is an important topic in plant/crop modelling, as the models are very often degenerate. It is most often referred to as \"multicollinearity\" in the field. In the context of model calibration, it is also known as \"parameter degeneracy\" or \"parameter collinearity\". In the context of model reduction, it is also known as \"redundancy\" or \"redundant variables\".","category":"page"},{"location":"working_with_data/reducing_dof/#Reducing-the-DoF-in-PlantSimEngine","page":"Reducing DoF","title":"Reducing the DoF in PlantSimEngine","text":"","category":"section"},{"location":"working_with_data/reducing_dof/#Soft-coupled-models","page":"Reducing DoF","title":"Soft-coupled models","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"PlantSimEngine provides a simple way to reduce the degrees of freedom in a model by constraining the values of some variables to measurements.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's define a model list as usual with the seven processes from examples/dummy.jl:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's say that m is our complete model, and that we want to reduce the degrees of freedom by constraining the value of var9 to a measurement, which was previously computed by Process7Model, a soft-dependency model. It is very easy to do this in PlantSimEngine: just remove the model from the model list and give the value of the measurement in the status:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nout = run!(m2, meteo)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"And that's it ! The models that depend on var9 will now use the measured value of var9 instead of the one computed by Process7Model.","category":"page"},{"location":"working_with_data/reducing_dof/#Hard-coupled-models","page":"Reducing DoF","title":"Hard-coupled models","text":"","category":"section"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It is a bit more complicated to reduce the degrees of freedom in a model that is hard-coupled to another model, because it calls the run! method of the other model.","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"In this case, we need to replace the old model with a new model that forces the value of the variable to the measurement. This is done by giving the measurements as inputs of the new model, and returning nothing so the value is unchanged. ","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Starting from the model list with the seven processes from above, but this time let's say that we want to reduce the degrees of freedom by constraining the value of var3 to a measurement, which was previously computed by Process1Model, a hard-dependency model. It is very easy to do this in PlantSimEngine: just replace the model by a new model that forces the value of var3 to the measurement:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"struct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Now we can create a new model list with the new model for process7:","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nout = run!(m3, meteo)","category":"page"},{"location":"working_with_data/reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"note: Note\nWe could also eventually provide the measured variable using the meteo data, but it is not recommended. The meteo data is meant to be used for the meteo variables only, and not for the model variables. It is better to use the status for that.","category":"page"},{"location":"API/API_public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"API/API_public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/API_public/#API-documentation","page":"Public API","title":"API documentation","text":"","category":"section"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/API_public/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"Public API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.AbstractModel","page":"Public API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.ModelList","page":"Public API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> outputs_sim = run!(models,meteo)\nTimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):\n╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮\n│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │\n╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯\n\njulia> outputs_sim[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.MultiScaleModel","page":"Public API","title":"PlantSimEngine.MultiScaleModel","text":"MultiScaleModel(model, mapping)\n\nA structure to make a model multi-scale. It defines a mapping between the variables of a  model and the nodes symbols from which the values are taken from.\n\nArguments\n\nmodel<:AbstractModel: the model to make multi-scale\nmapping<:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}: a vector of pairs of symbols and strings or vectors of strings\n\nThe mapping can be of the form:\n\n[:variable_name => \"Plant\"]: We take one value from the Plant node\n[:variable_name => [\"Leaf\"]]: We take a vector of values from the Leaf nodes\n[:variable_name => [\"Leaf\", \"Internode\"]]: We take a vector of values from the Leaf and Internode nodes\n[:variable_name => \"Plant\" => :variable_name_in_plant_scale]: We take one value from another variable name in the Plant node\n[:variable_name => [\"Leaf\" => :variable_name_1, \"Internode\" => :variable_name_2]]: We take a vector of values from the Leaf and Internode nodes with different names\n[PreviousTimeStep(:variable_name) => ...]: We flag the variable to be initialized with the value from the previous time step, and we do not use it to build the dep graph\n[:variable_name => :variable_name_from_another_model]: We take the value from another model at the same scale but rename it\n[PreviousTimeStep(:variable_name),]: We just flag the variable as a PreviousTimeStep to not use it to build the dep graph\n\nDetails about the different forms:\n\nThe variable variable_name of the model will be taken from the Plant node, assuming only one node has the Plant symbol.\n\nIn this case the value available from the status will be a scalar, and so the user must guaranty that only one node of type Plant is available in the MTG.\n\nThe variable variable_name of the model will be taken from the Leaf nodes. Notice it is given as a vector, indicating that the values will be taken \n\nfrom all the nodes of type Leaf. The model should be able to handle a vector of values. Note that even if there is only one node of type Leaf, the value will be taken as a vector of one element.\n\nThe variable variable_name of the model will be taken from the Leaf and Internode nodes. The values will be taken from all the nodes of type Leaf \n\nand Internode.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_in_plant_scale in the Plant node. This is useful\n\nwhen the variable name in the model is different from the variable name in the scale it is taken from.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_1 in the Leaf node and variable_name_2 in the Internode node.\nThe variable variable_name of the model uses the value computed on the previous time-step. This implies that the variable is not used to build the dependency graph\n\nbecause the dependency graph only applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe variable variable_name of the model will be taken from another model at the same scale, but with another variable name.\nThe variable variable_name of the model is just flagged as a PreviousTimeStep variable, so it is not used to build the dependency graph.\n\nNote that the mapping does not make any copy of the values, it only references them. This means that if the values are updated in the status of one node, they will be updated in the other nodes.\n\nExamples\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\nLet's take a model:\n\njulia> model = ToyCAllocationModel()\nToyCAllocationModel()\n\nWe can make it multi-scale by defining a mapping between the variables of the model and the nodes symbols from which the values are taken from:\n\nFor example, if the carbon_allocation comes from the Leaf and Internode nodes, we can define the mapping as follows:\n\njulia> mapping = [:carbon_allocation => [\"Leaf\", \"Internode\"]]\n1-element Vector{Pair{Symbol, Vector{String}}}:\n :carbon_allocation => [\"Leaf\", \"Internode\"]\n\nThe mapping is a vector of pairs of symbols and strings or vectors of strings. In this case, we have only one pair to define the mapping between the carbon_allocation variable and the Leaf and Internode nodes.\n\nWe can now make the model multi-scale by passing the model and the mapping to the MultiScaleModel constructor :\n\njulia> multiscale_model = PlantSimEngine.MultiScaleModel(model, mapping)\nMultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]])\n\nWe can access the mapping and the model:\n\njulia> PlantSimEngine.mapping_(multiscale_model)\n1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:\n :carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]\n\njulia> PlantSimEngine.model_(multiscale_model)\nToyCAllocationModel()\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.PreviousTimeStep","page":"Public API","title":"PlantSimEngine.PreviousTimeStep","text":"PreviousTimeStep(variable)\n\nA structure to manually flag a variable in a model to use the value computed on the previous time-step.  This implies that the variable is not used to build the dependency graph because the dependency graph only  applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe process is added when building the MultiScaleModel, to avoid conflicts between processes with the same variable name. For exemple one process can define a variable :carbon_biomass as a PreviousTimeStep, but the othe process would use  the variable as a dependency for the current time-step (and it would be fine because theyr don't share the same issue of cyclic dependency).\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Status","page":"Public API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> using PlantSimEngine\n\njulia> st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Rₛ]\n13.747\n\njulia> st.Rₛ\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Rₛ] = 20.0\n20.0\n\njulia> st.Rₛ = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.EF-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}","page":"Public API","title":"PlantSimEngine.add_organ!","text":"add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)\n\nAdd an organ to the graph, automatically taking care of initialising the status of the organ (multiscale-)variables.\n\nThis function should be called from a model that implements organ emergence, for example in function of thermal time.\n\nArguments\n\nnode: the node to which the organ is added (the parent organ of the new organ)\nsim_object: the simulation object, e.g. the GraphSimulation object from the extra argument of a model.\nlink: the link type between the new node and the organ:\n\"<\": the new node is following the parent organ\n\"+\": the new node is branching the parent organ\n\"/\": the new node is decomposing the parent organ, i.e. we change scale\nsymbol: the symbol of the organ, e.g. \"Leaf\"\nscale: the scale of the organ, e.g. 2.\nindex: the index of the organ, e.g. 1. The index may be used to easily identify branching order, or growth unit index on the axis. It is different from the node id that is unique.\nid: the unique id of the new node. If not provided, a new id is generated.\nattributes: the attributes of the new node. If not provided, an empty dictionary is used.\ncheck: a boolean indicating if variables initialisation should be checked. Passed to init_node_status!.\n\nReturns\n\nstatus: the status of the new node\n\nExamples\n\nSee the ToyInternodeEmergence example model from the Examples module (also found in the examples folder), or the test-mtg-dynamic.jl test file for an example usage.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.convert_outputs-Tuple{Dict{String}, Any}","page":"Public API","title":"PlantSimEngine.convert_outputs","text":"convert_outputs(sim_outputs::Dict{String,O} where O, sink; refvectors=false, no_value=nothing)\nconvert_outputs(sim_outputs::TimeStepTable{T} where T, sink)\n\nConvert the outputs returned by a simulation made on a plant graph into another format.\n\nDetails\n\nThe first method operates on the outputs of a multiscale simulation, the second one on those of a typical single-scale simulation.  The sink function determines the format used, for exemple a DataFrame.\n\nArguments\n\nsim_outputs : the outputs of a prior simulation, typically returned byrun!`.\nsink: a sink compatible with the Tables.jl interface (e.g. a DataFrame)\nrefvectors: if false (default), the function will remove the RefVector values, otherwise it will keep them\nno_value: the value to replace nothing values. Default is nothing. Usually used to replace nothing values \n\nby missing in DataFrames.\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph, DataFrames, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nmapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), )\n\nmtg = import_mtg_example();\n\nout = run!(mtg, mapping, meteo, tracked_outputs = Dict(\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :soil_water_content, :carbon_allocation),\n    \"Internode\" => (:carbon_allocation,),\n    \"Plant\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n));\n\nconvert_outputs(out, DataFrames)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.dep","page":"Public API","title":"PlantSimEngine.dep","text":"dep(m::ModelList, nsteps=1; verbose::Bool=true)\ndep(mapping::Dict{String,T}; verbose=true)\n\nGet the model dependency graph given a ModelList or a multiscale model mapping. If one graph is returned,  then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph. It is set to 1 in the case of a  multiscale mapping.\n\nDetails\n\nThe dependency graph is computed by searching the inputs of each process in the outputs of its own scale, or the other scales. There are five cases for every model (one model simulates one process):\n\nThe process has no inputs. It is completely independent, and is placed as one of the roots of the dependency graph.\nThe process needs inputs from models at its own scale. We put it as a child of this other process.\nThe process needs inputs from another scale. We put it as a child of this process at another scale.\nThe process needs inputs from its own scale and another scale. We put it as a child of both.\nThe process is a hard dependency of another process (only possible at the same scale). In this case, the process is set as a hard-dependency of the \n\nother process, and its simulation is handled directly from this process.\n\nFor the 4th case, the process have two parent processes. This is OK because the process will only be computed once during simulation as we check if both  parents were run before running the process. \n\nNote that in the 5th case, we still need to check if a variable is needed from another scale. In this case, the parent node is  used as a child of the process at the other scale. Note there can be several levels of hard dependency graph, so this is done recursively.\n\nHow do we do all that? We identify the hard dependencies first. Then we link the inputs/outputs of the hard dependencies roots  to other scales if needed. Then we transform all these nodes into soft dependencies, that we put into a Dict of Scale => Dict(process => SoftDependencyNode). Then we traverse all these and we set nodes that need outputs from other nodes as inputs as children/parents. If a node has no dependency, it is set as a root node and pushed into a new Dict (independantprocessroot). This Dict is the returned dependency graph. And  it presents root nodes as independent starting points for the sub-graphs, which are the models that are coupled together. We can then traverse each of  these graphs independently to retrieve the models that are coupled together, in the right order of execution.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nmodels = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;models...)\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.dr-Tuple{Any, Any}","page":"Public API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.fit","page":"Public API","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/Beer.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of PPFD, LAI  and Ri_PAR_f. \n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated PPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"Public API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.inputs","text":"inputs(mapping::Dict{String,T})\n\nGet the inputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"Public API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.outputs","text":"outputs(mapping::Dict{String,T})\n\nGet the outputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.run!","page":"Public API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\nrun!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or a plant graph (MTG).\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters, not available for simulation of plant graphs (the simulation object is passed using this).\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nmapping: a mapping between the MTG and the model list.\nnsteps: the number of time-steps to run, only needed if no meteo is given (else it is infered from it).\noutputs: the outputs to get in dynamic for each node type of the MTG.\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nUsers can ask for parallel execution by providing a compatible executor to the executor argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the Examples sub-module:\n\njulia> using PlantSimEngine.Examples;\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> outputs_sim = run!(models, meteo);\n\nGet the results:\n\njulia> (outputs_sim[:var4],outputs_sim[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/API_public/#PlantSimEngine.status-Tuple{Any}","page":"Public API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including example models and processes:\nusing PlantSimEngine.Examples;\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"Public API","title":"PlantSimEngine.to_initialize","text":"to_initialize(; verbose=true, vars...)\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\nto_initialize(mapping::Dict{String,T}, graph=nothing)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nArguments\n\nverbose: if true, print information messages.\nvars...: the models and processes to consider.\nm::T: a ModelList.\nm::DependencyGraph: a DependencyGraph.\nmapping::Dict{String,T}: a mapping that associates models to organs.\ngraph: a graph representing a plant or a scene, e.g. a multiscale tree graph. The graph is used to check if variables that are not initialized can be found in the graph nodes attributes.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\nto_initialize(m)\n\nOr with a mapping:\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmapping = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"Internode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\nto_initialize(mapping)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}","page":"Public API","title":"PlantSimEngine.to_initialize","text":"to_initialize(m::AbstractDependencyNode)\n\nReturn the variables that must be initialized providing a set of models and processes. The function just returns the inputs and outputs of each model, with their default values. To take into account model coupling, use the function at an upper-level instead, i.e.  to_initialize(m::ModelList) or to_initialize(m::DependencyGraph).\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Tuple{Module}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(m::AbstractDependencyNode)\n\nReturns a tuple with the name of the inputs and outputs variables needed by a model in  a dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"Public API","title":"PlantSimEngine.variables","text":"variables(mapping::Dict{String,T})\n\nGet the variables (inputs and outputs) of the models in a mapping, for each  process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"Public API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"Public API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nNewcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of AbstractModel:\n\nabstract type MyNewProcess <: AbstractModel end\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"API/API_public/#Example-models","page":"Public API","title":"Example models","text":"","category":"section"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"PlantSimEngine provides example processes and models to users. They are available from a sub-module called Examples. To get access to these models, you can simply use this sub-module:","category":"page"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"using PlantSimEngine.Examples","category":"page"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"The models are detailed below.","category":"page"},{"location":"API/API_public/","page":"Public API","title":"Public API","text":"Modules = [PlantSimEngine.Examples]\nPublic = true\nPrivate = true","category":"page"},{"location":"API/API_public/#PlantSimEngine.Examples","page":"Public API","title":"PlantSimEngine.Examples","text":"A sub-module with example models.\n\nExamples used in the documentation for a set of multiscale models. The models can be found in the examples folder of the package, and are stored  in the following files:\n\nToyAssimModel.jl\nToyCDemandModel.jl\nToyCAllocationModel.jl\nToySoilModel.jl\n\nExamples\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nToyAssimModel()\n\n\n\n\n\n","category":"module"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractCarbon_AllocationModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractCarbon_AllocationModel","text":"carbon_allocation process abstract model. \n\nAll models implemented to simulate the carbon_allocation process must be a subtype of this type, e.g.  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","text":"carbon_assimilation process abstract model. \n\nAll models implemented to simulate the carbon_assimilation process must be a subtype of this type, e.g.  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractCarbon_BiomassModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractCarbon_BiomassModel","text":"carbon_biomass process abstract model. \n\nAll models implemented to simulate the carbon_biomass process must be a subtype of this type, e.g.  struct MyCarbon_BiomassModel <: AbstractCarbon_BiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractCarbon_DemandModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractCarbon_DemandModel","text":"carbon_demand process abstract model. \n\nAll models implemented to simulate the carbon_demand process must be a subtype of this type, e.g.  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractDegreedaysModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractDegreedaysModel","text":"Degreedays process abstract model. \n\nAll models implemented to simulate the Degreedays process must be a subtype of this type, e.g.  struct MyDegreedaysModel <: AbstractDegreedaysModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractDegreedaysModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractGrowthModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractGrowthModel","text":"growth process abstract model. \n\nAll models implemented to simulate the growth process must be a subtype of this type, e.g.  struct MyGrowthModel <: AbstractGrowthModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractGrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractLai_DynamicModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractLai_DynamicModel","text":"LAI_Dynamic process abstract model. \n\nAll models implemented to simulate the LAI_Dynamic process must be a subtype of this type, e.g.  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","text":"leaf_surface process abstract model. \n\nAll models implemented to simulate the leaf_surface process must be a subtype of this type, e.g.  struct MyLeaf_SurfaceModel <: AbstractLeaf_SurfaceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_SurfaceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractLight_InterceptionModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractLight_InterceptionModel","text":"light_interception process abstract model. \n\nAll models implemented to simulate the light_interception process must be a subtype of this type, e.g.  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractLight_PartitioningModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractLight_PartitioningModel","text":"light_partitioning process abstract model. \n\nAll models implemented to simulate the light_partitioning process must be a subtype of this type, e.g.  struct MyLight_PartitioningModel <: AbstractLight_PartitioningModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_PartitioningModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","text":"maintenance_respiration process abstract model. \n\nAll models implemented to simulate the maintenance_respiration process must be a subtype of this type, e.g.  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","text":"organ_emergence process abstract model. \n\nAll models implemented to simulate the organ_emergence process must be a subtype of this type, e.g.  struct MyOrgan_EmergenceModel <: AbstractOrgan_EmergenceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractOrgan_EmergenceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess1Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess1Model","text":"process1 process abstract model. \n\nAll models implemented to simulate the process1 process must be a subtype of this type, e.g.  struct MyProcess1Model <: AbstractProcess1Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess1Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess2Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess2Model","text":"process2 process abstract model. \n\nAll models implemented to simulate the process2 process must be a subtype of this type, e.g.  struct MyProcess2Model <: AbstractProcess2Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess2Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess3Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess3Model","text":"process3 process abstract model. \n\nAll models implemented to simulate the process3 process must be a subtype of this type, e.g.  struct MyProcess3Model <: AbstractProcess3Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess3Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess4Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess4Model","text":"process4 process abstract model. \n\nAll models implemented to simulate the process4 process must be a subtype of this type, e.g.  struct MyProcess4Model <: AbstractProcess4Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess4Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess5Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess5Model","text":"process5 process abstract model. \n\nAll models implemented to simulate the process5 process must be a subtype of this type, e.g.  struct MyProcess5Model <: AbstractProcess5Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess5Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess6Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess6Model","text":"process6 process abstract model. \n\nAll models implemented to simulate the process6 process must be a subtype of this type, e.g.  struct MyProcess6Model <: AbstractProcess6Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess6Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractProcess7Model","page":"Public API","title":"PlantSimEngine.Examples.AbstractProcess7Model","text":"process7 process abstract model. \n\nAll models implemented to simulate the process7 process must be a subtype of this type, e.g.  struct MyProcess7Model <: AbstractProcess7Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess7Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.AbstractSoil_WaterModel","page":"Public API","title":"PlantSimEngine.Examples.AbstractSoil_WaterModel","text":"soil_water process abstract model. \n\nAll models implemented to simulate the soil_water process must be a subtype of this type, e.g.  struct MySoil_WaterModel <: AbstractSoil_WaterModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Beer","page":"Public API","title":"PlantSimEngine.Examples.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nRequired inputs: LAI in m² m⁻². Required meteorology data: Ri_PAR_f, the incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹).\n\nOutput: aPPFD, the absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process1Model","page":"Public API","title":"PlantSimEngine.Examples.Process1Model","text":"Process1Model(a)\n\nA dummy model implementing a \"process1\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process2Model","page":"Public API","title":"PlantSimEngine.Examples.Process2Model","text":"Process2Model()\n\nA dummy model implementing a \"process2\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process3Model","page":"Public API","title":"PlantSimEngine.Examples.Process3Model","text":"Process3Model()\n\nA dummy model implementing a \"process3\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process4Model","page":"Public API","title":"PlantSimEngine.Examples.Process4Model","text":"Process4Model()\n\nA dummy model implementing a \"process4\" process for testing purposes. It computes the inputs needed for the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process5Model","page":"Public API","title":"PlantSimEngine.Examples.Process5Model","text":"Process5Model()\n\nA dummy model implementing a \"process5\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process6Model","page":"Public API","title":"PlantSimEngine.Examples.Process6Model","text":"Process6Model()\n\nA dummy model implementing a \"process6\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3, but also from process 7 that is itself independant.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.Process7Model","page":"Public API","title":"PlantSimEngine.Examples.Process7Model","text":"Process7Model()\n\nA dummy model implementing a \"process7\" process for testing purposes. It is independent (needs :var0 only as for Process4Model), but its outputs are used by Process6Model, so it is a soft-coupling.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyAssimGrowthModel","page":"Public API","title":"PlantSimEngine.Examples.ToyAssimGrowthModel","text":"ToyAssimGrowthModel(Rm_factor, Rg_cost)\nToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\nRm_factor=0.5: the fraction of assimilation that goes into maintenance respiration\nRg_cost=1.2: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the assimilation, in gC m⁻² time-step⁻¹\nRm: the maintenance respiration, in gC m⁻² time-step⁻¹\nRg: the growth respiration, in gC m⁻² time-step⁻¹\nbiomass_increment: the daily biomass increment, in gC m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyAssimModel","page":"Public API","title":"PlantSimEngine.Examples.ToyAssimModel","text":"ToyAssimModel(LUE)\n\nComputes the assimilation of a plant (= photosynthesis).\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\nsoil_water_content: the soil water content, in %\n\nOutputs\n\ncarbon_assimilation: the assimilation or photosynthesis, also sometimes denoted A, in gC m⁻² time-step⁻¹\n\nDetails\n\nThe assimilation is computed as the product of the absorbed photosynthetic photon flux density (aPPFD) and the light use efficiency (LUE), so the units of the assimilation usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of aPPFD, e.g.  if aPPFD is in mol[PAR] plant⁻¹ time-step⁻¹, the assimilation will be in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyCAllocationModel","page":"Public API","title":"PlantSimEngine.Examples.ToyCAllocationModel","text":"ToyCAllocationModel()\n\nComputes the carbon allocation to each organ of a plant based on the plant total carbon offer and individual organ demand. This model should be used at the plant scale, because it first computes the carbon availaible for allocation as the minimum between the total demand  (sum of organs' demand) and total carbon offer (sum of organs' assimilation - total maintenance respiration), and then allocates the carbon relative  to each organ's demand.\n\nInputs\n\ncarbon_assimilation: a vector of the assimilation of all photosynthetic organs, usually in gC m⁻² time-step⁻¹\nRm: the maintenance respiration of the plant, usually in gC m⁻² time-step⁻¹\ncarbon_demand: a vector of the carbon demand of the organs, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the carbon assimilation, usually in gC m⁻² time-step⁻¹\n\nDetails\n\nThe units usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of the inputs, e.g. in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyCBiomassModel","page":"Public API","title":"PlantSimEngine.Examples.ToyCBiomassModel","text":"ToyCBiomassModel(construction_cost)\n\nComputes the carbon biomass of an organ based on the carbon allocation and construction cost.\n\nArguments\n\nconstruction_cost: the construction cost of the organ, usually in gC gC⁻¹. Should be understood as the amount of carbon needed to build 1g of carbon biomass.\n\nInputs\n\ncarbon_allocation: the carbon allocation to the organ for the time-step, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_biomass_increment: the increment of carbon biomass, usually in gC time-step⁻¹\ncarbon_biomass: the carbon biomass, usually in gC\ngrowth_respiration: the growth respiration, usually in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyCDemandModel","page":"Public API","title":"PlantSimEngine.Examples.ToyCDemandModel","text":"ToyCDemandModel(optimal_biomass, development_duration)\nToyCDemandModel(; optimal_biomass, development_duration)\n\nComputes the carbon demand of an organ depending on its biomass under optimal conditions and the duration of its development in degree days. The model assumes that the carbon demand is linear througout the duration of the development.\n\nArguments\n\noptimal_biomass: the biomass of the organ under optimal conditions, in gC\ndevelopment_duration: the duration of the development of the organ, in degree days\n\nInputs\n\nTT: the thermal time, in degree days\n\nOutputs\n\ncarbon_demand: the carbon demand, in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyDegreeDaysCumulModel","page":"Public API","title":"PlantSimEngine.Examples.ToyDegreeDaysCumulModel","text":"ToyDegreeDaysCumulModel(;init_TT=0.0, T_base=10.0, T_max=43.0)\n\nComputes the thermal time in degree days and cumulated degree-days based on the average daily temperature (T), the initial cumulated degree days, the base temperature below which there is no growth, and the maximum  temperature for growh.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyInternodeEmergence","page":"Public API","title":"PlantSimEngine.Examples.ToyInternodeEmergence","text":"ToyInternodeEmergence(;init_TT=0.0, TT_emergence = 300)\n\nComputes the organ emergence based on cumulated thermal time since last event.\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyLAIModel","page":"Public API","title":"PlantSimEngine.Examples.ToyLAIModel","text":"ToyLAIModel(;max_lai=8.0, dd_incslope=800, inc_slope=110, dd_decslope=1500, dec_slope=20)\n\nComputes the Leaf Area Index (LAI) based on a sigmoid function of thermal time.\n\nArguments\n\nmax_lai: the maximum LAI value\ndd_incslope: the thermal time at which the LAI starts to increase\ninc_slope: the slope of the increase\ndd_decslope: the thermal time at which the LAI starts to decrease\ndec_slope: the slope of the decrease\n\nInputs\n\nTT_cu: the cumulated thermal time since the beginning of the simulation, usually in °C days\n\nOutputs\n\nLAI: the Leaf Area Index, usually in m² m⁻²\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","page":"Public API","title":"PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","text":"ToyLAIfromLeafAreaModel()\n\nComputes the Leaf Area Index (LAI) of the scene based on the plants leaf area.\n\nArguments\n\nscene_area: the area of the scene, usually in m²\n\nInputs\n\nsurface: a vector of plant leaf surfaces, usually in m²\n\nOutputs\n\nLAI: the Leaf Area Index of the scene, usually in m² m⁻²\ntotal_surface: the total surface of the plants, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyLeafSurfaceModel","page":"Public API","title":"PlantSimEngine.Examples.ToyLeafSurfaceModel","text":"ToyLeafSurfaceModel(SLA)\n\nComputes the individual leaf surface from its biomass using the SLA.\n\nArguments\n\nSLA: the specific leaf area, usually in m² gC⁻¹. Should be understood as the surface area of a leaf per unit of carbon biomass.\n\nValues typically range from 0.002 to 0.027 m² gC⁻¹.\n\nInputs\n\ncarbon_biomass: the carbon biomass of the leaf, usually in gC\n\nOutputs\n\nsurface: the leaf surface, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyLightPartitioningModel","page":"Public API","title":"PlantSimEngine.Examples.ToyLightPartitioningModel","text":"ToyLightPartitioningModel()\n\nComputes the light partitioning based on relative surface.\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density at the larger scale (e.g. scene), in mol[PAR] m⁻² time-step⁻¹ \n\nOutputs\n\naPPFD: the assimilation or photosynthesis, also sometimes denoted A, in gC time-step⁻¹\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyMaintenanceRespirationModel","page":"Public API","title":"PlantSimEngine.Examples.ToyMaintenanceRespirationModel","text":"RmQ10FixedN(Q10, Rm_base, T_ref, P_alive, nitrogen_content)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nRm_base: Base maintenance respiration (gC gDM⁻¹ time-step⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nnitrogen_content: nitrogen content of the organ (gN gC⁻¹)\n\nInputs\n\ncarbon_biomass: the carbon biomass of the organ in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","page":"Public API","title":"PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","text":"ToyPlantLeafSurfaceModel()\n\nComputes the leaf surface at plant scale by summing the individual leaf surfaces.\n\nInputs\n\nleaf_surfaces: a vector of leaf surfaces, usually in m²\n\nOutputs\n\nsurface: the leaf surface at plant scale, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyPlantRmModel","page":"Public API","title":"PlantSimEngine.Examples.ToyPlantRmModel","text":"ToyPlantRmModel()\n\nTotal plant maintenance respiration based on the sum of Rm_organs, the maintenance respiration of the organs.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC time-step⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToyRUEGrowthModel","page":"Public API","title":"PlantSimEngine.Examples.ToyRUEGrowthModel","text":"ToyRUEGrowthModel(efficiency)\n\nComputes the carbon biomass increment of a plant based on the radiation use efficiency principle.\n\nArguments\n\nefficiency: the radiation use efficiency, in gC[biomass] mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\nbiomass_increment: the daily biomass increment, in gC[biomass] m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC[biomass] m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.ToySoilWaterModel","page":"Public API","title":"PlantSimEngine.Examples.ToySoilWaterModel","text":"ToySoilWaterModel(values=[0.5])\n\nA toy model to compute the soil water content. The model simply take a random value in the values range using rand.\n\nOutputs\n\nsoil_water_content: the soil water content (%).\n\nArguments\n\nvalues: a range of soil_water_content values to sample from. Can be a vector of values [0.5,0.6] or a range 0.1:0.1:1.0. Default is [0.5].\n\n\n\n\n\n","category":"type"},{"location":"API/API_public/#PlantSimEngine.Examples.import_mtg_example-Tuple{}","page":"Public API","title":"PlantSimEngine.Examples.import_mtg_example","text":"import_mtg_example()\n\nReturns an example multiscale tree graph (MTG) with a scene, a soil, and a plant with two internodes and two leaves.\n\nExamples\n\njulia> using PlantSimEngine.Examples\n\njulia> import_mtg_example()\n/ 1: Scene\n├─ / 2: Soil\n└─ + 3: Plant\n   └─ / 4: Internode\n      ├─ + 5: Leaf\n      └─ < 6: Internode\n         └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.fit-Tuple{Type{PlantSimEngine.Examples.Beer}, Any}","page":"Public API","title":"PlantSimEngine.fit","text":"fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n\nCompute the k parameter of the Beer-Lambert law from measurements.\n\nArguments\n\n::Type{Beer}: the model type\ndf: a DataFrame with the following columns:\naPPFD: the measured absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹\nLAI: the measured leaf area index in m² m⁻²\nRi_PAR_f: the measured incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹)\n\nExamples\n\nImport the example models defined in the Examples sub-module:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\n\nCreate a model list with a Beer model, and fit it to the data:\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public/#PlantSimEngine.run!-2","page":"Public API","title":"PlantSimEngine.run!","text":"run!(::Beer, object, meteo, constants=Constants(), extra=nothing)\n\nComputes the photosynthetic photon flux density (aPPFD, µmol m⁻² s⁻¹) absorbed by an  object using the incoming PAR radiation flux (Ri_PAR_f, W m⁻²) and the Beer-Lambert law of light extinction.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for LAI (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\nextra = nothing: extra arguments, not used here.\n\nExamples\n\nm = ModelList(Beer(0.5), status=(LAI=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_q=300.0)\n\nrun!(m, meteo)\n\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"This page details some of the assumptions, coupling constraints and inner workings of PlantSimEngine which may be particular relevant when implementing new models.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"TODO est-ce le meilleur endroit ?","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-provides-the-simulation-timestep,-but-models-can-veer-away-from-it","page":"-","title":"Weather data provides the simulation timestep, but models can veer away from it","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"The weather data timesteps, whether hourly or daily, provide the pace at which most other models run.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"In XPalm, weather data for most models is provided daily, meaning biomass calculations are also provided daily. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Many models are considered to be steady-state over that timeframe, but not all : the leaf pruning model pertubes the plant in a non-steady state fashion, for example. Models that require computations over several iterations to stabilise (often part of hard dependencies) might also have a timestep unrelated to the weather data.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"note: Note\nImplicitely, this means any vector variables given as input to the simulation must be consistent with the number of weather timesteps. Providing one weather value but a larger vector variable is an exception : the weather data is replicated over each timestep. (This may be subject to change in the future when support for different timesteps in a single simulation is implemented)","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Weather-data-must-be-interpolated-prior-to-simulation","page":"-","title":"Weather data must be interpolated prior to simulation","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"If your weather data isn't adjusted to conform to a regular timestep, you will need to adjust it to fit that constraint. PlantSimEngine does no interpolation prior to simulation and expects regular weather timesteps.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-cyclic-dependencies-in-the-simplified-dependency-graph","page":"-","title":"No cyclic dependencies in the simplified dependency graph","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"This has been explained elsewhere TODO  : the dependency graph is comprised of soft and hard dependency nodes, and the final version only links soft dependency nodes and is guaranteed to contain no cycles.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Any user model coupling which causes a cyclic dependency to occur will require some extra tinkering to run : either design models differently, create a hard dependency with some of the problematic models, or break the cycle by having a variable take the previous timestep's value as input.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Note : Only the previous timestep is accessible in PlantSimEngine without any kind of dedicated model. How to create a model to store more past timesteps of a specific variable is described here TODO","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-need-to-be-declared-in-the-model-definition","page":"-","title":"Hard dependencies need to be declared in the model definition","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Hard dependencies are handled internally by their owning soft dependency model, ie the hard dep's run! function is directly called by the soft dependency's run!.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"The current way in which PlantSimEngine creates its dependency graph requires users to declare what process is required in the hard dependency and which scale it pulls the model and its variables from.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Parallelisation-opportunities-must-be-part-of-the-model-definition","page":"-","title":"Parallelisation opportunities must be part of the model definition","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Traits that indicate that a model is independent or objects need to be part of the model definition. Modelers need to keep this in mind when implementing new models.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"This is currently mostly a concern for single-scale simulations, as multi-scale simulations are not currently parallelised ; a more involved scheduler would need to be implemented when MTGs are modified by models, and to handle more interesting parallelisation opportunities at specific scales. ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"There may be new parallelisation features for multi-plant simulations further down the road.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Hard-dependencies-can-only-have-one-parent-in-the-dependency-graph","page":"-","title":"Hard dependencies can only have one parent in the dependency graph","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"The final dependency graph is comprised only of soft dependency nodes, and is guaranteed to contain no cycles. Hard dependencies are handled internally by their soft dependency ancestor. To avoid any ambiguity in terms of processing order, only one soft dependency node can 'own' a hard dependency And similarly, nested hard dependencies only have a single soft dependency ancestor.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"This is not solely an implementation detail of PlantSimEngine's internal mechanisms ; if your simulation requires complex coupling, you might need to carefully consider how to manage your hard dependencies, or insert an extra intermediate model to simplify thigns.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#A-model-can-only-be-used-once-per-scale","page":"-","title":"A model can only be used once per scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Similarly, both for graph creation non-ambiguity (and for simulation cohesion), PlantSimEngine currently assumes a model describing a process only occurs once per scale.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"Model renaming and duplicating works around this assumption. It may change once multi-plant/multi-species features are implemented.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#No-two-variables-with-the-same-name-at-the-same-scale","page":"-","title":"No two variables with the same name at the same scale","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"This rule avoids potential ambiguity which could then cause both problems in terms of model ordering during the simulation, as well as incorrectly coupling models with the wrong variable.","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"A workaround for some of the situations where this occurs is described here : Having a variable simultaneously as input and output of a model","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#TODO-Organs-missing-in-the-MTG-but-declared-in-the-mapping-?","page":"-","title":"TODO Organs missing in the MTG but declared in the mapping ?","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#Status-template-intialisation-order","page":"-","title":"Status template intialisation order","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/","page":"-","title":"-","text":"TODO ","category":"page"},{"location":"troubleshooting_and_testing/implicit_contracts/#Diffusion-systems-?","page":"-","title":"Diffusion systems ?","text":"","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts/#TODO-simulation-order,-node-order,-etc.","page":"-","title":"TODO simulation order, node order, etc.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nout = run!(model)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\nout2 = run!(model2, meteo_day)\n","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: Aqua QA) (Image: DOI) (Image: JOSS)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine is a comprehensive package for simulating and modelling plants, soil and atmosphere. It provides tools to prototype, evaluate, test, and deploy plant/crop models at any scale. At its core, PlantSimEngine is designed with a strong emphasis on performance and efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines a framework for declaring processes and implementing associated models for their simulation. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It focuses on key aspects of simulation and modeling such as: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easy definition of new processes, such as light interception, photosynthesis, growth, soil water transfer...\nFast, interactive prototyping of models, with constraints to help users avoid errors, but sensible defaults to avoid over-complicating the model writing process\nNo hassle, the package manages automatically input and output variables, time-steps, objects, soft and hard coupling of models with a dependency graph\nSwitch between models without changing any code, with a simple syntax to define the model to use for a given process\nReduce the degrees of freedom by fixing variables, passing measurements, or using a simpler model for a given process\n🚀(very) fast computation 🚀, think of 100th of nanoseconds for one model, two coupled models (see this benchmark script), or the full energy balance of a leaf using PlantBiophysics.jl that uses PlantSimEngine\nOut of the box Sequential, Parallel (Multi-threaded) or Distributed (Multi-Process) computations over objects, time-steps and independent processes (thanks to Floops.jl)\nEasily scalable, with methods for computing over objects, time-steps and even Multi-Scale Tree Graphs\nComposable, allowing the use of any types as inputs such as Unitful to propagate units, or MonteCarloMeasurements.jl to propagate measurement error","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easy to use, and to help users avoid errors when implementing, coupling and simulating models.","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example of a model that simulates the growth of a plant, using a simple exponential growth model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine\nusing PlantSimEngine\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nout = run!(model) # run the model and extract its outputs","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note   The ToyLAIModel is available from the examples folder, and is a simple exponential growth model. It is used here for the sake of simplicity, but you can use any model you want, as long as it follows PlantSimEngine interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course you can plot the outputs quite easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add CairoMakie\nusing CairoMakie\n\nlines(out[:TT_cu], out[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Cumulated growing degree days since sowing (°C)\"))","category":"page"},{"location":"#Model-coupling","page":"Home","title":"Model coupling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Model coupling is done automatically by the package, and is based on the dependency graph between the models. To couple models, we just have to add them to the ModelList. For example, let's couple the ToyLAIModel with a model for light interception based on Beer's law:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nout2 = run!(model2, meteo_day)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ModelList couples the models by automatically computing the dependency graph of the models. The resulting dependency graph is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"╭──── Dependency graph ──────────────────────────────────────────╮\n│  ╭──── LAI_Dynamic ─────────────────────────────────────────╮  │\n│  │  ╭──── Main model ────────╮                              │  │\n│  │  │  Process: LAI_Dynamic  │                              │  │\n│  │  │  Model: ToyLAIModel    │                              │  │\n│  │  │  Dep: nothing          │                              │  │\n│  │  ╰────────────────────────╯                              │  │\n│  │                  │  ╭──── Soft-coupled model ─────────╮  │  │\n│  │                  │  │  Process: light_interception    │  │  │\n│  │                  └──│  Model: Beer                    │  │  │\n│  │                     │  Dep: (LAI_Dynamic = (:LAI,),)  │  │  │\n│  │                     ╰─────────────────────────────────╯  │  │\n│  ╰──────────────────────────────────────────────────────────╯  │\n╰────────────────────────────────────────────────────────────────╯","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can plot the results by indexing the outputs with the variable name (e.g. out2[:LAI]):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, out2[:TT_cu], out2[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, out2[:TT_cu], out2[:aPPFD], color=:firebrick1)\n\nfig","category":"page"},{"location":"#Multiscale-modelling","page":"Home","title":"Multiscale modelling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Multi-scale modeling section for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easily scalable, and can be used to simulate models at different scales. For example, you can simulate a model at the leaf scale, and then couple it with models at any other scale, e.g. internode, plant, soil, scene scales. Here's an example of a simple model that simulates plant growth using sub-models operating at different scales:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapping=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\"],\n        ),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        MultiScaleModel(\n            model=ToyInternodeEmergence(TT_emergence=20.0),\n            mapping=[:TT_cu => \"Scene\"],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can import an example plant from the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mtg = import_mtg_example()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make a fake meteorological data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=300.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f=500.0)\n]\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"And run the simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"out_vars = Dict(\n    \"Scene\" => (:TT_cu,),\n    \"Plant\" => (:carbon_allocation, :carbon_assimilation, :soil_water_content, :aPPFD, :TT_cu, :LAI),\n    \"Leaf\" => (:carbon_demand, :carbon_allocation),\n    \"Internode\" => (:carbon_demand, :carbon_allocation),\n    \"Soil\" => (:soil_water_content,),\n)\n\nout = run!(mtg, mapping, meteo, tracked_outputs=out_vars, executor=SequentialEx());\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then extract the outputs in a DataFrame and sort them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames\ndf_out = convert_outputs(out, DataFrame)\nsort!(df_out, [:timestep, :node])","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example output of a multiscale simulation is shown in the documentation of PlantBiophysics.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Plant growth simulation)","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! 😃","category":"page"},{"location":"introduction/why_julia/#The-choice-of-using-Julia","page":"Why Julia ?","title":"The choice of using Julia","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine is implemented in Julia. It arose from a particular combination of needs and requirements, a combination which Julia seemed to fill adequately.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Other modelling frameworks, FSPMs and crop models are -often- written in combinations of Java, C++, Python, or Fortran. Given that it isn't the language many researchers (and developers !) are most familiar with, this page provides a short explanation of the reasoning behind that language choice. It might not have been the only possible valid choice, of course.","category":"page"},{"location":"introduction/why_julia/#A-researcher-developer-tool","page":"Why Julia ?","title":"A researcher-developer tool","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine is a goal oriented framework. Its features arose -and continue to evolve- out of necessity for more and more complex simulations. It wasn't a pre-designed piece of software.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"It was therefore originally a means to an end, and not a product in itself. ","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"TODO","category":"page"},{"location":"introduction/why_julia/#PlantSimEngine's-constraints","page":"Why Julia ?","title":"PlantSimEngine's constraints","text":"","category":"section"},{"location":"introduction/why_julia/#Performance","page":"Why Julia ?","title":"Performance","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While computers have gained several orders of magnitude of power and memory over the past few decades, to the point where many prior performance bottlenecks have vanished, performance can still be a limiting factor.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Simulating multiple processes with user-provided variables over many plants with tens of thousands of leaves requires a lot of computation. Using a higher-level language such as Python or R would not lead to adequate simulation times.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"In fact, part of the initial motivation to commit to Julia happened after porting an ecophysiological simulation from R to Julia and getting an order of magnitude difference in performance 'out-of-the-box'.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia, with its 'Just-ahead-of-time' compilation model and its flexibility allowing to do some lower-level optimisation, doesn't suffer from the limitations one would encounter by using only Python or R. ","category":"page"},{"location":"introduction/why_julia/#Flexibility,-ease-of-use","page":"Why Julia ?","title":"Flexibility, ease of use","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"PlantSimEngine was also developed with a few goals in mind, one of them being to make hypothesis testing quite easy. It is currently difficult to validate FSPM, crop model or ecophysiological hypotheses TODO","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Similarly, when developing a full-featured FSPM, there might be a need to test different models for a specific process, or to switch a model for a more complex one. API and language ease of use is as much of a factor as automated model coupling in keeping these changes smooth.","category":"page"},{"location":"introduction/why_julia/#Packages-destined-to-be-used-by-a-wider-community","page":"Why Julia ?","title":"Packages destined to be used by a wider community","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"As mentioned earlier, PlantSimEngine is intended for a wide audience. Only few of them are expected to have a strong development background. Many other potential users might be researchers more well-versed in ecophysiology or plant architecture and only know a little bit of Python, Matlab or R. Reducing friction for these users is paramount.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Open-source libraries/packages, ease of installation and low entry barrier also factor in the decision.","category":"page"},{"location":"introduction/why_julia/#Modularity-and-flexibility-while-retaining-performance","page":"Why Julia ?","title":"Modularity and flexibility while retaining performance","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"One approach could be to combine, say, Python, with a more performant language such as C++ or Fortran. The slower but flexible language being used for prototyping, and when performance is required, some chunks are reimplmented in the other language.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"This fits the performance constraint, but has a few caveats.","category":"page"},{"location":"introduction/why_julia/#Low-developer-bandwidth","page":"Why Julia ?","title":"Low developer bandwidth","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"And of course, budget, time and resources are a concern. The more autonomous researchers and modelers are, and the less specialist developer/engineering resources are required, the easier it is for the project to keep evolving.","category":"page"},{"location":"introduction/why_julia/#Comparison","page":"Why Julia ?","title":"Comparison","text":"","category":"section"},{"location":"introduction/why_julia/#The-Two-Language-Problem","page":"Why Julia ?","title":"The Two-Language Problem","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Combining two different languages requires a lot of language expertise, with constant knowledge refreshing, as one might only occasionally work with and debug with the lower-level language. Or more engineering resources.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Speed of iteration is also lost whenever performance is a concern, which happens often in our context. However modular and easy-to-use a language like Python might be, whenever it's time to switch to a low-level language, development speed will slow down.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia, while likely being a little harder to learn than Python, and require extra knowledge to properly make use of its flexibility and performance capabilities, leads to a significantly smoother development experience.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Everything can be done using Julia exclusively, so there is no need to learn two languages. No need to interface between them. Iteration speed doesn't suddenly grind to a halt if a low-level implementation is needed. A competent researcher-developer might have less need of engineering resources, while still being able to work a lot on modeling and the actual plant side of things.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"TODO image ML","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"It seems we aren't the only ones to feel Julia is the right tool for our job for those reasons. Indeed, other niches where Julia seems to thrive tend to be other computationally heavy areas with much active research, such as ML and climate modeling.","category":"page"},{"location":"introduction/why_julia/#A-good-balance-in-terms-of-accessibility","page":"Why Julia ?","title":"A good balance in terms of accessibility","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Another argument in favour of Julia is that one of the aims for PlantSimEngine is to be easy-to-use for researchers wishing to test hypothesis, or reproduce results from other papers. TODO","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Many researchers are not developers by trade or heart, and a Java-only or C++-only implementation, on top of the earlier points, would not be accessible enough and would not gain much traction.","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Julia, while less ubiquitous than other languages in research circles, resembles Python and R and is more beginner-friendly than Java or C++. It is easier for a Python user to learn to use a simple Julia package than a C++ one. ","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Users will also find it easier to quickly implement new models without the potential hurdle of a low-level implementation, or some language interfacing also being required. The prototyping phase doesn't require a subsequent performance tuning phase.","category":"page"},{"location":"introduction/why_julia/#Ease-of-environment-setup","page":"Why Julia ?","title":"Ease of environment setup","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"Similarly, Julia's language and package installation is -mostly- fairly straightforward and requires little additional knowledge.","category":"page"},{"location":"introduction/why_julia/#Downsides-acceptable","page":"Why Julia ?","title":"Downsides acceptable","text":"","category":"section"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"While very practical for a 'researcher-developer', Julia is of course far from being the perfect language in every discipline. It is massive in terms of features, has a heavy runtime, is more involved to learn and master quickly compared to Python, has a few hurdles for beginners, some quirks that can be awkward for developers, tools that aren't fully mature, no clear 'recommended' workflow, and so on. ","category":"page"},{"location":"introduction/why_julia/","page":"Why Julia ?","title":"Why Julia ?","text":"The cost for switching may not be worth it in many other circumstances. However, several of these downsides, while very relevant for embedded systems, or game development, are much less relevant regarding PlantSimEngine. And others can be mitigated with, hopefully, adequate learning resources and documentation.","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Model coupling for users","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls again run! inside its implementation at some point. Note that it does not force any kind of conductance model over another, just that there is one to simulate the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We provide an example script that implements seven dummy processes in examples/dummy. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model... ","category":"page"},{"location":"model_coupling/model_coupling_user/#Hard-coupled-models","page":"Model coupling for users","title":"Hard coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The Process3Model calls Process2Model, and Process2Model calls Process1Model. This explicit call is called a hard-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The other models for the other processes are called Process4Model, Process5Model... and they do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"tip: Tip\nHard-coupling of models is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is hard-coupled to a photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Back to our example, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's use the Examples sub-module so we can play around:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"tip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Here is how we can make the model coupling:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Note that the user only declares the models, not the way the models are coupled because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Now the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their hard or soft-coupling.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"For example, Process1Model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"inputs(Process1Model(2.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"And Process2Model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"inputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"outputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"So considering those two models, we only need var1 and var2 to be initialized, as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"page"},{"location":"model_coupling/model_coupling_user/#Soft-coupled-models","page":"Model coupling for users","title":"Soft coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"All following models (Process4Model to Process7Model) do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's make a new model list including the soft-coupled models:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"With this list of models, we only need to initialize var0, that is an input of Process4Model and Process7Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"to_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"We can initialize it like so:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"model_coupling/model_coupling_user/#Simulation-order","page":"Model coupling for users","title":"Simulation order","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"When calling run!, the models are run in the right order using a dependency graph that is computed automatically based on the hard and soft dependencies of the models following a simple set of rules:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Model coupling for users","title":"Model coupling for users","text":"Independent models are run first. A model is independent if it can be run alone, or only using initializations. It is not dependent on any other model.\nFrom their children dependencies:\nHard dependencies are always run before soft dependencies. Inner hard dependency graphs are considered as a whole, i.e. as a single soft dependency.\nSoft dependencies are then run sequentially. If a soft dependency has several parent nodes (i.e. its inputs are computed by several models), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"}]
}
