<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Key Concepts · PlantSimEngine.jl</title><meta name="title" content="Key Concepts · PlantSimEngine.jl"/><meta property="og:title" content="Key Concepts · PlantSimEngine.jl"/><meta property="twitter:title" content="Key Concepts · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites/key_concepts/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites/key_concepts/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites/key_concepts/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li class="is-active"><a class="tocitem" href>Key Concepts</a><ul class="internal"><li><a class="tocitem" href="#Crop-models"><span>Crop models</span></a></li><li><a class="tocitem" href="#FSPM"><span>FSPM</span></a></li><li><a class="tocitem" href="#PlantSimEngine-terminology"><span>PlantSimEngine terminology</span></a></li></ul></li><li><a class="tocitem" href="../julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../../multiscale/multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../../multiscale/single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../../multiscale/multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../../multiscale/multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../../multiscale/multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../multiscale/multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li><li><a class="tocitem" href="../../multiscale/multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/API_public/">Public API</a></li><li><a class="tocitem" href="../../API/API_examples/">Example models</a></li><li><a class="tocitem" href="../../API/API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../credits/">Credits</a></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Prerequisites</a></li><li class="is-active"><a href>Key Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Key Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/prerequisites/key_concepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Key-Concepts"><a class="docs-heading-anchor" href="#Key-Concepts">Key Concepts</a><a id="Key-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts" title="Permalink"></a></h1><p>You&#39;ll find a brief description of some of the main concepts and terminology related to and used in PlantSimEngine. </p><ul><li><a href="#Key-Concepts">Key Concepts</a></li><li class="no-marker"><ul><li><a href="#Crop-models">Crop models</a></li><li><a href="#FSPM">FSPM</a></li><li><a href="#PlantSimEngine-terminology">PlantSimEngine terminology</a></li><li class="no-marker"><ul><li><a href="#Processes">Processes</a></li><li><a href="#Models">Models</a></li><li><a href="#Variables,-inputs,-outputs,-and-model-coupling">Variables, inputs, outputs, and model coupling</a></li><li><a href="#Dependency-graphs">Dependency graphs</a></li><li><a href="#hard_dependency_def">&quot;Hard&quot; and &quot;Soft&quot; dependencies</a></li><li><a href="#Weather-data">Weather data</a></li><li><a href="#Organ/Scale">Organ/Scale</a></li><li><a href="#Multiscale-modeling">Multiscale modeling</a></li><li><a href="#Multi-scale-Tree-Graphs">Multi-scale Tree Graphs</a></li><li class="no-marker"><ul><li><a href="#Scale/symbol-terminology-ambiguity">Scale/symbol terminology ambiguity</a></li></ul></li><li><a href="#State-machines">State machines</a></li></ul></li></ul></li></ul><h2 id="Crop-models"><a class="docs-heading-anchor" href="#Crop-models">Crop models</a><a id="Crop-models-1"></a><a class="docs-heading-anchor-permalink" href="#Crop-models" title="Permalink"></a></h2><h2 id="FSPM"><a class="docs-heading-anchor" href="#FSPM">FSPM</a><a id="FSPM-1"></a><a class="docs-heading-anchor-permalink" href="#FSPM" title="Permalink"></a></h2><h2 id="PlantSimEngine-terminology"><a class="docs-heading-anchor" href="#PlantSimEngine-terminology">PlantSimEngine terminology</a><a id="PlantSimEngine-terminology-1"></a><a class="docs-heading-anchor-permalink" href="#PlantSimEngine-terminology" title="Permalink"></a></h2><p>This page provides a general description of the concepts and terminology used in PlantSimEngine. For a more implementation-guided description of the design and some of the terms presented here, see the <a href="../../step_by_step/detailed_first_example/#Detailed-walkthrough-of-a-simple-simulation">Detailed walkthrough of a simple simulation</a></p><p>!!! Note     Some terminology unfortunately has different meanings in different contexts. This is particularly true of the terms organ, scale and symbol, which have a different meaning for <a href="#Multi-scale-Tree-Graphs">Multi-scale Tree Graphs</a> than the rest of PlantSimEngine (see <a href="#Scale/symbol-terminology-ambiguity">Scale/symbol terminology ambiguity</a> further down). Make sure to double-check those subsections, and relevant examples if you encounter issues relating to these terms.</p><h3 id="Processes"><a class="docs-heading-anchor" href="#Processes">Processes</a><a id="Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Processes" title="Permalink"></a></h3><p>A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.</p><p>See <a href="../../step_by_step/implement_a_process/#Implementing-a-new-process">Implementing a new process</a> for a brief explanation on how to declare a new process.</p><h3 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h3><p>Models are then implemented for a particular process. </p><p>There may be different models that can be used for the same process ; for instance, there are multiple hypotheses and ways of modeling photosynthesis, with different granularity and accuracy. A simple photosynthesis model might apply a simple formula and apply it to the total leaf surface, a more complex one might calculate interception and light extinction. </p><p>The companion package PlantBiophysics.jl provides the <a href="https://vezy.github.io/PlantBiophysics.jl/stable/functions/#PlantBiophysics.Beer"><code>Beer</code></a> structure for the implementation of the Beer-Lambert law of light extinction. The process of <code>light_interception</code> and the <code>Beer</code> model are provided as an example script in this package too at <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/master/examples/Beer.jl"><code>examples/Beer.jl</code></a>.</p><p>Models can also be used for ad hoc computations that aren&#39;t directly tied to a specific literature-defined physiological process. In PlantSimEngine, everything is a model. There are many instances where a custom model might be practical to aggregate some computations or handle other information. To illustrate, XPalm, the Oil Palm model has a few models that handle the state of different organs, and a mdoel to handle leaf pruning, which you can find <a href="https://github.com/PalmStudio/XPalm.jl/blob/main/src/plant/phytomer/leaves/leaf_pruning.jl">here</a>.</p><p>To prepare a simulation, you declare a ModelList with whatever models you wish to make use of and initialize necessary parameters: see the <a href="#step_by_step">step<em>by</em>step</a> section to learn how to use them in practice.</p><p>For multi-scale simulations, models need to be tied to a particular scale when used. See the <a href="#Multiscale-modeling">Multiscale modeling</a> section below, or the <a href="../../multiscale/multiscale_considerations/#Multi-scale-considerations">Multi-scale considerations</a> page for a more detailed description of multi-scale peculiarities.</p><h3 id="Variables,-inputs,-outputs,-and-model-coupling"><a class="docs-heading-anchor" href="#Variables,-inputs,-outputs,-and-model-coupling">Variables, inputs, outputs, and model coupling</a><a id="Variables,-inputs,-outputs,-and-model-coupling-1"></a><a class="docs-heading-anchor-permalink" href="#Variables,-inputs,-outputs,-and-model-coupling" title="Permalink"></a></h3><p>A model used in a simulation requires some input data and parameters, and will compute some other data which may be used by other models.  Depending on what models are combined in a simulation, some variables may be inputs of some models, outputs of other models, only be part of intermediary computations, or be a user input to the whole simulation.</p><p>Here&#39;s a conceptual model coupling example; each &quot;node&quot; is equivalent to a distinct PlantSimEngine model, &quot;compute()&quot; is equivalent to the model&#39;s &quot;run!&quot; function:</p><p><img src="../../www/GUID-12E2DDAD-7B20-4FE2-AA36-7FAC950382A6-low.png" alt="Model coupling example"/> (Source: <a href="https://help.autodesk.com/view/MAYAUL/2016/ENU/?guid=__files_GUID_A9070270_9B5D_4511_8012_BC948149884D_htm&quot;">Autodesk</a>)</p><h3 id="Dependency-graphs"><a class="docs-heading-anchor" href="#Dependency-graphs">Dependency graphs</a><a id="Dependency-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Dependency-graphs" title="Permalink"></a></h3><p>Coupling models together in this fashion creates what is known as a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph</a> or DAG, a type of <a href="https://en.wikipedia.org/wiki/Dependency_graph">dependency graph</a>. The order in which models are run is determined by the ordering of these models in that graph.</p><p><img src="../../www/dags_acyclic_vs_cyclic-d1a669bf1b8b6bfa8ac3041788e81171.png" alt="Example DAG"/> A simple Directed Acyclic Graph, note the required absence of cycles. Source: <a href="https://www.astronomer.io/docs/learn/dags/">Astronomer</a></p><p>PlantSimEngine creates this Directed Acyclic Graph under the hood by plugging the right variables in the right models. Users therefore only need to declare models, they do not need write the code to connect them as PlantSimEngine does that work for them, as long as the model coupling has no cyclic dependency.</p><h3 id="hard_dependency_def"><a class="docs-heading-anchor" href="#hard_dependency_def">&quot;Hard&quot; and &quot;Soft&quot; dependencies</a><a id="hard_dependency_def-1"></a><a class="docs-heading-anchor-permalink" href="#hard_dependency_def" title="Permalink"></a></h3><p>Linking models by setting output variables from one model as input of another model handles many typical couplings (with more situations occurring with multi-scale models and variables), but what if two models are interdependent ? What if they need to iterate on some computation and pass variables back and forth ? </p><p>You can find a typical example in a companion package: <a href="https://github.com/VEZY/PlantBiophysics.jl">PlantBioPhysics.jl</a>. An energy balance model, the <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">Monteith model</a>, needs to <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/c1a75f294109d52dc619f764ce51c6ca1ea897e8/src/processes/energy/Monteith.jl#L154">iteratively run a photosynthesis model</a> in its <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function. </p><p>See the illustration below of the way these models are interdependent:</p><p><img src="../../www/ecophysio_coupling_diagram.png" alt="Example of a coupling with cycles"/></p><p>Example of a coupling with a cycle. Source: TODO</p><p>Model couplings that cause simulation to flow both ways break the &#39;acyclic&#39; assumption of the dependency graph.</p><p>PlantSimEngine handles this internally by not having those &quot;heavily-coupled&quot; models -called &quot;hard dependencies&quot; from now on- be part of the main dependency graph. Instead, they are made to be children nodes of the parent/ancestor model, which handles them internally, so they aren&#39;t tied to other nodes of the dependency graph. The resulting higher-level graph therefore only links models without any two-way interdependencies, and remains a directed graph, enabling a cohesive simulation order. The simpler couplings in that top-level graph are called &quot;soft dependencies&quot;.</p><p><img src="../../www/PBP_dependency_graph.png" alt="Hard dependency coupling visualization in PlantSimEngine"/> The previous coupling, handled by PlantSimEngine</p><p>How PlantSimEngine links these models under the hood. The red models (&quot;hard dependencies&quot;) are not exposed in the final dependency graph, which only contains the blue &quot;soft dependencies&quot;, and has no cycles.</p><p>This approach does have implications when developing interdependent models : hard dependencies need to be made explicit, and the ancestor needs to call the hard dependency model&#39;s <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function explicitely in its own <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function. Hard dependency models therefore must have only one parent model. </p><p>This reliance on another process makes these models slightly more complex to develop and validate, and less versatile than simpler models. Occasional refactoring may be necessary to handle a hard dependency creeping up when adding new models to a simulation.</p><p>Note that hard dependencies can also have their own hard dependencies, and some complex couplings can happen. A hard dependency model can have another hard dependency model as a parent.</p><h3 id="Weather-data"><a class="docs-heading-anchor" href="#Weather-data">Weather data</a><a id="Weather-data-1"></a><a class="docs-heading-anchor-permalink" href="#Weather-data" title="Permalink"></a></h3><p>To run a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.</p><p>Users are strongly encouraged to use <a href="https://github.com/PalmStudio/PlantMeteo.jl"><code>PlantMeteo.jl</code></a>, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. We will make constant use of it throughout the documentation, and recommend working with it. </p><p>The most basic data structure from this package is a type called <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.Atmosphere"><code>Atmosphere</code></a>, which defines steady-state atmospheric conditions, <em>i.e.</em> the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.TimeStepTable"><code>TimeStepTable</code></a>.</p><p>The mandatory variables to provide for an <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.Atmosphere"><code>Atmosphere</code></a> are: <code>T</code> (air temperature in °C), <code>Rh</code> (relative humidity, 0-1) and <code>Wind</code> (the wind speed, m s⁻¹). </p><p>In the example below, we also pass in the -optional- incoming photosynthetically active radiation flux (<code>Ri_PAR_f</code>, W m⁻²). We can declare such conditions like so:</p><pre><code class="language-julia hljs">using PlantMeteo
meteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Atmosphere(date = Dates.DateTime(&quot;2025-03-21T12:18:44.541&quot;), duration = Dates.Second(1), T = 20.0, Wind = 1.0, P = 101.325, Rh = 0.65, Precipitations = 0.0, Cₐ = 400.0, e = 1.5255470730405223, eₛ = 2.3469954969854188, VPD = 0.8214484239448965, ρ = 1.2040822421461452, λ = 2.4537e6, γ = 0.06725339460440805, ε = 0.5848056484857892, Δ = 0.14573378083416522, clearness = Inf, Ri_SW_f = Inf, Ri_PAR_f = 500.0, Ri_NIR_f = Inf, Ri_TIR_f = Inf, Ri_custom_f = Inf)</code></pre><p>More details are available from the <a href="https://vezy.github.io/PlantMeteo.jl/stable">package documentation</a>. If you do not wish to make use of this package, you can alternately provide your own data, as long as it respects the <a href="https://tables.juliadata.org/stable/#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)">Tables.jl interface</a>.</p><p>If you wish to make use of more fine-grained weather data, it will likely require more advanced model creation and MTG manipulation, and more involved work on the modeling side.∂</p><h3 id="Organ/Scale"><a class="docs-heading-anchor" href="#Organ/Scale">Organ/Scale</a><a id="Organ/Scale-1"></a><a class="docs-heading-anchor-permalink" href="#Organ/Scale" title="Permalink"></a></h3><p>Plants have different organs with distinct physiological properties and processes. When doing more fine-grained simulations of plant growth, many models will be tied to a particular organ of a plant. Models handling flowering state or root water absorption are such examples. Others, such as carbon allocation and demand, might be reused in slightly different ways for multiple organs of the plant.</p><p>PlantSimEngine documentation tends to use the terms &quot;organ&quot; and &quot;scale&quot; mostly interchangeably. &quot;Scale&quot; is a bit more general and accurate, since some models might not operate at a specific organ level, but (for example) at the scene level, so a &quot;Scene&quot; scale might be present in the MTG, and in the user-provided data.</p><p>When working with multi-scale data, the scale will often need to be specified to map variables, or to indicate at what scale level models work out. You will see some code resembling this :</p><pre><code class="language-julia hljs">&quot;Root&quot; =&gt; (RootGrowthModel(), OrganAgeModel()),
&quot;Leaf&quot; =&gt; (LightInterceptionModel(), OrganAgeModel()),
&quot;Plant&quot; =&gt; (TotalBiomassModel(),),</code></pre><p>This example excerpt links specific models to a specific scale. Note that one model is reused at two different scales, and note that &quot;Plant&quot; isn&#39;t an actual organ, hence the preferred usage of the term &quot;scale&quot;.</p><h3 id="Multiscale-modeling"><a class="docs-heading-anchor" href="#Multiscale-modeling">Multiscale modeling</a><a id="Multiscale-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Multiscale-modeling" title="Permalink"></a></h3><p>Multi-scale modeling is the process of simulating a system at multiple levels of detail simultaneously. Some models might run at the organ scale while others run at the plot scale. Each model can access variables at its scale and other scales if needed, allowing for a more comprehensive system representation. It can also help identify emergent properties that are not apparent at a single level of detail. </p><p>For example, a model of photosynthesis at the leaf scale can be combined with a model of carbon allocation at the plant scale to simulate the growth and development of the plant. Another example is a combination of models to simulate the energy balance of a forest. To simulate it, you need a model for each organ type of the plant, another for the soil, and finally, one at the plot scale, integrating all others.</p><p>When running multi-scale simulations which contain models operating at different organ levels for the plant, extra information needs to be provided by the user to run models. Since some models are reused at different organ levels, it is necessary to indicate which organ level a model operates at.</p><p>This is why multi-scale simulations make use of a &#39;mapping&#39; : the ModelList in the single-scale examples does not have a way to tie models to plant organs,and the more versatile models could be used in various places. The user must also indicate how models operate with other scales, e.g. if an input variable comes from another scale, it is required to indicate which scale it is mapped from.</p><p>You can read more about some practical differences as a user between single- and multi-scale simulations here: <a href="../../multiscale/multiscale_considerations/#Multi-scale-considerations">Multi-scale considerations</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When you encounter the terms &quot;Single-scale simulations&quot;, or &quot;ModelList simulations&quot;, they will refer to simulations that are &quot;not multi-scale&quot;. A multi-scale simulation makes use of a mapping between different organ/scale levels. A single-scale simulation has no such mapping, and uses the simpler ModelList interface.  You can implement a mapping that only makes use of a single scale level, of course, making it a &quot;single-scale multi-scale simulation&quot;, but <strong>unless otherwise specified, single-scale, and the whole section dedicated to single-scale simulations, refer to simulations with ModelList objects, and no mapping</strong>.</p></div></div><h3 id="Multi-scale-Tree-Graphs"><a class="docs-heading-anchor" href="#Multi-scale-Tree-Graphs">Multi-scale Tree Graphs</a><a id="Multi-scale-Tree-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-scale-Tree-Graphs" title="Permalink"></a></h3><p><img src="../../www/Grassy_plant_MTG_vertical.svg" alt="Grassy plant and equivalent MTG"/></p><p>A Grassy plant and its equivalent MTG</p><p>Multi-scale Tree Graphs (MTG) are a data structure used to represent plants. A more detailed introduction to the format and its attributes can be found <a href="https://vezy.github.io/MultiScaleTreeGraph.jl/stable/the_mtg/mtg_concept/">in the MultiScaleTreeGraph.jl package documentation</a>.</p><p>Multi-scale simulations can operate on MTG objects ; new nodes are added corresponding to new organs created during the plant&#39;s growth.</p><p>You can see a basic display of an MTG by simply typing its name in the REPL:</p><p><img src="../../www/MTG_output.png" alt="example display of an MTG in PlantSimEngine"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Another companion package, <a href="https://github.com/VEZY/PlantGeom.jl">PlantGeom.jl</a>, can also create MTG objects from .opf files (corresponding to the <a href="https://amap-dev.cirad.fr/projects/xplo/wiki/The_opf_format_(*opf)">Open Plant Format</a>, an alternate means of describing plants computationally).</p></div></div><p>TODO lien avec AMAP ?</p><h4 id="Scale/symbol-terminology-ambiguity"><a class="docs-heading-anchor" href="#Scale/symbol-terminology-ambiguity">Scale/symbol terminology ambiguity</a><a id="Scale/symbol-terminology-ambiguity-1"></a><a class="docs-heading-anchor-permalink" href="#Scale/symbol-terminology-ambiguity" title="Permalink"></a></h4><p>Multi-scale tree graphs have different terminology (see <a href="#Organ/Scale">Organ/Scale</a>):</p><ul><li>a symbol corresponds to a PlantSimEngine scale, eg &quot;Plant&quot;, &quot;Root&quot;, and has nothing to do with the Julia programming language&#39;s definition of symbol (eg <code>:var</code>)</li><li>Scales are integers passed to the Node constructor describing the level of description of the tree graph object. They don&#39;t always have a one-to-one correspondence to a multi-scale simulation&#39;s scales, but are similar.</li></ul><p><img src="../../www/Grassy_plant_scales.svg" alt="Three scale levels on an MTG, which differ from typical PlantSimEngine concept of scale"/></p><p>You can find a brief description of the MTG concepts <a href="https://vezy.github.io/MultiScaleTreeGraph.jl/stable/the_mtg/mtg_concept/#Node-MTG-and-attributes">here</a>.</p><p>Other words are unfortunately reused in various contexts with different meanings: tree/leaf/root have a different meaning when talking about computer science data structure (eg, graphs, dependency graphs and trees).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the majority of cases, you can assume the tree-related terminology refers to the biological terms, and that &quot;organ&quot; refer to plant organs, and &quot;single-scale&quot;, &quot;multi-scale&quot; and &quot;scale&quot; to PlantSimEngine&#39;s concept of scales described in <a href="#Organ/Scale">Organ/Scale</a>. MTG objects are mostly manipulated no a per-node basis, unless a model makes use of functions relating to MTG traversal, in which case you may expect computer science terminology.</p></div></div><h3 id="State-machines"><a class="docs-heading-anchor" href="#State-machines">State machines</a><a id="State-machines-1"></a><a class="docs-heading-anchor-permalink" href="#State-machines" title="Permalink"></a></h3><p>A state machine is a computational concept used to model mechanisms and devices, which may be of interest for your simulations.</p><p><img src="../../www/Turnstile_state_machine_colored.svg.png" alt="State machine image"/> A simple state machine. See the <a href="https://en.wikipedia.org/wiki/Finite-state_machine">wikipedia page</a> for more examples.</p><p>State machines can be useful to model organ state: some organs in <a href="https://github.com/PalmStudio/XPalm.jl">XPalm.jl</a>, a package modelling the oil palm using PlantSimEngine, have a <code>state</code> variable behaving like a state machine, indicating whether an organ is mature, pruned, flowering, etc.</p><p>You can find an example model (amongst other such models) affecting the <code>state</code> variable of some organs depending on their age and thermal time in the XPalm oil palm FSPM <a href="https://github.com/PalmStudio/XPalm.jl/blob/main/src/plant/phytomer/phytomer/state.jl">here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installing_plantsimengine/">« Installing and running PlantSimEngine</a><a class="docs-footer-nextpage" href="../julia_basics/">Julia language basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 21 March 2025 12:19">Friday 21 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
