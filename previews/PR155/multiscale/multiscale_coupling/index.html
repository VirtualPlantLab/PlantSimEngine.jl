<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiscale coupling considerations · PlantSimEngine.jl</title><meta name="title" content="Multiscale coupling considerations · PlantSimEngine.jl"/><meta property="og:title" content="Multiscale coupling considerations · PlantSimEngine.jl"/><meta property="twitter:title" content="Multiscale coupling considerations · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_coupling/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_coupling/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_coupling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../multiscale_cyclic/">Handling cyclic dependencies</a></li><li class="is-active"><a class="tocitem" href>Multiscale coupling considerations</a><ul class="internal"><li><a class="tocitem" href="#Scalar-and-vector-variable-mappings"><span>Scalar and vector variable mappings</span></a></li><li><a class="tocitem" href="#Hard-dependencies-between-models-at-different-scale-levels"><span>Hard dependencies between models at different scale levels</span></a></li><li><a class="tocitem" href="#Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale"><span>Implementation details: accessing a hard dependency&#39;s variables from a different scale</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li><li><a class="tocitem" href="../multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/API_public/">Public API</a></li><li><a class="tocitem" href="../../API/API_examples/">Example models</a></li><li><a class="tocitem" href="../../API/API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Moving to multiscale</a></li><li class="is-active"><a href>Multiscale coupling considerations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiscale coupling considerations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/multiscale/multiscale_coupling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Handling-dependencies-in-a-multiscale-context"><a class="docs-heading-anchor" href="#Handling-dependencies-in-a-multiscale-context">Handling dependencies in a multiscale context</a><a id="Handling-dependencies-in-a-multiscale-context-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-dependencies-in-a-multiscale-context" title="Permalink"></a></h1><ul><li><a href="#Handling-dependencies-in-a-multiscale-context">Handling dependencies in a multiscale context</a></li><li class="no-marker"><ul><li><a href="#Scalar-and-vector-variable-mappings">Scalar and vector variable mappings</a></li><li><a href="#Hard-dependencies-between-models-at-different-scale-levels">Hard dependencies between models at different scale levels</a></li><li class="no-marker"><ul><li><a href="#An-example-from-the-toy-plant-simulation-tutorial">An example from the toy plant simulation tutorial</a></li><li><a href="#An-example-from-XPalm.jl">An example from XPalm.jl</a></li></ul></li><li><a href="#Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale">Implementation details: accessing a hard dependency&#39;s variables from a different scale</a></li><li class="no-marker"><ul><li><a href="#Back-to-the-XPalm-example">Back to the XPalm example</a></li></ul></li></ul></li></ul><h2 id="Scalar-and-vector-variable-mappings"><a class="docs-heading-anchor" href="#Scalar-and-vector-variable-mappings">Scalar and vector variable mappings</a><a id="Scalar-and-vector-variable-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-and-vector-variable-mappings" title="Permalink"></a></h2><p>In the detailed example discussed previously <a href="../multiscale/#Multi-scale-variable-mapping">Multi-scale variable mapping</a>, there were several instances of mapping a variable from one scale to another, which we&#39;ll briefly describe again to help transition to the next and more advanced subsection. Here&#39;s a relevant exerpt from the mapping : </p><pre><code class="language-julia hljs">&quot;Plant&quot; =&gt; (
        MultiScaleModel(
            model=ToyLAIModel(),
            mapped_variables=[
                :TT_cu =&gt; &quot;Scene&quot;,
            ],
        ),
        ...
        MultiScaleModel(
            model=ToyCAllocationModel(),
            mapped_variables=[
                :carbon_assimilation =&gt; [&quot;Leaf&quot;],
                :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;],
                :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]
            ],
        ),
        ...
    ),</code></pre><p>For flexibility reasons, instead of explicitely linking most models from different scales together, one only declares which variables are meant to be taken from another scale (or more accurately, a model at a different scale outputting those variables). This keeps the convenience of switching models while making few changes to the mapping. </p><p>However, PlantSimEngine cannot infer which scales have multiple instances, and which are single-instance, as the scale names are user-defined.</p><p>In the above example, there is only one scene at the &quot;Scene&quot;, and one plant at the &quot;Plant&quot; scale, meaning the <code>TT_cu</code> variable mapped between the two has a one-to-one scalar-to-scalar correspondance.</p><p>On the other hand, the <code>carbon_assimilation</code> variable is computed for <strong>every</strong> leaf, of which there could be hundreds, or thousands, giving a scalar-to-vector correspondance. The carbon assimilation model runs many times every timestep, whereas the carbon allocation model only runs once per timestep. There may be initially be only a single leaf, though, meaning PlantSimEngine cannot currently guess from the initial configuration that there might be multiple leaves created during the simulation.</p><p>Hence the difference in mapping declaration :  <code>TT_cu</code>is declared as a scalar correspondence : </p><pre><code class="language-julia hljs">:TT_cu =&gt; &quot;Scene&quot;,</code></pre><p>whereas <code>carbon_assimilation</code> (and other variables) will be declared as a vector correspondence :</p><pre><code class="language-julia hljs">:carbon_assimilation =&gt; [&quot;Leaf&quot;],</code></pre><p>Note that there may be instances where you might wish to write your own model to aggregate a variable from a multi-instance scale.</p><h2 id="Hard-dependencies-between-models-at-different-scale-levels"><a class="docs-heading-anchor" href="#Hard-dependencies-between-models-at-different-scale-levels">Hard dependencies between models at different scale levels</a><a id="Hard-dependencies-between-models-at-different-scale-levels-1"></a><a class="docs-heading-anchor-permalink" href="#Hard-dependencies-between-models-at-different-scale-levels" title="Permalink"></a></h2><p>If a model requires some input variable that is computed at another scale, then providing the appropriate mapping for that variable will resolve name conflicts and enable that model to run with no further steps for the user or the modeler when the coupling is a &#39;soft dependency&#39;.</p><p>In the case of a hard dependency that operates <strong>at the same scale as its parent</strong>, declaring the hard dependency is exactly the same as in single-scale simulations and there are also no new extra steps on the user-side:</p><ul><li>The parent model directly handles the call to its hard dependency model(s), meaning they are not explicitely managed by the top-level dependency graph.</li><li>This means only the owning model of that dependency is visible in the graph, and its hard dependency nodes are internal.</li><li>When the caller (or any downstream model that requires some variables from the hard dependency model) operates at the same scale, variables are easily accessible, and no mapping is required. </li></ul><p>On the other hand, modelers do need to bear in mind a couple of subtleties when developing models that possess hard dependencies that operate <strong>at a different organ level from their parent</strong>: </p><p>If an model needs to be directly called by a parent but operates at a different scale/organ level, a modeler must declare hard dependencies with their respective organ level, similarly to the way the user provides a mapping. </p><p>Conceptually :</p><pre><code class="language-julia hljs"> PlantSimEngine.dep(m::ParentModel) = (
    name_provided_in_the_mapping=AbstractHardDependencyModel =&gt; [&quot;Organ_Name_1&quot;,],
)</code></pre><h3 id="An-example-from-the-toy-plant-simulation-tutorial"><a class="docs-heading-anchor" href="#An-example-from-the-toy-plant-simulation-tutorial">An example from the toy plant simulation tutorial</a><a id="An-example-from-the-toy-plant-simulation-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#An-example-from-the-toy-plant-simulation-tutorial" title="Permalink"></a></h3><p>You can find an example of a hard dependency discussed in the <a href="../multiscale_example_3/#A-multi-scale-hard-dependency-appears">A multi-scale hard dependency appears</a> subsection of the third part of toy plant tutorial.</p><h3 id="An-example-from-XPalm.jl"><a class="docs-heading-anchor" href="#An-example-from-XPalm.jl">An example from XPalm.jl</a><a id="An-example-from-XPalm.jl-1"></a><a class="docs-heading-anchor-permalink" href="#An-example-from-XPalm.jl" title="Permalink"></a></h3><p>Here&#39;s a concrete example in <a href="https://github.com/PalmStudio/XPalm.jl">XPalm</a>, an oil palm model developed on top of PlantSimEngine.   Organs are produced at the phytomer scale, but need to run an age model and a biomass model at the reproductive organs&#39; scales.</p><pre><code class="language-julia hljs"> PlantSimEngine.dep(m::ReproductiveOrganEmission) = (
    initiation_age=AbstractInitiation_AgeModel =&gt; [m.male_symbol, m.female_symbol],
    final_potential_biomass=AbstractFinal_Potential_BiomassModel =&gt; [m.male_symbol, m.female_symbol],
)</code></pre><p>The user-mapping includes the required models at specific organ levels. Here&#39;s the relevant portion of the mapping for the male reproductive organ :</p><pre><code class="language-julia hljs">mapping = Dict(
    ...
    &quot;Male&quot; =&gt;
    MultiScaleModel(
        model=XPalm.InitiationAgeFromPlantAge(),
        mapped_variables=[:plant_age =&gt; &quot;Plant&quot;,],
    ),
    ...
    XPalm.MaleFinalPotentialBiomass(
        p.parameters[:male][:male_max_biomass],
        p.parameters[:male][:age_mature_male],
        p.parameters[:male][:fraction_biomass_first_male],
    ),
    ...
)</code></pre><p>The model&#39;s constructor provides convenient default names for the scale corresponding to the reproductive organs. A user may override that if their naming schemes or MTG attributes differ.</p><pre><code class="language-julia hljs">function ReproductiveOrganEmission(mtg::MultiScaleTreeGraph.Node; phytomer_symbol=&quot;Phytomer&quot;, male_symbol=&quot;Male&quot;, female_symbol=&quot;Female&quot;)
    ...
end</code></pre><h2 id="Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale"><a class="docs-heading-anchor" href="#Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale">Implementation details: accessing a hard dependency&#39;s variables from a different scale</a><a id="Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details:-accessing-a-hard-dependency&#39;s-variables-from-a-different-scale" title="Permalink"></a></h2><p>But how does a model M calling a hard dependency H provide H&#39;s variables when calling H&#39;s <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function ? The <a href="../../API/API_public/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a> argument the user provides M operates at M&#39;s organ level, so if used to call H&#39;s run! function any required variable for H will be missing.    </p><p>PlantSimEngine provides what are called Status Templates in the simulation graph. Each organ level has its own Status template listing the available variables at that scale. So when a model M calls a hard dependency H&#39;s <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function, any required variables can be accessed through the status template of H&#39;s organ level.</p><h3 id="Back-to-the-XPalm-example"><a class="docs-heading-anchor" href="#Back-to-the-XPalm-example">Back to the XPalm example</a><a id="Back-to-the-XPalm-example-1"></a><a class="docs-heading-anchor-permalink" href="#Back-to-the-XPalm-example" title="Permalink"></a></h3><p>Using the same example in XPalm, the oil palm FSPM: </p><pre><code class="language-julia hljs"># Note that the function&#39;s &#39;status&#39; parameter does NOT contain the variables required by the hard dependencies as the calling model&#39;s organ level is &quot;Phytomer&quot;, not &quot;Male&quot; or &quot;Female&quot;

function PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)
    ...
    status.graph_node_count += 1

    # Create the new organ as a child of the phytomer:
    st_repro_organ = add_organ!(
        status.node[1], # The phytomer&#39;s internode is its first child 
        sim_object,  # The simulation object, so we can add the new status 
        &quot;+&quot;, status.sex, 4;
        index=status.phytomer_count,
        id=status.graph_node_count,
        attributes=Dict{Symbol,Any}()
    )

    # Compute the initiation age of the organ:
    PlantSimEngine.run!(sim_object.models[status.sex].initiation_age, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)
    PlantSimEngine.run!(sim_object.models[status.sex].final_potential_biomass, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)
end</code></pre><p>In the above example the organ and its status template are created on the fly. When that isn&#39;t the case, the status template can be accessed through the simulation graph :</p><pre><code class="language-julia hljs">function PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)

    ...

    if status.sex == &quot;Male&quot;

        status_male = sim_object.statuses[&quot;Male&quot;][1]
        run!(sim_object.models[&quot;Male&quot;].initiation_age, models, status_male, meteo, constants, sim_object)
        run!(sim_object.models[&quot;Male&quot;].final_potential_biomass, models, status_male, meteo, constants, sim_object)
    else
        # Female
        ...
    end
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multiscale_cyclic/">« Handling cyclic dependencies</a><a class="docs-footer-nextpage" href="../multiscale_example_1/">A rudimentary plant simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 22 September 2025 12:36">Monday 22 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
