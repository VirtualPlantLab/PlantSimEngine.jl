<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fixing bugs in the plant simulation · PlantSimEngine.jl</title><meta name="title" content="Fixing bugs in the plant simulation · PlantSimEngine.jl"/><meta property="og:title" content="Fixing bugs in the plant simulation · PlantSimEngine.jl"/><meta property="twitter:title" content="Fixing bugs in the plant simulation · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_3/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_3/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/multiscale/multiscale_example_3/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../../step_by_step/detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../../step_by_step/simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../../step_by_step/model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../step_by_step/quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_process/">Implementing a process</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model/">Implementing a model</a></li><li><a class="tocitem" href="../../step_by_step/parallelization/">Parallelization</a></li><li><a class="tocitem" href="../../step_by_step/advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../../step_by_step/implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox" checked/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../multiscale_example_2/">Expanding the plant simulation</a></li><li class="is-active"><a class="tocitem" href>Fixing bugs in the plant simulation</a><ul class="internal"><li><a class="tocitem" href="#An-organ-creation-problem"><span>An organ creation problem</span></a></li><li><a class="tocitem" href="#A-resource-distribution-bug"><span>A resource distribution bug</span></a></li><li><a class="tocitem" href="#Final-words"><span>Final words</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/API_public/">Public API</a></li><li><a class="tocitem" href="../../API/API_examples/">Example models</a></li><li><a class="tocitem" href="../../API/API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Moving to multiscale</a></li><li><a class="is-disabled">Building a simple plant</a></li><li class="is-active"><a href>Fixing bugs in the plant simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fixing bugs in the plant simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/multiscale/multiscale_example_3.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fixing-bugs-in-the-plant-simulation"><a class="docs-heading-anchor" href="#Fixing-bugs-in-the-plant-simulation">Fixing bugs in the plant simulation</a><a id="Fixing-bugs-in-the-plant-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-bugs-in-the-plant-simulation" title="Permalink"></a></h1><p>There are two major issues hinted at in last chapter&#39;s implementation, which we&#39;ll discuss and resolve here.</p><p>You can find the full script for this simulation in the <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyMultiScalePlantModel/ToyPlantSimulation3.jl">ToyMultiScalePlantModel</a> subfolder of the examples folder.</p><ul><li><a href="#Fixing-bugs-in-the-plant-simulation">Fixing bugs in the plant simulation</a></li><li class="no-marker"><ul><li><a href="#An-organ-creation-problem">An organ creation problem</a></li><li class="no-marker"><ul><li><a href="#Delaying-organ-maturity">Delaying organ maturity</a></li></ul></li><li><a href="#A-resource-distribution-bug">A resource distribution bug</a></li><li class="no-marker"><ul><li><a href="#Fixing-resource-computation:-a-root-growth-decision-model">Fixing resource computation: a root growth decision model</a></li><li><a href="#Internode-emission-adjustments">Internode emission adjustments</a></li><li><a href="#A-multi-scale-hard-dependency-appears">A multi-scale hard dependency appears</a></li><li><a href="#Root-growth-decision-model-implementation">Root growth decision model implementation</a></li><li><a href="#Root-growth">Root growth</a></li><li><a href="#Mapping-adjustments">Mapping adjustments</a></li><li><a href="#Breaking-the-dependency-cycle">Breaking the dependency cycle</a></li><li><a href="#Updated-mapping">Updated mapping</a></li></ul></li><li><a href="#Final-words">Final words</a></li></ul></li></ul><h2 id="An-organ-creation-problem"><a class="docs-heading-anchor" href="#An-organ-creation-problem">An organ creation problem</a><a id="An-organ-creation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#An-organ-creation-problem" title="Permalink"></a></h2><p>There is one quirk you may have noticed when inspecting the data : when a root expands, the new root is immediately active, and some models may act on it immediately... including the root growth model. Meaning this new root may also sprout another root in the same timestep, and so on.</p><p>You can notice this by looking at the simulation&#39;s state during the first two timesteps:</p><pre><code class="language-julia hljs">outs = run!(mtg, mapping, first(meteo_day, 2))

root_nodes_per_timestep = [0, 0]
for i in 1:length(outs[&quot;Root&quot;])
    if outs[&quot;Root&quot;][i].timestep &lt; 3
        root_nodes_per_timestep[outs[&quot;Root&quot;][i].timestep] += 1
    end
end

root_nodes_per_timestep</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
  1
 10</code></pre><p>Our root grew to full length within one timestep. Oops.</p><p>This is an implementation decision in PlantSimEngine. <strong>By default, newly created organs are active</strong>, and models can affect them <strong>as soon as they are created</strong>.</p><p>In our case, internode growth depends on a threshold thermal time value, which accumulates over several timesteps, so even though new internodes are immediately active, they can&#39;t themselves grow new organs within the same timestep. But as we&#39;ve just showcased, we have a root problem.</p><p>This quirk is also handled in <a href="https://github.com/PalmStudio/XPalm.jl">XPalm.jl</a>, a package using PlantSimEngine: some organs make use of state machines, and are considered &quot;immature&quot; when they are created. Immature organs cannot grow new organs until some conditions are met for their state to change. There are also other conditions governing organ emergence, such as specific threshold values relating to Thermal Time (see <a href="https://github.com/PalmStudio/XPalm.jl/blob/433e1c47c743e7a53e764672818a43ed8feb10c6/src/plant/phytomer/leaves/phyllochron.jl#L46">here</a> for an example).</p><div class="admonition is-info" id="Note-c492cb1250c1a455"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c492cb1250c1a455" title="Permalink"></a></header><div class="admonition-body"><p>This implementation decision for new organs to be immediately active may be subject to change in future versions of PlantSimEngine. Also note that the way the dependency graph is structured determines the order in which models run. Meaning that which models are run before or after organ creation might change with new additions and updates to your mapping. Some models might run &quot;one timestep later&quot;, see <a href="../../troubleshooting_and_testing/implicit_contracts/#Simulation-order-instability-when-adding-models">Simulation order instability when adding models</a> for more details.</p></div></div><div class="admonition is-info" id="Note-d3be58a570f377d5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d3be58a570f377d5" title="Permalink"></a></header><div class="admonition-body"><p>MTG node output data has a couple of subtleties, see <a href="../multiscale_considerations/#Multi-scale-output-data-structure">Multi-scale output data structure</a> for more details</p></div></div><h3 id="Delaying-organ-maturity"><a class="docs-heading-anchor" href="#Delaying-organ-maturity">Delaying organ maturity</a><a id="Delaying-organ-maturity-1"></a><a class="docs-heading-anchor-permalink" href="#Delaying-organ-maturity" title="Permalink"></a></h3><p>How do we avoid this extreme instant growth ? We can, of course, add some thermal time constraint. We could arbitrarily tinker with water resources. </p><p>We can otherwise add a simple state machine variable to our root and internodes in the MTG, indicating a newly added organ is immature and cannot grow on the same timestep. Since our root doesn&#39;t branch, we can simply keep track of a single state variable. See the <a href="../../prerequisites/key_concepts/#State-machines">State machines</a> section for some examples.</p><p>In fact, we could change the scale at which the check is made to extend the root, and have another model call this one directly. This enables running this model only for the end root when those occasional timesteps when root growth is possible, instead of at every timestep for every root node.</p><h2 id="A-resource-distribution-bug"><a class="docs-heading-anchor" href="#A-resource-distribution-bug">A resource distribution bug</a><a id="A-resource-distribution-bug-1"></a><a class="docs-heading-anchor-permalink" href="#A-resource-distribution-bug" title="Permalink"></a></h2><p>Another problem you may have noticed, is that the water and carbon stock are computed by aggregating photosynthesis over leaves and absorption over roots... But they aren&#39;t always properly decremented when consumed !</p><p>If the end root grows, it outputs a <code>carbon_root_creation_consumed</code> value, but under certain conditions, we might also create other roots and internodes even when there shouldn&#39;t be enough carbon left for them. </p><p>Indeed, if both the root and leaf water thresholds are met, and there is enough carbon for a single root or internode but not for both, and the root model runs before the internode model, both will use the carbon_stock variable prior to organ emission. The internode emission model won&#39;t account for the root carbon consumption.</p><p>This occurs because <code>carbon_stock</code> is only computed once, and won&#39;t update until the next timestep.</p><h3 id="Fixing-resource-computation:-a-root-growth-decision-model"><a class="docs-heading-anchor" href="#Fixing-resource-computation:-a-root-growth-decision-model">Fixing resource computation: a root growth decision model</a><a id="Fixing-resource-computation:-a-root-growth-decision-model-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-resource-computation:-a-root-growth-decision-model" title="Permalink"></a></h3><p>To avoid that problem in our specific case, we can couple the root growth model and the internode emission model, and pass the <code>carbon_root_creation_consumed</code> variable to the internode emission model so that it can use an updated carbon stock. Or we could have an intermediate model recompute the new stock to pass along to the internode emission model. </p><p>There is a section in the [Tips and workarounds] page discussing this situation and other potential solutions: <a href="../../troubleshooting_and_testing/tips_and_workarounds/#Having-a-variable-simultaneously-as-input-and-output-of-a-model">Having a variable simultaneously as input and output of a model</a>.</p><p>We&#39;ll go for the first option and couple the root growth and internode emission model.</p><h3 id="Internode-emission-adjustments"><a class="docs-heading-anchor" href="#Internode-emission-adjustments">Internode emission adjustments</a><a id="Internode-emission-adjustments-1"></a><a class="docs-heading-anchor-permalink" href="#Internode-emission-adjustments" title="Permalink"></a></h3><p>The only change required for our internode emission model is to take into account <code>carbon_root_creation_consumed</code> as a new input, map that variable from the &quot;Root&quot; scale in our mapping, and compute the adjusted carbon stock. Here&#39;s the relevant excerpt in the <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function.</p><pre><code class="language-julia hljs"> # take into account that the stock may already be depleted 
    carbon_stock_updated_after_roots = status.carbon_stock - status.carbon_root_creation_consumed

    # if not enough carbon, no organ creation
    if carbon_stock_updated_after_roots &lt; m.carbon_internode_creation_cost
        return nothing
    end</code></pre><h3 id="A-multi-scale-hard-dependency-appears"><a class="docs-heading-anchor" href="#A-multi-scale-hard-dependency-appears">A multi-scale hard dependency appears</a><a id="A-multi-scale-hard-dependency-appears-1"></a><a class="docs-heading-anchor-permalink" href="#A-multi-scale-hard-dependency-appears" title="Permalink"></a></h3><p>Our root growth decision model inherits some of the responsibility from last chapter&#39;s root growth model, so inputs, parameters and condition checks will be similar. We&#39;ll let the root growth model keep the length check and only focus on resources.</p><p>Since the decision model is now directly responsible for calling the actual root growth model, we need to declare that it requires a root growth model as a hard dependency and cannot be run standalone. </p><p>This hard dependency is in fact multiscale, since both models operate at different scales, &quot;Plant&quot; and &quot;Root&quot;. You can read more about multi-scale hard dependencies in the <a href="../multiscale_coupling/#Handling-dependencies-in-a-multiscale-context">Handling dependencies in a multiscale context</a> page.</p><p>Compared to the single-scale equivalent, the multi-scale declaration additionally requires mapping the scale:</p><pre><code class="language-julia hljs">PlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=&gt;[&quot;Root&quot;],)</code></pre><p>The <code>status</code> argument <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function of the root growth decision model only contains variables from the &quot;Plant&quot; scale, or explicitely mapped to this scale, which isn&#39;t the case for the root growth&#39;s variables. To make use of the root growth model&#39;s variables, we need to recover the <a href="../../API/API_public/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a> at the &quot;Root&quot; scale. It is accessible from the <code>extra</code> argument in <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a>&#39;s signature. </p><p>In multi-scale simulations, this <code>extra</code> argument implicitely contains an object storing the simulation state. It contains the statuses at various scales, and all the models indexed per scale and process name.</p><p>Access to the &quot;Root&quot; status within the root growth decision model <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function is done like so:</p><pre><code class="language-julia hljs">status_Root= extra_args.statuses[&quot;Root&quot;][1]</code></pre><p>It is then possible to call the root growth model from the parent&#39;s <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function:</p><pre><code class="language-julia hljs">PlantSimEngine.run!(extra.models[&quot;Root&quot;].root_growth, models, status_Root, meteo, constants, extra)</code></pre><p>Which will enable writing the rest of the <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function.</p><h3 id="Root-growth-decision-model-implementation"><a class="docs-heading-anchor" href="#Root-growth-decision-model-implementation">Root growth decision model implementation</a><a id="Root-growth-decision-model-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Root-growth-decision-model-implementation" title="Permalink"></a></h3><p>With that new coupling consideration properly handled, we can complete the full model implementation:</p><pre><code class="language-julia hljs">PlantSimEngine.@process &quot;root_growth_decision&quot; verbose = false

struct ToyRootGrowthDecisionModel{T} &lt;: AbstractRoot_Growth_DecisionModel
    water_threshold::T
    carbon_root_creation_cost::T
end

PlantSimEngine.inputs_(::ToyRootGrowthDecisionModel) = 
(water_stock=0.0,carbon_stock=0.0)

PlantSimEngine.outputs_(::ToyRootGrowthDecisionModel) = NamedTuple()

PlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=&gt;[&quot;Root&quot;],)

# &quot;status&quot; is at the &quot;Plant&quot; scale
function PlantSimEngine.run!(m::ToyRootGrowthDecisionModel, models, status, meteo, constants=nothing, extra=nothing)

    if status.water_stock &lt; m.water_threshold &amp;&amp; status.carbon_stock &gt; m.carbon_root_creation_cost
        # Obtain &quot;status&quot; at &quot;Root&quot; scale
        status_Root= extra_args.statuses[&quot;Root&quot;][1]
        # Call the hard dependency model directly with its status
        PlantSimEngine.run!(extra.models[&quot;Root&quot;].root_growth, models, status_Root, meteo, constants, extra)
    end
end</code></pre><p>The root growth model will output the <code>carbon_root_creation_consumed</code> computation, but it&#39;ll still be exposed to downstream models despite the root growth model being a &#39;hidden&#39; model in the dependency graph due to its hard dependency nature.</p><p>With this new coupling, we will only be creating at most a single new root per timestep, as the root growth decision will only be called once per timestep. </p><h3 id="Root-growth"><a class="docs-heading-anchor" href="#Root-growth">Root growth</a><a id="Root-growth-1"></a><a class="docs-heading-anchor-permalink" href="#Root-growth" title="Permalink"></a></h3><p>This iteration turns into a simplifed version of last chapter&#39;s.</p><pre><code class="language-julia hljs">PlantSimEngine.@process &quot;root_growth&quot; verbose = false

struct ToyRootGrowthModel &lt;: AbstractRoot_GrowthModel
    root_max_len::Int
end

PlantSimEngine.inputs_(::ToyRootGrowthModel) = NamedTuple()
PlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)

function PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)    
    status.carbon_root_creation_consumed = 0.0

    root_end = get_root_end_node(status.node)
        
    if length(root_end) != 1 
        throw(AssertionError(&quot;Couldn&#39;t find MTG leaf node with symbol \&quot;Root\&quot;&quot;))
    end
    
    root_len = get_roots_count(root_end[1])
    if root_len &lt; m.root_max_len
        st = add_organ!(root_end[1], extra, &quot;&lt;&quot;, &quot;Root&quot;, 2, index=1)
        status.carbon_root_creation_consumed = m.carbon_root_creation_cost
    end
end</code></pre><h3 id="Mapping-adjustments"><a class="docs-heading-anchor" href="#Mapping-adjustments">Mapping adjustments</a><a id="Mapping-adjustments-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-adjustments" title="Permalink"></a></h3><p>The new mapping only has straightforward changes. Some models cease to be multi-scale, others require new variables to be mapped for them. <code>carbon_root_creation_consumed</code> ceases to be a vector mapping and is a scalar variable.</p><pre><code class="language-julia hljs">mapping = Dict(
&quot;Scene&quot; =&gt; ToyDegreeDaysCumulModel(),
&quot;Plant&quot; =&gt; (
    MultiScaleModel(
        model=ToyStockComputationModel(),          
        mapped_variables=[
            :carbon_captured=&gt;[&quot;Leaf&quot;],
            :water_absorbed=&gt;[&quot;Root&quot;],
            :carbon_root_creation_consumed=&gt;&quot;Root&quot;,
            :carbon_organ_creation_consumed=&gt;[&quot;Internode&quot;]

        ],
        ),
    MultiScaleModel(
        model=ToyRootGrowthDecisionModel(10.0, 50.0),
    ),
        Status(water_stock = 0.0, carbon_stock = 0.0)
    ),
&quot;Internode&quot; =&gt; (        
        MultiScaleModel(
            model=ToyCustomInternodeEmergence(),#TT_emergence=20.0),
            mapped_variables=[:TT_cu =&gt; &quot;Scene&quot;,
            :water_stock=&gt;&quot;Plant&quot;,
            :carbon_stock=&gt;&quot;Plant&quot;, 
            :carbon_root_creation_consumed=&gt;&quot;Root&quot;],
        ),        
        Status(carbon_organ_creation_consumed=0.0),
    ),
&quot;Root&quot; =&gt;   (ToyRootGrowthModel(10),       
            ToyWaterAbsorptionModel(),
            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),
            ),
&quot;Leaf&quot; =&gt; ( ToyLeafCarbonCaptureModel(),),
)</code></pre><p>We can now run our simulation as we did previously... or can we ?</p><pre><code class="language-julia hljs">ERROR: Cyclic dependency detected for process resource_stock_computation: resource_stock_computation for organ Plant depends on root_growth from organ Root, which depends on the first one. This is not allowed, you may need to develop a new process that does the whole computation by itself.</code></pre><p>Ah, it looks like our additional usage of the root carbon cost creates a cyclic dependency. </p><h3 id="Breaking-the-dependency-cycle"><a class="docs-heading-anchor" href="#Breaking-the-dependency-cycle">Breaking the dependency cycle</a><a id="Breaking-the-dependency-cycle-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-dependency-cycle" title="Permalink"></a></h3><p>Fortunately, the logic here is quite straightforward. We can&#39;t be computing our current timestep&#39;s resource stock with <code>carbon_root_creation_consumed</code>, and then updating it right after root creation again using a new value of <code>carbon_root_creation_consumed</code>.</p><p>The solution is hopefully quite intuitive : when we compute resource stocks, we should be computing it using the previous timestep&#39;s values. Then root creation happens (or doesn&#39;t), and the computed <code>carbon_root_creation_consumed</code> corresponds to the current timestep value. We could also do the same for water to be consistent.</p><h3 id="Updated-mapping"><a class="docs-heading-anchor" href="#Updated-mapping">Updated mapping</a><a id="Updated-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Updated-mapping" title="Permalink"></a></h3><p>The relevant part of the mapping that needs to be updated is the following:</p><pre><code class="language-julia hljs">mapping = Dict(
...
&quot;Plant&quot; =&gt; (
    MultiScaleModel(
        model=ToyStockComputationModel(),          
        mapped_variables=[
            :carbon_captured=&gt;[&quot;Leaf&quot;],
            :water_absorbed=&gt;[&quot;Root&quot;],
            PreviousTimeStep(:carbon_root_creation_consumed)=&gt;&quot;Root&quot;,
            PreviousTimeStep(:carbon_organ_creation_consumed)=&gt;[&quot;Internode&quot;],
        ],
        ),
        ToyRootGrowthDecisionModel(10.0, 50.0),
        Status(water_stock = 0.0, carbon_stock = 0.0)
    ),
...
)</code></pre><h2 id="Final-words"><a class="docs-heading-anchor" href="#Final-words">Final words</a><a id="Final-words-1"></a><a class="docs-heading-anchor-permalink" href="#Final-words" title="Permalink"></a></h2><p>And you&#39;re now ready to run the simulation.</p><p>The full script can be found <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyMultiScalePlantModel/ToyPlantSimulation3.jl">here</a>, in the ToyMultiScalePlantModel subfolder of the examples folder.</p><p>We now have a plant with two different growth directions. Roots are added at the beginning, until water is considered abundant enough.</p><p>Of course, there are still several design issues with this implementation. It is as utterly unrealistic as the previous one, and doesn&#39;t even consume water. Some condition checking is a little ad hoc and could be made more robust. More sanity checks could be added, and the model and variable names could definitely be made more clear.</p><p>But once again, this example is only made to illustrate what is possible with this framework, and doesn&#39;t strive for ecophysiological consistency. And the approach can be made increasingly more complex by refining models and simulation parameters, and feeding in new information about your plant, and ramp up to realistic, production-ready and predictive simulations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multiscale_example_2/">« Expanding the plant simulation</a><a class="docs-footer-nextpage" href="../multiscale_example_4/">Visualizing our toy plant with PlantGeom »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 8 August 2025 15:04">Friday 8 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
