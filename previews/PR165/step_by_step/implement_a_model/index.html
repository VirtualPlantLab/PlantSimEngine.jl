<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing a model · PlantSimEngine.jl</title><meta name="title" content="Implementing a model · PlantSimEngine.jl"/><meta property="og:title" content="Implementing a model · PlantSimEngine.jl"/><meta property="twitter:title" content="Implementing a model · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/step_by_step/implement_a_model/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/step_by_step/implement_a_model/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/step_by_step/implement_a_model/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/why_plantsimengine/">Why PlantSimEngine ?</a></li><li><a class="tocitem" href="../../introduction/why_julia/">Why Julia ?</a></li></ul></li><li><span class="tocitem">Prerequisites</span><ul><li><a class="tocitem" href="../../prerequisites/installing_plantsimengine/">Installing and running PlantSimEngine</a></li><li><a class="tocitem" href="../../prerequisites/key_concepts/">Key Concepts</a></li><li><a class="tocitem" href="../../prerequisites/julia_basics/">Julia language basics</a></li></ul></li><li><span class="tocitem">Step by step - Single-scale simulations</span><ul><li><a class="tocitem" href="../detailed_first_example/">Detailed first simulation</a></li><li><a class="tocitem" href="../simple_model_coupling/">Coupling</a></li><li><a class="tocitem" href="../model_switching/">Model Switching</a></li><li><a class="tocitem" href="../quick_and_dirty_examples/">Quick examples</a></li><li><a class="tocitem" href="../implement_a_process/">Implementing a process</a></li><li class="is-active"><a class="tocitem" href>Implementing a model</a><ul class="internal"><li><a class="tocitem" href="#Quick-version"><span>Quick version</span></a></li><li><a class="tocitem" href="#Detailed-version"><span>Detailed version</span></a></li><li><a class="tocitem" href="#Other-examples"><span>Other examples</span></a></li><li><a class="tocitem" href="#Requirements"><span>Requirements</span></a></li><li><a class="tocitem" href="#Example:-the-Beer-Lambert-model"><span>Example: the Beer-Lambert model</span></a></li></ul></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li><li><a class="tocitem" href="../advanced_coupling/">Advanced coupling and hard dependencies</a></li><li><a class="tocitem" href="../implement_a_model_additional/">Implementing a model : additional notes</a></li></ul></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><span class="tocitem">Working with data</span><ul><li><a class="tocitem" href="../../working_with_data/reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../working_with_data/fitting/">Fitting</a></li><li><a class="tocitem" href="../../working_with_data/inputs/">Input types</a></li><li><a class="tocitem" href="../../working_with_data/visualising_outputs/">Visualizing outputs and data</a></li><li><a class="tocitem" href="../../working_with_data/floating_point_accumulation_error/">Floating-point considerations</a></li></ul></li><li><span class="tocitem">Moving to multiscale</span><ul><li><a class="tocitem" href="../../multiscale/multiscale_considerations/">Multiscale considerations</a></li><li><a class="tocitem" href="../../multiscale/single_to_multiscale/">Converting a simulation to multi-scale</a></li><li><a class="tocitem" href="../../multiscale/multiscale/">More variable mapping examples</a></li><li><a class="tocitem" href="../../multiscale/multiscale_cyclic/">Handling cyclic dependencies</a></li><li><a class="tocitem" href="../../multiscale/multiscale_coupling/">Multiscale coupling considerations</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Building a simple plant</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../multiscale/multiscale_example_1/">A rudimentary plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_2/">Expanding the plant simulation</a></li><li><a class="tocitem" href="../../multiscale/multiscale_example_3/">Fixing bugs in the plant simulation</a></li></ul></li><li><a class="tocitem" href="../../multiscale/multiscale_example_4/">Visualizing our toy plant with PlantGeom</a></li></ul></li><li><span class="tocitem">Troubleshooting and testing</span><ul><li><a class="tocitem" href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/downstream_tests/">Automated testing</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/tips_and_workarounds/">Tips and Workarounds</a></li><li><a class="tocitem" href="../../troubleshooting_and_testing/implicit_contracts/">Implicit contracts</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/API_public/">Public API</a></li><li><a class="tocitem" href="../../API/API_examples/">Example models</a></li><li><a class="tocitem" href="../../API/API_private/">Internal API</a></li></ul></li><li><a class="tocitem" href="../../documentation_improvement/">Improving our documentation</a></li><li><a class="tocitem" href="../../developers/">Developer guidelines</a></li><li><a class="tocitem" href="../../planned_features/">Planned features</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Step by step - Single-scale simulations</a></li><li class="is-active"><a href>Implementing a model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementing a model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/step_by_step/implement_a_model.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="model_implementation_page"><a class="docs-heading-anchor" href="#model_implementation_page">Implementing a model</a><a id="model_implementation_page-1"></a><a class="docs-heading-anchor-permalink" href="#model_implementation_page" title="Permalink"></a></h1><p>For your own simulations, you might want to move beyond simple usage at some point and implement your own models. In this page, we&#39;ll go through the required steps for writing a new model. The detailed version is tailored for people less familiar with programming.</p><h2 id="Quick-version"><a class="docs-heading-anchor" href="#Quick-version">Quick version</a><a id="Quick-version-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-version" title="Permalink"></a></h2><p>Declare a new process : </p><pre><code class="language-julia hljs">@process &quot;light_interception&quot; verbose = false</code></pre><p>Declare your model struct, and its parameters : </p><pre><code class="language-julia hljs">struct Beer{T} &lt;: AbstractLight_InterceptionModel
    k::T
end</code></pre><p>Declare the <code>inputs_</code> and <code>outputs_</code> methods for that model (note the &#39;_&#39;, these methods are distinct from <code>inputs</code> and <code>outputs</code>)</p><pre><code class="language-julia hljs">function PlantSimEngine.inputs_(::Beer)
    (LAI=-Inf,)
end

function PlantSimEngine.outputs_(::Beer)
    (aPPFD=-Inf,)
end</code></pre><p>Write the <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function that operates on a single timestep : </p><pre><code class="language-julia hljs">function run!(::Beer, models, status, meteo, constants, extras)
    status.PPFD =
        meteo.Ri_PAR_f *
        exp(-models.light_interception.k * status.LAI) *
        constants.J_to_umol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">run! (generic function with 1 method)</code></pre><p>Determine if parallelization is possible, and which traits to declare :</p><pre><code class="language-julia hljs">PlantSimEngine.ObjectDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsObjectIndependent()
PlantSimEngine.TimeStepDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsTimeStepIndependent()</code></pre><p>And that is all you need to get going, for this example with a single parameter and no interdependencies. </p><p>The <a href="../../API/API_public/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>@process</code></a> macro does some boilerplate work described <a href="../implement_a_process/#under_the_hood">here</a></p><p>Some extra utility functions can also be interesting to implement to make users&#39; lives simpler. See the <a href="../implement_a_model_additional/#Model-implementation-additional-notes">Model implementation additional notes</a> page for details. If your custom model needs to handle more complex couplings than the simple input/output described in this example, check out the <a href="../advanced_coupling/#Coupling-more-complex-models">Coupling more complex models</a> page.</p><h2 id="Detailed-version"><a class="docs-heading-anchor" href="#Detailed-version">Detailed version</a><a id="Detailed-version-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-version" title="Permalink"></a></h2><p><code>PlantSimEngine.jl</code> was designed to make new model implementation very simple. So let&#39;s learn about how to implement your own model with a simple example: implementing a new light interception model.</p><p>The model we&#39;ll (re)implement is available as an example model from the <code>Examples</code> sub-module. You can access the script from here: <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/Beer.jl"><code>examples/Beer.jl</code></a>. It is also available in the <code>PlantBioPhysics.jl</code> package.</p><p>You can import the model and PlantSimEngine&#39;s other example models into your environment with <code>using</code>:</p><pre><code class="language-julia hljs"># Import the example models defined in the `Examples` sub-module:
using PlantSimEngine.Examples</code></pre><h2 id="Other-examples"><a class="docs-heading-anchor" href="#Other-examples">Other examples</a><a id="Other-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Other-examples" title="Permalink"></a></h2><p><code>PlantSimEngine</code>&#39;s other toy models can be found in the <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples">examples</a> folder.</p><p>For other examples, you can look at the code in <a href="https://github.com/VEZY/PlantBiophysics.jl"><code>PlantBiophysics.jl</code></a>, where you will find <em>e.g.</em> a photosynthesis model, with the implementation of the <code>FvCB</code> model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/photosynthesis/FvCB.jl">src/photosynthesis/FvCB.jl</a>; an energy balance model with the implementation of the <code>Monteith</code> model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">src/energy/Monteith.jl</a>; or a stomatal conductance model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/conductances/stomatal/medlyn.jl">src/conductances/stomatal/medlyn.jl</a>.</p><h2 id="Requirements"><a class="docs-heading-anchor" href="#Requirements">Requirements</a><a id="Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements" title="Permalink"></a></h2><p>If you have a look at example models, you&#39;ll see that in order to implement a new model you&#39;ll need to implement:</p><ul><li>a structure, used to hold the parameter values and to dispatch to the right method</li><li>the actual model, developed as a method for the process it simulates</li><li>some helper functions used by the package and/or the users</li></ul><h2 id="Example:-the-Beer-Lambert-model"><a class="docs-heading-anchor" href="#Example:-the-Beer-Lambert-model">Example: the Beer-Lambert model</a><a id="Example:-the-Beer-Lambert-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-Beer-Lambert-model" title="Permalink"></a></h2><h3 id="The-process"><a class="docs-heading-anchor" href="#The-process">The process</a><a id="The-process-1"></a><a class="docs-heading-anchor-permalink" href="#The-process" title="Permalink"></a></h3><p>We start by declaring the light interception process at l.7 using <a href="../../API/API_public/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>@process</code></a>: </p><pre><code class="language-julia hljs">@process &quot;light_interception&quot; verbose = false</code></pre><p>See <a href="../implement_a_process/#Implementing-a-new-process">Implementing a new process</a> for more details on how that works and how to use the process.</p><h3 id="The-structure"><a class="docs-heading-anchor" href="#The-structure">The structure</a><a id="The-structure-1"></a><a class="docs-heading-anchor-permalink" href="#The-structure" title="Permalink"></a></h3><p>To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:</p><ul><li>hold the parameter values</li><li>dispatch to the right <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> method when calling it</li></ul><p>The structure of the model (or type) is defined as follows:</p><pre><code class="language-julia hljs">struct Beer{T} &lt;: AbstractLight_InterceptionModel
    k::T
end</code></pre><p>The first line defines the name of the model (<code>Beer</code>). It is good practice to use camel case for the name, <em>i.e.</em> using capital letters for the words and no separator <code>LikeThis</code>. </p><p>The <code>Beer</code> structure is defined as a subtype of <code>AbstractLight_InterceptionModel</code> indicating what kind of process the model simulates. The <code>AbstractLight_InterceptionModel</code> type is automatically created when defining the process &quot;light_interception&quot;.</p><p>We can therefore infer from the declaration that <code>Beer</code> is a model to simulate the light interception process.</p><p>Then come the parameters names, and their types. </p><h3 id="User-types-and-parametric-types"><a class="docs-heading-anchor" href="#User-types-and-parametric-types">User types and parametric types</a><a id="User-types-and-parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#User-types-and-parametric-types" title="Permalink"></a></h3><p>There is a little Julia specificity here, to enable the user to pass their own types to the simulation.</p><ul><li><code>Beer</code> is a parameterized <code>struct</code>, indicated by the <code>{T}</code> annotation</li><li>We indicate the <code>k</code> parameter is of type <code>T</code> by adding <code>::T</code> after the name.</li></ul><p>The <code>T</code> is an arbitrary letter here. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, <em>e.g.</em>:</p><pre><code class="language-julia hljs">struct CustomModel{T,S} &lt;: AbstractLight_InterceptionModel
    k::T
    x::T
    y::T
    z::S
end</code></pre><p>Parameterized types are practical because they let the user choose the type of the parameters, and potentially change them at runtime. For example a user could use the <code>Particles</code> type from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> for automatic uncertainty propagation throughout the simulation. We refer you to the <a href="../implement_a_model_additional/#Parametric-types">Parametric types</a> subsection of the <a href="../implement_a_model_additional/#Model-implementation-additional-notes">Model implementation additional notes</a> page for more information on parametric types.</p><h3 id="Inputs-and-outputs"><a class="docs-heading-anchor" href="#Inputs-and-outputs">Inputs and outputs</a><a id="Inputs-and-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Inputs-and-outputs" title="Permalink"></a></h3><p>When implementing a new model, it is necessary to declare what variables will be required, whether provided as an input to our model or computed for every timestep as an output. Input variables will either be initialized by the user in a <code>Status</code> object, or provided by another model. Output variables may be global simulation outputs and/or used by other models.</p><p>In our case, the <code>Beer</code> model, computing light interception, has one input variable and one output variable:</p><ul><li>Inputs: <code>:LAI</code>, the leaf area index (m² m⁻²)</li><li>Outputs: <code>:aPPFD</code>, the photosynthetic photon flux density (μmol m⁻² s⁻¹)</li></ul><p>We declare these inputs/outputs by adding a method for the <a href="../../API/API_public/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="../../API/API_public/#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> functions. These functions take the type of the model as argument, and return a <code>NamedTuple</code> with the names of the variables as keys, and their default values as values:</p><pre><code class="language-julia hljs">function PlantSimEngine.inputs_(::Beer)
    (LAI=-Inf,)
end

function PlantSimEngine.outputs_(::Beer)
    (aPPFD=-Inf,)
end</code></pre><p>These functions are internal, and end with an &quot;_&quot;. Users instead use <a href="../../API/API_public/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="../../API/API_public/#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> to query model variables.</p><h3 id="The-run!-method"><a class="docs-heading-anchor" href="#The-run!-method">The run! method</a><a id="The-run!-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-run!-method" title="Permalink"></a></h3><p>When running a simulation with <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a>, each model is run in turn at every timestep, following whatever order was deduced from the ModelList definition and Status. Each model also has its <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> method for that purpose that update the simulation&#39;s current state, with a slightly different signature. The function takes six arguments:</p><pre><code class="language-julia hljs">function run!(::Beer, models, status, meteo, constants, extras)</code></pre><ul><li>the model&#39;s type</li><li>models: a <a href="../simple_model_coupling/#ModelList"><code>ModelList</code></a> object, which contains all the models of the simulation</li><li>status: a <a href="../../API/API_public/#PlantSimEngine.Status"><code>Status</code></a> object, which contains the current values (<em>i.e.</em> state) of the variables for <strong>one</strong> time-step (e.g. the value of the plant LAI at time t)</li><li>meteo: (usually) an <code>Atmosphere</code> object, or a row of the meteorological data, which contains the current values of the meteorological variables for <strong>one</strong> time-step (<em>e.g.</em> the value of the PAR at time t)</li><li>constants: a <code>Constants</code> object, or a <code>NamedTuple</code>, which contains the values of the constants for the simulation (<em>e.g.</em> the value of the Stefan-Boltzmann constant, unit-conversion constants...)</li><li>extras: any other object you want to pass to your model, mostly for advanced usage, not detailed here</li></ul><p>A typical <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> function can therefore make use of simulation constants, input/output variables accessible through the [<code>Status</code>](@ref object, or weather data. </p><p>Here is the <a href="../../API/API_public/#PlantSimEngine.run!"><code>run!</code></a> implementation of the light interception for a <a href="../simple_model_coupling/#ModelList"><code>ModelList</code></a> component models. Note that the input and output variable are accessed through the <a href="../../API/API_public/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a> argument :</p><pre><code class="language-julia hljs">function run!(::Beer, models, status, meteo, constants, extras)
    status.PPFD =
        meteo.Ri_PAR_f *
        exp(-models.light_interception.k * status.LAI) *
        constants.J_to_umol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">run! (generic function with 1 method)</code></pre><h3 id="Additional-notes"><a class="docs-heading-anchor" href="#Additional-notes">Additional notes</a><a id="Additional-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-notes" title="Permalink"></a></h3><p>To use this model, users will have to make sure that the variables for that model are defined in the <a href="../../API/API_public/#PlantSimEngine.Status"><code>Status</code></a> object, the meteorology, and the <code>Constants</code> object.</p><p>!!! Note     <a href="../../API/API_public/#PlantSimEngine.Status"><code>Status</code></a> objects contain the current state of the simulation. It is not, by default, possible to make use of earlier variable states, unless a custom model is written for that purpose.</p><p>Model parameters are available from the <a href="../simple_model_coupling/#ModelList"><code>ModelList</code></a> that is passed via the <code>models</code> argument. Index by the process name, then the parameter name. For example, the <code>k</code> parameter of the <code>Beer</code> model is found in <code>models.light_interception.k</code>.</p><div class="admonition is-warning" id="Warning-869ee7cfc9f2dfc7"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-869ee7cfc9f2dfc7" title="Permalink"></a></header><div class="admonition-body"><p>You need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before <em>e.g.</em>: <code>import PlantSimEngine: inputs_, outputs_</code>. The troubleshooting subsection <a href="../../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting/#Implementing-a-model:-forgetting-to-import-or-prefix-functions">Implementing a model: forgetting to import or prefix functions</a> showcases output errors that can occur when you forget to prefix.</p></div></div><h3 id="Parallelization-traits"><a class="docs-heading-anchor" href="#Parallelization-traits">Parallelization traits</a><a id="Parallelization-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization-traits" title="Permalink"></a></h3><p><code>PlantSimEngine</code> defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (<em>i.e.</em> objects) and/or time (<em>i.e.</em> time-steps).</p><p>By default, all models are assumed to be <strong>not</strong> parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.</p><p>For example, if we want to add the trait for parallelization over objects to our <code>Beer</code> model, we would do:</p><pre><code class="language-julia hljs">PlantSimEngine.ObjectDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsObjectIndependent()</code></pre><p>And if we want to add the trait for parallelization over time-steps to our <code>Beer</code> model, we would do:</p><pre><code class="language-julia hljs">PlantSimEngine.TimeStepDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsTimeStepIndependent()</code></pre><div class="admonition is-info" id="Note-118862c339833fe1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-118862c339833fe1" title="Permalink"></a></header><div class="admonition-body"><p>A model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.</p></div></div><p>OK that&#39;s it! We now a full new model implementation for the light interception process! Other models might be more complex in terms of what computations they do, or how they couple with other models, but the approach remains the same.</p><h3 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h3><p>If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.</p><p>To do so, we can add a method to the <a href="../../API/API_public/#PlantSimEngine.dep"><code>dep</code></a> function that tells PlantSimEngine which processes (and models) are needed for the model to run.</p><p>Our example model does not call another model, so we don&#39;t need to implement it. But we can look at <em>e.g.</em> the implementation for <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/d1d5addccbab45688a6c3797e650a640209b8359/src/processes/photosynthesis/FvCB.jl#L83"><code>Fvcb</code></a> in <code>PlantBiophysics.jl</code> to see how it works:</p><pre><code class="language-julia hljs">PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)</code></pre><p>Here we say to PlantSimEngine that the <code>Fvcb</code> model needs a model of type <code>AbstractStomatal_ConductanceModel</code> in the stomatal conductance process.</p><p>You can read more about hard dependencies in <a href="../advanced_coupling/#Coupling-more-complex-models">Coupling more complex models</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implement_a_process/">« Implementing a process</a><a class="docs-footer-nextpage" href="../parallelization/">Parallelization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 28 October 2025 14:29">Tuesday 28 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
