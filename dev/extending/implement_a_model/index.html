<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · PlantSimEngine.jl</title><meta name="title" content="Models · PlantSimEngine.jl"/><meta property="og:title" content="Models · PlantSimEngine.jl"/><meta property="twitter:title" content="Models · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/extending/implement_a_model/"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/extending/implement_a_model/"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/extending/implement_a_model/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../design/">Design</a></li><li><a class="tocitem" href="../../model_switching/">Model Switching</a></li><li><a class="tocitem" href="../../reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../../model_execution/">Execution</a></li><li><a class="tocitem" href="../../fitting/">Fitting</a></li><li><span class="tocitem">Extending</span><ul><li><a class="tocitem" href="../implement_a_process/">Processes</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Inspiration"><span>Inspiration</span></a></li><li><a class="tocitem" href="#Requirements"><span>Requirements</span></a></li><li><a class="tocitem" href="#Example:-the-Beer-Lambert-model"><span>Example: the Beer-Lambert model</span></a></li></ul></li><li><a class="tocitem" href="../inputs/">Input types</a></li></ul></li><li><span class="tocitem">Coupling</span><ul><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Users</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_coupling/model_coupling_user/">Simple case</a></li><li><a class="tocitem" href="../../model_coupling/multiscale/">Multi-scale modelling</a></li></ul></li><li><a class="tocitem" href="../../model_coupling/model_coupling_modeler/">Modelers</a></li></ul></li><li><span class="tocitem">FAQ</span><ul><li><a class="tocitem" href="../../FAQ/translate_a_model/">I want to use PlantSimEngine for my model</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extending</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs/src/extending/implement_a_model.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="model_implementation_page"><a class="docs-heading-anchor" href="#model_implementation_page">Model implementation in 5 minutes</a><a id="model_implementation_page-1"></a><a class="docs-heading-anchor-permalink" href="#model_implementation_page" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><code>PlantSimEngine.jl</code> was designed to make new model implementation very simple. So let&#39;s learn about how to implement your own model with a simple example: implementing a new light interception model.</p><h2 id="Inspiration"><a class="docs-heading-anchor" href="#Inspiration">Inspiration</a><a id="Inspiration-1"></a><a class="docs-heading-anchor-permalink" href="#Inspiration" title="Permalink"></a></h2><p>If you want to implement a new model, the best way to do it is to start from another implementation.</p><p>For a complete example, you can look at the code in <a href="https://github.com/VEZY/PlantBiophysics.jl"><code>PlantBiophysics.jl</code></a>, were you will find <em>e.g.</em> a photosynthesis model, with the implementation of the <code>FvCB</code> model in this Julia file: <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/photosynthesis/FvCB.jl">src/photosynthesis/FvCB.jl</a>; an energy balance model with the implementation of the <code>Monteith</code> model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">src/energy/Monteith.jl</a>; or a stomatal conductance model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/conductances/stomatal/medlyn.jl">src/conductances/stomatal/medlyn.jl</a>.</p><p><code>PlantSimEngine</code> also provide toy models that can be used as a base to better understand how to implement a new model: </p><ul><li>The Beer model for light interception in <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/Beer.jl">examples/Beer.jl</a></li><li>A toy LAI development in <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/ToyLAIModel.jl">examples/ToyLAIModel.jl</a></li></ul><h2 id="Requirements"><a class="docs-heading-anchor" href="#Requirements">Requirements</a><a id="Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements" title="Permalink"></a></h2><p>In those files, you&#39;ll see that in order to implement a new model you&#39;ll need to implement:</p><ul><li>a structure, used to hold the parameter values and to dispatch to the right method</li><li>the actual model, developed as a method for the process it simulates</li><li>some helper functions used by the package and/or the users</li></ul><p>If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see <a href="../implement_a_process/#Implement-a-new-process">Implement a new process</a>).</p><p>In this page, we&#39;ll just implement a model for a process that already exists: the light interception. This process is defined in <code>PlantBiophysics.jl</code>, and also made available as an example model from the <code>Examples</code> sub-module. You can access the script from here: <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/examples/Beer.jl"><code>examples/Beer.jl</code></a>.</p><p>We can import the model like so:</p><pre><code class="language-julia hljs"># Import the example models defined in the `Examples` sub-module:
using PlantSimEngine.Examples</code></pre><p>But instead of just using it, we will review the script line by line.</p><h2 id="Example:-the-Beer-Lambert-model"><a class="docs-heading-anchor" href="#Example:-the-Beer-Lambert-model">Example: the Beer-Lambert model</a><a id="Example:-the-Beer-Lambert-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-Beer-Lambert-model" title="Permalink"></a></h2><h3 id="The-process"><a class="docs-heading-anchor" href="#The-process">The process</a><a id="The-process-1"></a><a class="docs-heading-anchor-permalink" href="#The-process" title="Permalink"></a></h3><p>We declare the light interception process at l.7 using <a href="../../API/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>@process</code></a>: </p><pre><code class="language-julia hljs">@process &quot;light_interception&quot; verbose = false</code></pre><p>See <a href="../implement_a_process/#Implement-a-new-process">Implement a new process</a> for more details on how that works and how to use the process.</p><h3 id="The-structure"><a class="docs-heading-anchor" href="#The-structure">The structure</a><a id="The-structure-1"></a><a class="docs-heading-anchor-permalink" href="#The-structure" title="Permalink"></a></h3><p>To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:</p><ul><li>hold the parameter values</li><li>dispatch to the right <code>run!</code> method when calling it</li></ul><p>The structure of the model (or type) is defined as follows:</p><pre><code class="language-julia hljs">struct Beer{T} &lt;: AbstractLight_InterceptionModel
    k::T
end</code></pre><p>The first line defines the name of the model (<code>Beer</code>), which is completely free, except it is good practice to use camel case for the name, <em>i.e.</em> using capital letters for the words and no separator <code>LikeThis</code>. </p><p>We also can see that we define the <code>Beer</code> structure as a subtype of <code>AbstractLight_InterceptionModel</code>. This step is very important as it tells to the package what kind of process the model simulates. <code>AbstractLight_InterceptionModel</code> is automatically created when defining the process &quot;light_interception&quot;.</p><p>In our case, it tells us that <code>Beer</code> is a model to simulate the light interception process.</p><p>Then comes the parameters names, and their types. The type of parameters is given by the user at instantiation in our example. This is done using the <code>T</code> notation as follows:</p><ul><li>we say that our structure <code>Beer</code> is a parameterized <code>struct</code> by putting <code>T</code> in between brackets after the name of the <code>struct</code></li><li>We put <code>::T</code> after our parameter name in the <code>struct</code>. This way Julia knows that our parameter will be of type <code>T</code>.</li></ul><p>The <code>T</code> is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, <em>e.g.</em>:</p><pre><code class="language-julia hljs">struct YourStruct{T,S} &lt;: AbstractLight_InterceptionModel
    k::T
    x::T
    y::T
    z::S
end</code></pre><p>Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.</p><p>But why not forcing the type such as the following:</p><pre><code class="language-julia hljs">struct YourStruct &lt;: AbstractLight_InterceptionModel
    k::Float64
    x::Float64
    y::Float64
    z::Int
end</code></pre><p>Well, you can do that. But you&#39;ll lose a lot of the magic Julia has to offer this way.</p><p>For example a user could use the <code>Particles</code> type from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.</p><h3 id="The-method"><a class="docs-heading-anchor" href="#The-method">The method</a><a id="The-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-method" title="Permalink"></a></h3><p>The models are implemented by adding a method for its type to the <a href="../../API/#PlantSimEngine.run!"><code>run!</code></a> function. The exclamation point at the end of the function name is used in Julia to tell users that the function is mutating, <em>i.e.</em> it modifies its input.</p><p>The function takes six arguments:</p><ul><li>the type of your model</li><li>models: a <code>ModelList</code> object, which contains all the models of the simulation</li><li>status: a <code>Status</code> object, which contains the current values (<em>i.e.</em> state) of the variables for <strong>one</strong> time-step (e.g. the value of the plant LAI at time t)</li><li>meteo: (usually) an <code>Atmosphere</code> object, or a row of the meteorological data, which contains the current values of the meteorological variables for <strong>one</strong> time-step (<em>e.g.</em> the value of the PAR at time t)</li><li>constants: a <code>Constants</code> object, or a <code>NamedTuple</code>, which contains the values of the constants for the simulation (<em>e.g.</em> the value of the Stefan-Boltzmann constant)</li><li>extras: any other object you want to pass to your model. This is for advanced users, and is not used in this example. Note that it is used to pass the <code>Node</code> when simulating a MultiScaleTreeGraph.</li></ul><p>Your implementation can use any variables or parameters in these objects. The only thing you have to do is to make sure that the variables you use are defined in the <code>Status</code> object, the meteorology, and the <code>Constants</code> object.</p><p>The variables you use from the <code>Status</code> must be declared as inputs of your model. And the ones you modify must be declared as outputs. We&#39;ll that below.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Models implementations are done for <strong>one</strong> time-step by design. The values of the previous time-step is always available in the <code>status</code> (<em>e.g.</em> <code>status.biomass</code>) as long as the variable is an output of your model. This is because at the end of a time-step, the <code>Status</code> object is recycled for the next time-step and so the latest computed values are always available. This is why it is possible to increment a value every time-step using <em>e.g.</em> <code>status.biomass += 1.0</code>. By design models don&#39;t have access to values prior to the one before. If you&#39;re not convinced by this approach, ask yourself how the plant knows the value of <em>e.g.</em> LAI from 15 days ago. It doesn&#39;t. It only knows its current state. Most of the time-sensitive variables really are just an accumulation of values until a threshold anyway. BUt if you really need to use values from the past (<em>e.g.</em> 15 time-steps before), you can add a variable to the <code>Status</code> object that is uses like a queue (see <em>e.g.</em> <a href="https://juliacollections.github.io/DataStructures.jl/stable/">DataStructures.jl</a>).</p></div></div><p><code>PlantSimEngine</code> then automatically deals with every other detail, such as checking that the object is correctly initialized, applying the computations over objects and time-steps. This is nice because as a developer you don&#39;t have to deal with those details, and you can just concentrate on your model implementation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before <em>e.g.</em>: <code>import PlantSimEngine: inputs_, outputs_</code></p></div></div><p>So let&#39;s do it! Here is our own implementation of the light interception for a <code>ModelList</code> component models:</p><pre><code class="language-julia hljs">function run!(::Beer, models, status, meteo, constants, extras)
    status.PPFD =
        meteo.Ri_PAR_f *
        exp(-models.light_interception.k * status.LAI) *
        constants.J_to_umol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">run! (generic function with 1 method)</code></pre><p>The first argument (<code>::Beer</code>) means this method will only execute when the function is called with a first argument that is of type <code>Beer</code>. This is our way of telling Julia that this method implements the <code>Beer</code> model for the light interception process.</p><p>An important thing to note is that the model parameters are available from the <code>ModelList</code> that is passed via the <code>models</code> argument. Then parameters are found in field called by the process name, and the parameter name. For example, the <code>k</code> parameter of the <code>Beer</code> model is found in <code>models.light_interception.k</code>.</p><p>One last thing to do is to define the inputs and outputs of our model. This is done by adding a method for the <a href="../../API/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="../../API/#PlantSimEngine.outputs-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>outputs</code></a> functions. These functions take the type of the model as argument, and return a <code>NamedTuple</code> with the names of the variables as keys, and their default values as values.</p><p>In our case, the <code>Beer</code> model has one input and one output:</p><ul><li>Inputs: <code>:LAI</code>, the leaf area index (m² m⁻²)</li><li>Outputs: <code>:aPPFD</code>, the photosynthetic photon flux density (μmol m⁻² s⁻¹)</li></ul><p>Here is how we communicate that to PlantSimEngine:</p><pre><code class="language-julia hljs">function PlantSimEngine.inputs_(::Beer)
    (LAI=-Inf,)
end

function PlantSimEngine.outputs_(::Beer)
    (aPPFD=-Inf,)
end</code></pre><p>Note that both functions end with an &quot;_&quot;. This is because these functions are internal, they will not be called by the users directly. Users will use <a href="../../API/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="../../API/#PlantSimEngine.outputs-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>outputs</code></a> instead, which call <code>inputs_</code> and <code>outputs_</code>, but stripping out the default values.</p><h3 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h3><p>If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.</p><p>To do so, we can add a method to the <code>dep</code> function that tells PlantSimEngine which processes (and models) are needed for the model to run.</p><p>Our example model does not call another model, so we don&#39;t need to implement it. But we can look at <em>e.g.</em> the implementation for <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/d1d5addccbab45688a6c3797e650a640209b8359/src/processes/photosynthesis/FvCB.jl#L83"><code>Fvcb</code></a> in <code>PlantBiophysics.jl</code> to see how it works:</p><pre><code class="language-julia hljs">PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)</code></pre><p>Here we say to PlantSimEngine that the <code>Fvcb</code> model needs a model of type <code>AbstractStomatal_ConductanceModel</code> in the stomatal conductance process.</p><p>You can read more about dependencies in <a href="../../model_coupling/model_coupling_modeler/#Model-coupling-for-modelers">Model coupling for modelers</a> and <a href="../../model_coupling/model_coupling_user/#Model-coupling-for-users">Model coupling for users</a>.</p><h3 id="The-utility-functions"><a class="docs-heading-anchor" href="#The-utility-functions">The utility functions</a><a id="The-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-utility-functions" title="Permalink"></a></h3><p>Before running a simulation, you can do a little bit more for your implementation (optional).</p><p>First, you can add a method for type promotion. It wouldn&#39;t make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called <code>Beer2</code> that would take two parameters:</p><pre><code class="language-julia hljs">struct Beer2{T} &lt;: AbstractLight_InterceptionModel
    k::T
    x::T
end</code></pre><p>To add type promotion to <code>Beer2</code> we would do:</p><pre><code class="language-julia hljs">function Beer2(k,x)
    Beer2(promote(k,x))
end</code></pre><p>This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:</p><pre><code class="language-julia hljs">Beer2(0.6,2)</code></pre><p>You don&#39;t see a problem? Well your users won&#39;t either. But there&#39;s one: <code>Beer2</code> is a parametric type, so all fields share the same type <code>T</code>. This is the <code>T</code> in <code>Beer2{T}</code> and then in <code>k::T</code> and <code>x::T</code>. And this force the user to give all parameters with the same type.</p><p>And in our example above, the user provides <code>0.6</code> for <code>k</code>, which is a <code>Float64</code>, and <code>2</code> for <code>x</code>, which is an <code>Int</code>. ANd if you don&#39;t have type promotion, Julia will return an error because both should be either <code>Float64</code> or <code>Int</code>. That&#39;s were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert <code>2</code> to <code>2.0</code>.</p><p>A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of <code>k</code>. So we can provide a default value like so:</p><pre><code class="language-julia hljs">Beer() = Beer(0.6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer</code></pre><p>Now the user can call <code>Beer</code> with zero value, and <code>k</code> will default to <code>0.6</code>.</p><p>Another useful thing is the ability to instantiate your model type with keyword arguments, <em>i.e.</em> naming the arguments. You can do it by adding the following method:</p><pre><code class="language-julia hljs">Beer(;k) = Beer(k)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer</code></pre><p>Did you notice the <code>;</code> before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call <code>Beer</code> like this:</p><pre><code class="language-julia hljs">Beer(k = 0.7)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer{Float64}(0.7)</code></pre><p>This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.</p><p>The last optional thing to implement is a method for the <code>eltype</code> function:</p><pre><code class="language-julia hljs">Base.eltype(x::Beer{T}) where {T} = T</code></pre><p>This one helps Julia know the type of the elements in the structure, and make it faster.</p><h3 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h3><p><code>PlantSimEngine</code> defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (<em>i.e.</em> objects) and/or time (<em>i.e.</em> time-steps).</p><p>By default, all models are assumed to be <strong>not</strong> parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.</p><p>For example, if we want to add the trait for parallelization over objects to our <code>Beer</code> model, we would do:</p><pre><code class="language-julia hljs">PlantSimEngine.ObjectDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsObjectIndependent()</code></pre><p>And if we want to add the trait for parallelization over time-steps to our <code>Beer</code> model, we would do:</p><pre><code class="language-julia hljs">PlantSimEngine.TimeStepDependencyTrait(::Type{&lt;:Beer}) = PlantSimEngine.IsTimeStepIndependent()</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.</p></div></div><p>OK that&#39;s it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implement_a_process/">« Processes</a><a class="docs-footer-nextpage" href="../inputs/">Input types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 24 July 2024 10:34">Wednesday 24 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
