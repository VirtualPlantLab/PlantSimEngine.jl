<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · PlantSimEngine.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/PlantSimEngine.jl/extending/implement_a_model/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantSimEngine.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../design/">Design</a></li><li><span class="tocitem">Extending</span><ul><li><a class="tocitem" href="../implement_a_process/">Processes</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Inspiration"><span>Inspiration</span></a></li><li><a class="tocitem" href="#Requirements"><span>Requirements</span></a></li><li><a class="tocitem" href="#Example:-the-Beer-Lambert-model"><span>Example: the Beer-Lambert model</span></a></li></ul></li></ul></li><li><span class="tocitem">Coupling</span><ul><li><a class="tocitem" href="../../model_coupling/model_coupling_user/">Users</a></li><li><a class="tocitem" href="../../model_coupling/model_coupling_modeler/">Modelers</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extending</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/PlantSimEngine.jl/blob/main/docs/src/extending/implement_a_model.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="model_implementation_page"><a class="docs-heading-anchor" href="#model_implementation_page">Model implementation in 5 minutes</a><a id="model_implementation_page-1"></a><a class="docs-heading-anchor-permalink" href="#model_implementation_page" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><code>PlantSimEngine.jl</code> was designed to make new model implementation very simple. So let&#39;s learn about how to implement your own model with a simple example: implementing a new light interception model.</p><h2 id="Inspiration"><a class="docs-heading-anchor" href="#Inspiration">Inspiration</a><a id="Inspiration-1"></a><a class="docs-heading-anchor-permalink" href="#Inspiration" title="Permalink"></a></h2><p>If you want to implement a new model, the best way to do it is to start from another implementation.</p><p>For a complete example, you can look at the code in <a href="https://github.com/VEZY/PlantBiophysics.jl"><code>PlantBiophysics.jl</code></a>, were you will find <em>e.g.</em> a photosynthesis model, with the implementation of the <code>FvCB</code> model in this Julia file: <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/photosynthesis/FvCB.jl">src/photosynthesis/FvCB.jl</a>; an energy balance model with the implementation of the <code>Monteith</code> model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">src/energy/Monteith.jl</a>; or a stomatal conductance model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/conductances/stomatal/medlyn.jl">src/conductances/stomatal/medlyn.jl</a>.</p><h2 id="Requirements"><a class="docs-heading-anchor" href="#Requirements">Requirements</a><a id="Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements" title="Permalink"></a></h2><p>In those files, you&#39;ll see that in order to implement a new model you&#39;ll need to implement:</p><ul><li>a structure, used to hold the parameter values and to dispatch to the right method</li><li>the actual model, developed as a method for the process it simulates</li><li>some helper functions used by the package and/or the users</li></ul><p>If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see <a href="../implement_a_process/#Implement-a-new-process">Implement a new process</a>).</p><p>In this page, we&#39;ll just implement a model for a process that exists already: the light interception. This process is defined in <code>PlantBiophysics.jl</code>, but also in an example script in this package here: <a href="https://github.com/VEZY/PlantSimEngine.jl/blob/main/examples/light.jl"><code>examples/light.jl</code></a>.</p><p>We can include this file like so:</p><pre><code class="language-julia hljs">include(joinpath(dirname(dirname(pathof(PlantSimEngine))), &quot;examples&quot;, &quot;light.jl&quot;))</code></pre><p>But instead of just using it, we will review the script line by line.</p><h2 id="Example:-the-Beer-Lambert-model"><a class="docs-heading-anchor" href="#Example:-the-Beer-Lambert-model">Example: the Beer-Lambert model</a><a id="Example:-the-Beer-Lambert-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-Beer-Lambert-model" title="Permalink"></a></h2><h3 id="The-process"><a class="docs-heading-anchor" href="#The-process">The process</a><a id="The-process-1"></a><a class="docs-heading-anchor-permalink" href="#The-process" title="Permalink"></a></h3><p>We declare the light interception process at l.7 using <a href="../../API/#PlantSimEngine.@gen_process_methods-Tuple{Any, Vararg{Any}}"><code>@gen_process_methods</code></a>: </p><pre><code class="language-julia hljs">@gen_process_methods &quot;light_interception&quot; verbose = false</code></pre><p>See <a href="../implement_a_process/#Implement-a-new-process">Implement a new process</a> for more details on how that works and how to use the process.</p><h3 id="The-structure"><a class="docs-heading-anchor" href="#The-structure">The structure</a><a id="The-structure-1"></a><a class="docs-heading-anchor-permalink" href="#The-structure" title="Permalink"></a></h3><p>The first thing to do to implement a model is to define a structure.</p><p>The purpose of the structure is two-fold:</p><ul><li>hold the parameter values</li><li>dispatch to the right method when calling the process function</li></ul><p>The structure of the model (or type) is defined as follows:</p><pre><code class="language-julia hljs">struct Beer{T} &lt;: AbstractLight_InterceptionModel
    k::T
end</code></pre><p>The first line defines the name of the model (<code>Beer</code>), which is completely free, except it is good practice to use camel case for the name, <em>i.e.</em> using capital letters for the words and no separator <code>LikeThis</code>. </p><p>We also can see that we define the <code>Beer</code> structure as a subtype of <code>AbstractLight_InterceptionModel</code>. This step is very important as it tells to the package what kind of process the model simulates. <code>AbstractLight_InterceptionModel</code> is automatically created when defining the process &quot;light_interception&quot;.</p><p>In our case, it tells us that <code>Beer</code> is a model to simulate the light interception process.</p><p>Then comes the parameters names, and their types. The type of the parameters is given by the user at instantiation in our example. This is done using the <code>T</code> notation as follows:</p><ul><li>we say that our structure <code>Beer</code> is a parameterized <code>struct</code> by putting <code>T</code> in between brackets after the name of the <code>struct</code></li><li>We put <code>::T</code> after our parameter name in the <code>struct</code>. This way Julia knows that our parameter will be of type <code>T</code>.</li></ul><p>The <code>T</code> is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, <em>e.g.</em>:</p><pre><code class="language-julia hljs">struct YourStruct{T,S} &lt;: AbstractLight_InterceptionModel
    k::T
    x::T
    y::T
    z::S
end</code></pre><p>Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.</p><p>But why not forcing the type such as the following:</p><pre><code class="language-julia hljs">struct YourStruct &lt;: AbstractLight_InterceptionModel
    k::Float64
    x::Float64
    y::Float64
    z::Int
end</code></pre><p>Well, you can do that. But you&#39;ll lose a lot of the magic Julia has to offer this way.</p><p>For example a user could use the <code>Particles</code> type from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.</p><h3 id="The-method"><a class="docs-heading-anchor" href="#The-method">The method</a><a id="The-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-method" title="Permalink"></a></h3><p>The models are implemented in a function named after the process and a &quot;!_&quot; as a suffix. The exclamation point is used in Julia to tell users the function is mutating, <em>i.e.</em> it modifies its input.</p><p>Your implementation should always modify the input status and return nothing. This ensures that models compute fast. The &quot;_&quot; suffix is used to tell users that this is the internal implementation, which is only used by modelers.</p><p>Remember that PlantSimEngine only exports the generic functions of the processes to users because they are the one that handles every other details, such as checking that the object is correctly initialized, and applying the computations over objects and time-steps. This is nice because as a developer you don&#39;t have to deal with those details, and you can just concentrate on your implementation.</p><p>However, you have to remember that if your model calls another one, you&#39;ll have to use the internal implementation directly to avoid the overheads of the generic functions (you don&#39;t want all these checks).</p><p>So if you want to implement a new light interception model, you have to make your own method for the <code>light_interception!_</code> function. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>We need to import all the functions we need to use or extend, so Julia knows we are extending the methods from PlantSimEngine, and not defining our own functions. To do so, we prefix the said functions by the package name, or import them before <em>e.g.</em>: <code>import PlantSimEngine: inputs_, outputs_</code></p></div></div><p>So let&#39;s do it! Here is our own implementation of the light interception for a <code>ModelList</code> component models:</p><pre><code class="language-julia hljs">function light_interception!_(::Beer, models, status, meteo, constants, extras)
    status.PPFD =
        meteo.Ri_PAR_f *
        exp(-models.light_interception.k * status.LAI) *
        constants.J_to_umol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">light_interception!_ (generic function with 5 methods)</code></pre><p>The first argument (<code>::Beer</code>) means this method will only execute when the function is called with a first argument that is of type <code>Beer</code>. This is our way of telling Julia that this method is implementing the <code>Beer</code> model for the light interception process.</p><p>An important thing to note is that our variables are stored in different structures:</p><ul><li><code>models</code>: lists the processes and the models parameters (we use <code>k</code>from Beer here using <code>models.light_interception.k</code>)</li><li><code>meteo</code>: the micro-climatic conditions</li><li><code>status</code>: the input and output variables of the models</li><li><code>constants</code>: any constants given as a struct or a <code>NamedTuple</code></li><li><code>extras</code>: any other value or object (<em>e.g.</em> it is used to pass the node when computing MTGs)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The micro-meteorological conditions are always given for one time-step inside the models methods, so they are always of <code>Atmosphere</code> type. The <code>Tables.jl</code> type (<em>e.g.</em> <code>TimeStepTable</code> or <code>DataFrame</code>) conditions are handled earlier by the generic functions, <em>i.e.</em> <code>light_interception()</code> and <code>light_interception!()</code>, not <code>light_interception!_()</code>.</p></div></div><p>OK ! So that&#39;s it ? Almost. One last thing to do is to define a method for inputs/outputs so that PlantSimEngine knows which variables are needed for our model, and which it computes. Remember that the actual model is implemented for <code>light_interception!_</code>, so we have to tell PlantSimEngine which ones are needed, and what are their default value:</p><ul><li>Inputs: <code>:LAI</code>, the leaf area index (m² m⁻²)</li><li>Outputs: <code>:PPFD</code>, the photosynthetic photon flux density (μmol m⁻² s⁻¹)</li></ul><p>Here is how we communicate that to PlantSimEngine:</p><pre><code class="language-julia hljs">function PlantSimEngine.inputs_(::Beer)
    (LAI=-Inf,)
end

function PlantSimEngine.outputs_(::Beer)
    (PPFD=-Inf,)
end</code></pre><p>Note that both function end with an &quot;_&quot;. This is because these functions are internal, they will not be called by the users directly. Users will use <a href="../../API/#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="../../API/#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> instead, which call <code>inputs_</code> and <code>outputs_</code>, but stripping out the default values.</p><h3 id="The-utility-functions"><a class="docs-heading-anchor" href="#The-utility-functions">The utility functions</a><a id="The-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-utility-functions" title="Permalink"></a></h3><p>Before running a simulation, you can do a little bit more for your implementation (optional).</p><p>First, you can add a method for type promotion. It wouldn&#39;t make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called <code>Beer2</code> that would take two parameters:</p><pre><code class="language-julia hljs">struct Beer2{T} &lt;: AbstractLight_InterceptionModel
    k::T
    x::T
end</code></pre><p>To add type promotion to <code>Beer2</code> we would do:</p><pre><code class="language-julia hljs">function Beer2(k,x)
    Beer2(promote(k,x))
end</code></pre><p>This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:</p><pre><code class="language-julia hljs">Beer2(0.6,2)</code></pre><p>You don&#39;t see a problem? Well your users won&#39;t either. But there&#39;s one: <code>Beer2</code> is a parametric type, so all fields share the same type <code>T</code>. This is the <code>T</code> in <code>Beer2{T}</code> and then in <code>k::T</code> and <code>x::T</code>. And this force the user to give all parameters with the same type.</p><p>And in our example above, the user provides <code>0.6</code> for <code>k</code>, which is a <code>Float64</code>, and <code>2</code> for <code>x</code>, which is an <code>Int</code>. ANd if you don&#39;t have type promotion, Julia will return an error because both should be either <code>Float64</code> or <code>Int</code>. That&#39;s were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert <code>2</code> to <code>2.0</code>.</p><p>A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of <code>k</code>. So we can provide a default value like so:</p><pre><code class="language-julia hljs">Beer() = Beer(0.6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer</code></pre><p>Now the user can call <code>Beer</code> with zero value, and <code>k</code> will default to <code>0.6</code>.</p><p>Another useful thing to provide to the user is the ability to instantiate your model type with keyword values. You can do it by adding the following method:</p><pre><code class="language-julia hljs">Beer(;k) = Beer(k)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer</code></pre><p>Did you notice the <code>;</code> before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call <code>Beer</code> like this:</p><pre><code class="language-julia hljs">Beer(k = 0.7)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Beer{Float64}(0.7)</code></pre><p>This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.</p><p>One more thing to implement is a method for the <code>dep</code> function that tells PlantSimEngine which processes (and models) are needed for the model to run (<em>i.e.</em> if your model is coupled to another model).</p><p>Our example model does not call another model, so we don&#39;t need to implement it. But we can look at <em>e.g.</em> the implementation for <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/d1d5addccbab45688a6c3797e650a640209b8359/src/processes/photosynthesis/FvCB.jl#L83"><code>Fvcb</code></a> in <code>PlantBiophysics.jl</code> to see how it works:</p><pre><code class="language-julia hljs">PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)</code></pre><p>Here we say to PlantSimEngine that the <code>Fvcb</code> model needs a model of type <code>AbstractStomatal_ConductanceModel</code> in the stomatal conductance process.</p><p>The last optional thing to implement is a method for the <code>eltype</code> function:</p><pre><code class="language-julia hljs">Base.eltype(x::Beer{T}) where {T} = T</code></pre><p>This one helps Julia to know the type of the elements in the structure, and make it faster.</p><p>OK that&#39;s it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue so I can improve it.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implement_a_process/">« Processes</a><a class="docs-footer-nextpage" href="../../model_coupling/model_coupling_user/">Users »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 19 January 2023 23:36">Thursday 19 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
