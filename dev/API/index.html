<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PlantSimEngine.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/PlantSimEngine.jl/API/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PlantSimEngine.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../design/">Design</a></li><li><a class="tocitem" href="../model_switching/">Model Switching</a></li><li><a class="tocitem" href="../reducing_dof/">Reducing DoF</a></li><li><a class="tocitem" href="../model_execution/">Execution</a></li><li><a class="tocitem" href="../fitting/">Fitting</a></li><li><span class="tocitem">Extending</span><ul><li><a class="tocitem" href="../extending/implement_a_process/">Processes</a></li><li><a class="tocitem" href="../extending/implement_a_model/">Models</a></li><li><a class="tocitem" href="../extending/inputs/">Input types</a></li></ul></li><li><span class="tocitem">Coupling</span><ul><li><a class="tocitem" href="../model_coupling/model_coupling_user/">Users</a></li><li><a class="tocitem" href="../model_coupling/model_coupling_modeler/">Modelers</a></li></ul></li><li><span class="tocitem">FAQ</span><ul><li><a class="tocitem" href="../FAQ/translate_a_model/">I want to use PlantSimEngine for my model</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API-documentation"><span>API documentation</span></a></li><li><a class="tocitem" href="#Un-exported"><span>Un-exported</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/PlantSimEngine.jl/blob/main/docs/src/API.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a></li><li><a href="#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a></li><li><a href="#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a></li><li><a href="#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a></li><li><a href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a></li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a></li><li><a href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a></li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a></li><li><a href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a></li><li><a href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a></li><li><a href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a></li><li><a href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a></li><li><a href="#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a></li><li><a href="#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}"><code>PlantSimEngine.convert_vars</code></a></li><li><a href="#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a></li><li><a href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a></li><li><a href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a></li><li><a href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a></li><li><a href="#PlantSimEngine.draw_panel-NTuple{5, Any}"><code>PlantSimEngine.draw_panel</code></a></li><li><a href="#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a></li><li><a href="#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a></li><li><a href="#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a></li><li><a href="#PlantSimEngine.get_Ref_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing"><code>PlantSimEngine.get_Ref_i</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, &lt;:ModelList}, Any}"><code>PlantSimEngine.init_mtg_models!</code></a></li><li><a href="#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a></li><li><a href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a></li><li><a href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a></li><li><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a></li><li><a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a></li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a></li><li><a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a></li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a></li><li><a href="#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a></li><li><a href="#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a></li><li><a href="#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a></li><li><a href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a></li><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a></li><li><a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a></li><li><a href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}"><code>PlantSimEngine.to_initialize</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}"><code>PlantSimEngine.update_mtg_models!</code></a></li><li><a href="#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a></li><li><a href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a></li><li><a href="#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a></li></ul><h2 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status" href="#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><code>PlantMeteo.TimeStepTable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeStepTable{Status}(df::DataFrame)</code></pre><p>Method to build a <code>TimeStepTable</code> (from <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/">PlantMeteo.jl</a>)  from a <code>DataFrame</code>, but with each row being a <code>Status</code>.</p><p><strong>Note</strong></p><p><a href="#PlantSimEngine.ModelList"><code>ModelList</code></a> uses <code>TimeStepTable{Status}</code> by default (see examples below).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, DataFrames

# A TimeStepTable from a DataFrame:
df = DataFrame(
    Tₗ=[25.0, 26.0],
    aPPFD=[1000.0, 1200.0],
    Cₛ=[400.0, 400.0],
    Dₗ=[1.0, 1.2],
)
TimeStepTable{Status}(df)

# A leaf with several values for at least one of its variable will automatically use 
# TimeStepTable{Status} with the time steps:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# The status of the leaf is a TimeStepTable:
status(models)

# Of course we can also create a TimeStepTable with Status manually:
TimeStepTable(
    [
        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),
        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/TimeStepTable.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.AbstractModel" href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract model type. All models are subtypes of this one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/Abstract_model_structs.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.ModelList" href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelList(models::M, status::S)
ModelList(;
    status=nothing,
    init_fun::Function=init_fun_default,
    type_promotion=nothing,
    variables_check=true,
    kwargs...
)</code></pre><p>List the models for a simulation (<code>models</code>), and does all boilerplate for variable initialization,  type promotion, time steps handling.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The status field depends on the input models. You can get the variables needed by a model using <a href="#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a> on the instantiation of a model. You can also use <a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> and <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> instead.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>models</code>: a list of models. Usually given as a <code>NamedTuple</code>, but can be any other structure that </li></ul><p>implements <code>getproperty</code>.</p><ul><li><code>status</code>: a structure containing the initializations for the variables of the models. Usually a NamedTuple</li></ul><p>when given as a kwarg, or any structure that implements the Tables interface from <code>Tables.jl</code> (<em>e.g.</em> DataFrame, see details).</p><ul><li><code>init_fun</code>: a function that initializes the status based on a vector of NamedTuples (see details).</li><li><code>type_promotion</code>: optional type conversion for the variables with default values.</li></ul><p><code>nothing</code> by default, <em>i.e.</em> no conversion. Note that conversion is not applied to the variables input by the user as <code>kwargs</code> (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.</p><ul><li><code>variables_check=true</code>: check that all needed variables are initialized by the user.</li><li><code>kwargs</code>: the models, named after the process they simulate.</li></ul><p><strong>Details</strong></p><p>The argument <code>init_fun</code> is set by default to <code>init_fun_default</code> which initializes the status with a <code>TimeStepTable</code> of <code>Status</code> structures.</p><p>If you change <code>init_fun</code> by another function, make sure the type you are using (<em>i.e.</em> in place of <code>TimeStepTable</code>)  implements the <code>Tables.jl</code> interface (<em>e.g.</em> DataFrame does). And if you still use <code>TimeStepTable</code> but only change <code>Status</code>, make sure the type you give is indexable using the dot synthax (<em>e.g.</em> <code>x.var</code>).</p><p>If you need to input a custom Type for the status and make your users able to only partially initialize  the <code>status</code> field in the input, you&#39;ll have to implement a method for <code>add_model_vars!</code>, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the <code>Tables.jl</code> interface (<em>e.g.</em> DataFrame), and <code>NamedTuples</code>.</p><p>Note that <code>ModelList</code>makes a copy of the input <code>status</code> if it does not list all needed variables.</p><p><strong>Examples</strong></p><p>We&#39;ll use the dummy models from the <code>dummy.jl</code> in the examples folder of the package. It  implements three dummy processes: <code>Process1Model</code>, <code>Process2Model</code> and <code>Process3Model</code>, with one model implementation each: <code>Process1Model</code>, <code>Process2Model</code> and <code>Process3Model</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>Including an example script that implements dummy processes and models:</p><pre><code class="language-julia-repl hljs">julia&gt; include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());
[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; typeof(models)
ModelList{NamedTuple{(:process1, :process2, :process3), Tuple{Process1Model, Process2Model, Process3Model}}, TimeStepTable{Status{(:var4, :var5, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}}</code></pre><p>No variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually <code>typemin(Type)</code>, <em>i.e.</em> <code>-Inf</code> for floating point numbers). This component cannot be simulated yet.</p><p>To know which variables we need to initialize for a simulation, we use <a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; to_initialize(models)
(process1 = (:var1, :var2), process2 = (:var1,))</code></pre><p>We can now provide values for these variables in the <code>status</code> field, and simulate the <code>ModelList</code>,  <em>e.g.</em> for <code>process3</code> (coupled with <code>process1</code> and <code>process2</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; run!(models,meteo)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; models[:var6]
1-element Vector{Float64}:
 58.0138985</code></pre><p>If we want to use special types for the variables, we can use the <code>type_promotion</code> argument:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>We used <code>type_promotion</code> to force the status into Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float64
 Float64
 Float32</code></pre><p>But we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>We used <code>type_promotion</code> to force the status into Float32:</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float32
 Float32
 Float32</code></pre><p>We can also use DataFrame as the status type:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(:var1 =&gt; [13.747, 13.8], :var2 =&gt; [1.0, 1.0]);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; m = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=df, init_fun=x -&gt; DataFrame(x));</code></pre><p>Note that we use <code>init_fun</code> to force the status into a <code>DataFrame</code>, otherwise it would be automatically converted into a <code>TimeStepTable{Status}</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; status(m)
2×6 DataFrame
 Row │ var4     var5     var6     var1     var3     var2    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │    -Inf     -Inf     -Inf   13.747     -Inf      1.0
   2 │    -Inf     -Inf     -Inf   13.8       -Inf      1.0</code></pre><p>Note that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L2-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.Status" href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Status(vars)</code></pre><p>Status type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the <code>TimeStepRow</code> of a <code>TimeStepTable</code> (see  <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/"><code>PlantMeteo.jl</code> docs</a>) of a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a>.</p><p>Most of the code is taken from MasonProtter/MutableNamedTuples.jl, so <code>Status</code> is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a <code>NamedTuple</code> of the references to the values of the variables, which makes it mutable.</p><p><strong>Examples</strong></p><p>A leaf with one value for all variables will make a status with one time step:</p><pre><code class="language-julia-repl hljs">julia&gt; st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);</code></pre><p>All these indexing methods are valid:</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Rₛ]
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Rₛ
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1]
13.747</code></pre><p>Setting a Status variable is very easy:</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Rₛ] = 20.0
20.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Rₛ = 21.0
21.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1] = 22.0
22.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/Status.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.EF-Tuple{Any, Any}" href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EF(obs,sim)</code></pre><p>Returns the Efficiency Factor between observations <code>obs</code> and simulations <code>sim</code> using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe<em>model</em>efficiency_coefficient.</p><p>The closer to 1 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

EF(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/evaluation/statistics.jl#L45-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.NRMSE-Tuple{Any, Any}" href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NRMSE(obs,sim)</code></pre><p>Returns the Normalized Root Mean Squared Error between observations <code>obs</code> and simulations <code>sim</code>. Normalization is performed using division by observations range (max-min).</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

NRMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/evaluation/statistics.jl#L24-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.RMSE-Tuple{Any, Any}" href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RMSE(obs,sim)</code></pre><p>Returns the Root Mean Squared Error between observations <code>obs</code> and simulations <code>sim</code>.</p><p>The closer to 0 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

RMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/evaluation/statistics.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.dep" href="#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dep(m::ModelList, nsteps=1; verbose::Bool=true)</code></pre><p>Get the model dependency graph given a ModelList. If one graph is returned, then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. <code>nsteps</code> is the number of steps the dependency graph will be used over. It is used to determine the length of the <code>simulation_id</code> argument for each soft dependencies in the graph.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

dep(models)

# or directly with the processes:
vars = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

dep(;vars...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependencies.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.dr-Tuple{Any, Any}" href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dr(obs,sim)</code></pre><p>Returns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419</p><p>The closer to 1 the better.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

dr(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/evaluation/statistics.jl#L70-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.fit" href="#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit()</code></pre><p>Optimize the parameters of a model using measurements and (potentially) initialisation values. </p><p>Modellers should implement a method to <code>fit</code> for their model, with the following design pattern:</p><p>The call to the function should take the model type as the first argument (T::Type{&lt;:AbstractModel}),  the data as the second argument (as a <code>Table.jl</code> compatible type, such as <code>DataFrame</code>), and the  parameters initializations as keyword arguments (with default values when necessary).</p><p>For example the method for fitting the <code>Beer</code> model from the example script (see <code>src/examples/Beer.jl</code>) looks like  this:</p><pre><code class="language-julia hljs">function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)
    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)
    return (k=k,)
end</code></pre><p>The function should return the optimized parameters as a <code>NamedTuple</code> of the form <code>(parameter_name=parameter_value,)</code>.</p><p>Here is an example usage with the <code>Beer</code> model, where we fit the <code>k</code> parameter from &quot;measurements&quot; of <code>PPFD</code>, <code>LAI</code>  and <code>Ri_PAR_f</code>. </p><pre><code class="language-julia hljs">include(joinpath(pkgdir(PlantSimEngine), &quot;examples/Beer.jl&quot;))
m = ModelList(Beer(0.6), status=(LAI=2.0,))
meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)
run!(m, meteo)
df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])
fit(Beer, df)</code></pre><p>Note that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of <code>k=0.6</code>, and then use the simulated PPFD to fit the <code>k</code> parameter again, which gives the same value as the one used on the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/evaluation/fit.jl#L2-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, &lt;:ModelList}, Any}" href="#PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, &lt;:ModelList}, Any}"><code>PlantSimEngine.init_mtg_models!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mtg_models!(
    mtg::MultiScaleTreeGraph.Node,
    models::Dict{String,&lt;:ModelList},
    i=nothing;
    verbose=true,
    attr_name=:models
)</code></pre><p>initialize the components of an MTG (<em>i.e.</em> nodes) with the corresponding models.</p><p>The function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.</p><p><strong>Arguments</strong></p><ul><li><code>mtg::MultiScaleTreeGraph.Node</code>: the MTG tree.</li><li><code>models::Dict{String,ModelList}</code>: a dictionary of models named by components names</li><li><code>i=nothing</code>: the time-step to initialize. If <code>nothing</code>, initialize all the time-steps.</li><li><code>verbose = true</code>: return information during the processes</li><li><code>attr_name = :models</code>: the node attribute name used to store the models, default to </li></ul><p>Symbol(MultiScaleTreeGraph.cache_name(&quot;PlantSimEngine models&quot;))</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine, MultiScaleTreeGraph

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

# Make an MTG:
mtg = Node(MultiScaleTreeGraph.NodeMTG(&quot;/&quot;, &quot;Plant&quot;, 1, 1))
internode = Node(mtg, MultiScaleTreeGraph.NodeMTG(&quot;/&quot;, &quot;Internode&quot;, 1, 2))
leaf = Node(mtg, MultiScaleTreeGraph.NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 1, 2))
leaf[:var1] = [15.0, 16.0]
leaf[:var2] = 0.3

# Declare our models:
models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    )
)

# Checking which variables are needed for our models:
[component =&gt; to_initialize(model) for (component, model) in models]
# OK we need to initialize :var1 and :var2

# We could compute them directly inside the MTG from available variables instead of 
# giving them as initialisations:
transform!(
    mtg,
    :var1 =&gt; (x -&gt; x .+ 2.0) =&gt; :var2,
    ignore_nothing = true
)

# Initialising all components with their corresponding models and initialisations at time-step 1:
init_mtg_models!(mtg, models, 1)</code></pre><p>Note that this is possible only because the initialisation values are found in the MTG. If the initialisations are constant values between components, we can directly initialize them in the models definition (as we do in the begining).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/mtg/init_mtg_models.jl#L1-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}" href="#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_status!(object::Dict{String,ModelList};vars...)
init_status!(component::ModelList;vars...)</code></pre><p>Initialise model variables for components with user input.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
    )
)

init_status!(models, var1=1.0 , var2=2.0)
status(models[&quot;Leaf&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L109-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_variables(models...)</code></pre><p>Initialized model variables with their default values. The variables are taken from the inputs and outputs of the models.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

init_variables(Process1Model(2.0))
init_variables(process1=Process1Model(2.0), process2=Process2Model())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L163-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputs(model::AbstractModel)
inputs(...)</code></pre><p>Get the inputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no inputs) or <code>Missing</code> models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));

inputs(Process1Model(1.0))

# output
(:var1, :var2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList" href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_initialized(m::T) where T &lt;: ModelList
is_initialized(m::T, models...) where T &lt;: ModelList</code></pre><p>Check if the variables that must be initialized are, and return <code>true</code> if so, and <code>false</code> and an information message if not.</p><p><strong>Note</strong></p><p>There is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

is_initialized(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L215-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outputs(model::AbstractModel)
outputs(...)</code></pre><p>Get the outputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no outputs) or <code>Missing</code> models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));

outputs(Process1Model(1.0))

# output
(:var3,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L39-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.run!" href="#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())</code></pre><p>Run the simulation for each model in the model list in the correct order, <em>i.e.</em> respecting the dependency graph.</p><p>If several time-steps are given, the models are run sequentially for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>object</code>: a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a>, an array or dict of <code>ModelList</code>, or an MTG.</li><li><code>meteo</code>: a <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.TimeStepTable"><code>PlantMeteo.TimeStepTable</code></a> of </li></ul><p><a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Atmosphere"><code>PlantMeteo.Atmosphere</code></a> or a single <code>PlantMeteo.Atmosphere</code>.</p><ul><li><code>constants</code>: a <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Constants"><code>PlantMeteo.Constants</code></a> object, or a <code>NamedTuple</code> of constant keys and values.</li><li><code>extra</code>: extra parameters.</li><li><code>check</code>: if <code>true</code>, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.</li><li><code>executor</code>: the <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> executor used to run the simulation either in sequential (<code>executor=SequentialEx()</code>), in a </li></ul><p>multi-threaded way (<code>executor=ThreadedEx()</code>, the default), or in a distributed way (<code>executor=DistributedEx()</code>).</p><p><strong>Returns</strong></p><p>Modifies the status of the object in-place. Users may retrieve the results from the object using  the <a href="https://vezy.github.io/PlantSimEngine.jl/stable/API/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a>  function (see examples).</p><p><strong>Details</strong></p><p><strong>Model execution</strong></p><p>The models are run according to the dependency graph. If a model has a soft dependency on another model (<em>i.e.</em> its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.</p><p><strong>Parallel execution</strong></p><p>Users can ask for parallel execution by providing a compatible executor to the <code>executor</code> argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> package to run the simulation in parallel. That means that you can provide any compatible executor to the <code>executor</code> argument. You can take a look at <a href="https://github.com/JuliaFolds/FoldsThreads.jl">FoldsThreads.jl</a> for extra thread-based executors, <a href="https://github.com/JuliaFolds/FoldsDagger.jl">FoldsDagger.jl</a> for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon <a href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a> for GPU computations  (see <a href="https://github.com/VEZY/PlantSimEngine.jl/issues/22">this issue</a>) and <a href="https://github.com/JuliaFolds/FoldsKernelAbstractions.jl">FoldsKernelAbstractions.jl</a>. You can also take a look at  <a href="https://github.com/JuliaFolds/ParallelMagics.jl">ParallelMagics.jl</a> to check if automatic parallelization is possible.</p><p><strong>Example</strong></p><p>Import the packages: </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo;</code></pre><p>Load the dummy models given as example in the package:</p><pre><code class="language-julia-repl hljs">julia&gt; include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));</code></pre><p>Create a model list:</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));</code></pre><p>Create meteo data:</p><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);</code></pre><p>Run the simulation:</p><pre><code class="language-julia-repl hljs">julia&gt; run!(models, meteo);</code></pre><p>Get the results:</p><pre><code class="language-julia-repl hljs">julia&gt; (models[:var4],models[:var6])
([12.0], [41.95])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/run.jl#L1-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.status-Tuple{Any}" href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">status(m)
status(m::AbstractArray{&lt;:ModelList})
status(m::AbstractDict{T,&lt;:ModelList})</code></pre><p>Get a ModelList status, <em>i.e.</em> the state of the input (and output) variables.</p><p>See also <a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>is_initialized</code></a> and <a href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));

# Create a ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

status(models)

# Or just one variable:
status(models,:var1)


# Or the status at the ith time-step:
status(models, 2)

# Or even more simply:
models[:var1]
# output
2-element Vector{Float64}:
 15.0
 16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/get_status.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.to_initialize-Tuple{ModelList}" href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_initialize(v::T, vars...) where T &lt;: Union{Missing,AbstractModel}
to_initialize(m::T)  where T &lt;: ModelList
to_initialize(m::DependencyGraph)</code></pre><p>Return the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

to_initialize(process1=Process1Model(1.0), process2=Process2Model())

# Or using a component directly:
models = ModelList(process1=Process1Model(1.0), process2=Process2Model())
to_initialize(models)

m = ModelList(
    (
        process1=Process1Model(1.0),
        process2=Process2Model()
    ),
    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}" href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}"><code>PlantSimEngine.to_initialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_initialize(m::AbstractDependencyNode)</code></pre><p>Return the variables that must be initialized providing a set of models and processes. The function just returns the inputs and outputs of each model, with their default values. To take into account model coupling, use the function at an upper-level instead, <em>i.e.</em>  <code>to_initialize(m::ModelList)</code> or <code>to_initialize(m::DependencyGraph)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L72-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables-Tuple{Module}" href="#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(pkg::Module)</code></pre><p>Returns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).</p><p><strong>Note to developers</strong></p><p>Developers of a package that depends on PlantSimEngine should  put a csv file in &quot;data/variables.csv&quot;, then this file will be  returned by the function.</p><p><strong>Examples</strong></p><p>Here is an example with the PlantBiophysics package:</p><pre><code class="language-julia hljs">#] add PlantBiophysics
using PlantBiophysics
variables(PlantBiophysics)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L134-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}" href="#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(m::AbstractDependencyNode)</code></pre><p>Returns a tuple with the name of the inputs and outputs variables needed by a model in  a dependency graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}" href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(model)
variables(model, models...)</code></pre><p>Returns a tuple with the name of the variables needed by a model, or a union of those variables for several models.</p><p><strong>Note</strong></p><p>Each model can (and should) have a method for this function.</p><pre><code class="language-julia hljs">
using PlantSimEngine;

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));

variables(Process1Model(1.0))

variables(Process1Model(1.0), Process2Model())

# output

5-element Vector{Symbol}:
 :var1
 :var2
 :var3
 :var4
 :var5</code></pre><p><strong>See also</strong></p><p><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>variables_typed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L78-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.@process-Tuple{Any, Vararg{Any}}" href="#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@process(process::String, doc::String=&quot;&quot;; verbose::Bool=true)</code></pre><p>This macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if <code>verbose=true</code>.</p><p>The abstract process type is then used as a supertype of all models implementations for the  process, and is named &quot;Abstract&lt;ProcessName&gt;Model&quot;, <em>e.g.</em> <code>AbstractGrowthModel</code> for a process called growth.</p><p>The first argument to <code>@process</code> is the new process name,  the second is any additional documentation that should be added  to the <code>Abstract&lt;ProcessName&gt;Model</code> type, and the third determines whether  the short tutorial should be printed or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@process &quot;dummy_process&quot; &quot;This is a dummy process that shall not be used&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/process_generation.jl#L1-L21">source</a></section></article><h2 id="Un-exported"><a class="docs-heading-anchor" href="#Un-exported">Un-exported</a><a id="Un-exported-1"></a><a class="docs-heading-anchor-permalink" href="#Un-exported" title="Permalink"></a></h2><p>Private functions, types or constants from <code>PlantSimEngine</code>. These are not exported, so you need to use <code>PlantSimEngine.</code> to access them (<em>e.g.</em> <code>PlantSimEngine.DataFormat</code>). </p><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})" href="#DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components &lt;: AbstractArray{&lt;:ModelList})
DataFrame(components &lt;: AbstractDict{N,&lt;:ModelList})</code></pre><p>Fetch the data from a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a> (or an Array/Dict of) status into a DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine
using DataFrames

# Creating a ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# Converting to a DataFrame
df = DataFrame(models)

# Converting to a Dict of ModelLists
models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    )
)

# Converting to a DataFrame
df = DataFrame(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dataframe.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}" href="#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,S}) where {T,S&lt;:AbstractDict}</code></pre><p>Implementation of <code>DataFrame</code> for a <code>ModelList</code> model with one time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dataframe.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:TimeStepTable}" href="#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:TimeStepTable}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,&lt;:TimeStepTable})</code></pre><p>Implementation of <code>DataFrame</code> for a <code>ModelList</code> model with several time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dataframe.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}" href="#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFormat(T::Type)</code></pre><p>Returns the data format of the type <code>T</code>. The data format is used to determine how to iterate over the data. The following data formats are supported:</p><ul><li><code>TableAlike</code>: The data is a table-like object, e.g. a <code>DataFrame</code> or a <code>TimeStepTable</code>. The data is iterated over by rows using the <code>Tables.jl</code> interface.</li><li><code>SingletonAlike</code>: The data is a singleton-like object, e.g. a <code>NamedTuple</code>   or a <code>TimeStepRow</code>. The data is iterated over by columns.</li></ul><p>The default implementation returns <code>TableAlike</code> for <code>AbstractDataFrame</code>, <code>TimeStepTable</code>, <code>AbstractVector</code> and <code>Dict</code>, <code>TreeAlike</code> for <code>Node</code>, <code>SingletonAlike</code> for <code>Status</code>, <code>ModelList</code>, <code>NamedTuple</code> and <code>TimeStepRow</code>.</p><p>The default implementation for <code>Any</code> throws an error. Users that want to use another input should define this trait for the new data format, e.g.:</p><pre><code class="language-julia hljs">PlantSimEngine.DataFormat(::Type{&lt;:MyType}) = TableAlike()</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo, DataFrames

julia&gt; PlantSimEngine.DataFormat(DataFrame)
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat([1, 2, 3])
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Dict(:a =&gt; 1, :b =&gt; 2))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))
PlantSimEngine.SingletonAlike()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/table_traits.jl#L6-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.DependencyGraph" href="#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})</code></pre><p>A graph of dependencies between models.</p><p><strong>Arguments</strong></p><ul><li><code>roots::T</code>: the root nodes of the graph.</li><li><code>not_found::Dict{Symbol,DataType}</code>: the models that were not found in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.DependencyTrait" href="#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DependencyTrait(T::Type)</code></pre><p>Returns information about the eventual dependence of a model <code>T</code> to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.</p><p>The following dependence traits are supported:</p><ul><li><code>TimeStepDependencyTrait</code>: Trait that defines whether a model can be parallelizable over time-steps for its computation.</li><li><code>ObjectDependencyTrait</code>: Trait that defines whether a model can be parallelizable over objects for its computation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.ObjectDependencyTrait" href="#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObjectDependencyTrait(::Type{T})</code></pre><p>Defines the trait about the eventual dependence of a model <code>T</code> to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.</p><p>The following dependency traits are supported:</p><ul><li><code>IsObjectDependent</code>: The model depends on other objects for its computation, it cannot be run in parallel.</li><li><code>IsObjectIndependent</code>: The model does not depend on other objects for its computation, it can be run in parallel.</li></ul><p>All models are object dependent by default (<em>i.e.</em> <code>IsObjectDependent</code>). This is probably not right for the majority of models, but:</p><ol><li>It is the safest default, as it will not lead to incorrect results if the user forgets to override this trait</li></ol><p>which is not the case for the opposite (i.e. <code>IsObjectIndependent</code>)</p><ol><li>It is easy to override this trait for models that are object independent</li></ol><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is object independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # false</code></pre><p>Define a model that is object dependent:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L135-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}" href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeStepDependencyTrait(::Type{T})</code></pre><p>Defines the trait about the eventual dependence of a model <code>T</code> to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.</p><p>The following dependency traits are supported:</p><ul><li><code>IsTimeStepDependent</code>: The model depends on other time-steps for its computation, it cannot be run in parallel.</li><li><code>IsTimeStepIndependent</code>: The model does not depend on other time-steps for its computation, it can be run in parallel.</li></ul><p>All models are time-step dependent by default (<em>i.e.</em> <code>IsTimeStepDependent</code>). This is probably not right for the  majority of models, but:</p><ol><li>It is the safest default, as it will not lead to incorrect results if the user forgets to override this trait</li></ol><p>which is not the case for the opposite (i.e. <code>IsTimeStepIndependent</code>)</p><ol><li>It is easy to override this trait for models that are time-step independent</li></ol><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other objects for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is time-step independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>Check if the model is parallelizable over time-steps:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # false</code></pre><p>Define a model that is time-step dependent:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()</code></pre><p>Check if the model is parallelizable over time-steps:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L19-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})" href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractArray{&lt;:ModelList})</code></pre><p>Copy an array-alike of <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)" href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractDict{N,&lt;:ModelList} where N)</code></pre><p>Copy a Dict-alike <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:ModelList" href="#Base.copy-Tuple{T} where T&lt;:ModelList"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::ModelList)
Base.copy(l::ModelList, status)</code></pre><p>Copy a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a>, eventually with new values for the status.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

# Create a model list:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# Copy the model list:
ml2 = copy(models)

# Copy the model list with new status:
ml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L329-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(component&lt;:ModelList, key::Symbol)
getindex(component&lt;:ModelList, key)</code></pre><p>Indexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

lm = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

lm[:var1] # Returns the value of the Tₗ variable
lm[2]  # Returns the status at the second time-step
lm[2][:var1] # Returns the value of Tₗ at the second time-step
lm[:var1][2] # Equivalent of the above

# output
16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/get_status.jl#L65-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}" href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_model_vars(x, models, type_promotion; init_fun=init_fun_default)</code></pre><p>Check which variables in <code>x</code> are not initialized considering a set of <code>models</code> and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.</p><p>This function needs to be implemented for each type of <code>x</code>. The default method works for  any Tables.jl-compatible <code>x</code> and for NamedTuples.</p><p>Careful, the function makes a copy of the input <code>x</code> if it does not list all needed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.check_dimensions-Tuple{Any, Any}" href="#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_dimensions(component,weather)
check_dimensions(status,weather)</code></pre><p>Checks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, PlantMeteo

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

# Creating a dummy weather:
w = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)

# Creating a dummy component:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=[15.0, 16.0], var2=0.3)
)

# Checking that the number of time-steps are compatible (here, they are, it returns nothing):
PlantSimEngine.check_dimensions(models, w) 

# Creating a dummy weather with 3 time-steps:
w = Weather([
    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)
])

# Checking that the number of time-steps are compatible (here, they are not, it throws an error):
PlantSimEngine.check_dimensions(models, w)

# output
ERROR: DimensionMismatch: Component status should have the same number of time-steps (2) than weather data (3).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/checks/dimensions.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}" href="#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}"><code>PlantSimEngine.convert_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)
convert_vars(type_promotion::Nothing, ref_vars)</code></pre><p>Convert the status variables to the type specified in the type promotion dictionary.</p><p><strong>Examples</strong></p><p>If we want all the variables that are Reals to be Float32, we can use:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

ref_vars = init_variables(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
)
type_promotion = Dict(Real =&gt; Float32)

PlantSimEngine.convert_vars(type_promotion, ref_vars.process3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L391-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.diff_vars-Tuple{Any, Any}" href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_vars(x, y)</code></pre><p>Returns the names of variables that have different values in x and y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.draw_guide-NTuple{5, Any}" href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_guide(h, w, prefix, isleaf, guides)</code></pre><p>Draw the line guide for one node of the dependency graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.draw_panel-NTuple{5, Any}" href="#PlantSimEngine.draw_panel-NTuple{5, Any}"><code>PlantSimEngine.draw_panel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_panel(node, graph, prefix, dep_graph_guides, parent; title=&quot;Soft-coupled model&quot;)</code></pre><p>Draw the panels for all dependencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.drop_process-Tuple{Any, Symbol}" href="#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drop_process(proc_vars, process)</code></pre><p>Return a new <code>NamedTuple</code> with the process <code>process</code> removed from the <code>NamedTuple</code> <code>proc_vars</code>.</p><p><strong>Arguments</strong></p><ul><li><code>proc_vars::NamedTuple</code>: the <code>NamedTuple</code> from which we want to remove the process <code>process</code>.</li><li><code>process::Symbol</code>: the process we want to remove from the <code>NamedTuple</code> <code>proc_vars</code>.</li></ul><p><strong>Returns</strong></p><p>A new <code>NamedTuple</code> with the process <code>process</code> removed from the <code>NamedTuple</code> <code>proc_vars</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; drop_process((a = 1, b = 2, c = 3), :b)
(a = 1, c = 3)

julia&gt; drop_process((a = 1, b = 2, c = 3), (:a, :c))
(b = 2,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/soft_dependencies.jl#L133-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.flatten_vars-Tuple{Any}" href="#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten_vars(vars)</code></pre><p>Return a set of the variables in the <code>vars</code> dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>vars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: a dict of process =&gt; symbols of inputs.</li></ul><p><strong>Returns</strong></p><p>A set of the variables in the <code>vars</code> dictionary.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; flatten_vars(Dict(:process1 =&gt; (:var1, :var2), :process2 =&gt; (:var3, :var4)))
Set{Symbol} with 4 elements:
  :var4
  :var3
  :var2
  :var1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/soft_dependencies.jl#L227-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.get_Ref_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing" href="#PlantSimEngine.get_Ref_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing"><code>PlantSimEngine.get_Ref_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Ref_i(node, attr, i&lt;:Nothing)
get_Ref_i(node, attr, i)</code></pre><p>Get reference to node attribute at ith value or value if <code>i&lt;:Nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/mtg/init_mtg_models.jl#L244-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}" href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_ts_kwargs(kwargs)</code></pre><p>By default, the function returns its argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}</code></pre><p>Takes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to <em>e.g.</em> give constant values for all time-steps for one variable.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">PlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/ModelList.jl#L293-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_variables_manual-Tuple{Any, Any}" href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_variables_manual(models...;vars...)</code></pre><p>Return an initialisation of the model variables with given values.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using PlantSimEngine

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

PlantSimEngine.init_variables_manual(status(models), (var1=20.0,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L298-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.object_parallelizable-Tuple{T} where T" href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">object_parallelizable(x::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>x</code> is parallelizable, i.e. if the model can be computed in parallel for different objects, or <code>false</code> otherwise. </p><p>The default implementation returns <code>false</code> for all models. If you develop a model that is parallelizable over objects, you should add a method to <a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> for your model.</p><p>Note that this method can also be applied on a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> directly, in which case it returns <code>true</code> if all models in the graph are parallelizable, and <code>false</code> otherwise.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other objects for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is object independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L205-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.parallelizable-Tuple{T} where T" href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallelizable(::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>T</code> or the whole dependency graph is parallelizable, <em>i.e.</em> if the model can be computed in parallel for different time-steps or objects. The default implementation returns <code>false</code> for all models.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over objects, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is parallelizable:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()

# Override the object dependency trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>Check if the model is parallelizable:</p><pre><code class="language-julia hljs">parallelizable(MyModel()) # true</code></pre><p>Or if we want to be more explicit:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel())
object_parallelizable(MyModel())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L254-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}" href="#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search_inputs_in_output(process, inputs, outputs)</code></pre><p>Return a dictionary with the soft dependencies of the processes in the dependency graph <code>d</code>. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.</p><p><strong>Arguments</strong></p><ul><li><code>process::Symbol</code>: the process for which we want to find the soft dependencies.</li><li><code>inputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}</code>: a dict of process =&gt; symbols of inputs per process.</li><li><code>outputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: a dict of process =&gt; symbols of outputs per process.</li></ul><p><strong>Details</strong></p><p>The inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.</p><p><strong>Returns</strong></p><p>A dictionary with the soft dependencies for the processes.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">in_ = Dict(
    :process3 =&gt; [:process3=&gt;(:var4, :var5), :process2=&gt;(:var1, :var3), :process1=&gt;(:var1, :var2)],
    :process4 =&gt; [:process4=&gt;(:var0,)],
    :process6 =&gt; [:process6=&gt;(:var7, :var9)],
    :process5 =&gt; [:process5=&gt;(:var5, :var6)],
)

out_ = Dict(
    :process3 =&gt; Pair{Symbol}[:process3=&gt;(:var4, :var6), :process2=&gt;(:var4, :var5), :process1=&gt;(:var3,)],
    :process4 =&gt; [:process4=&gt;(:var1, :var2)],
    :process6 =&gt; [:process6=&gt;(:var8,)],
    :process5 =&gt; [:process5=&gt;(:var7,)],
)

search_inputs_in_output(:process3, in_, out_)
(process4 = (:var1, :var2),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/soft_dependencies.jl#L160-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.soft_dependencies" href="#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">soft_dependencies(d::DependencyGraph)</code></pre><p>Return a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> with the soft dependencies of the processes in the dependency graph <code>d</code>. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.</p><p><strong>Arguments</strong></p><ul><li><code>d::DependencyGraph</code>: the hard-dependency graph.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Load the dummy models given as example in the package:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

# Create a model list:
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
)

# Create the hard-dependency graph:
hard_dep = hard_dependencies(models.models, verbose=true)

# Get the soft dependencies graph:
soft_dep = soft_dependencies(hard_dep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/soft_dependencies.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.timestep_parallelizable-Tuple{T} where T" href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_parallelizable(x::T)
timestep_parallelizable(x::DependencyGraph)</code></pre><p>Returns <code>true</code> if the model <code>x</code> is parallelizable, i.e. if the model can be computed in parallel over time-steps, or <code>false</code> otherwise.</p><p>The default implementation returns <code>false</code> for all models. If you develop a model that is parallelizable over time-steps, you should add a method to <a href="#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> for your model.</p><p>Note that this method can also be applied on a <a href="#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a> directly, in which case it returns <code>true</code> if all models in the graph are parallelizable, and <code>false</code> otherwise.</p><p><strong>See also</strong></p><ul><li><a href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable over time-steps, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>: Returns <code>true</code> if the model is parallelizable, and <code>false</code> otherwise.</li><li><a href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>: Defines the trait about the eventual dependence of a model to other time-steps for its computation.</li></ul><p><strong>Examples</strong></p><p>Define a dummy process:</p><pre><code class="language-julia hljs">using PlantSimEngine

# Define a test process:
@process &quot;TestProcess&quot;</code></pre><p>Define a model that is time-step independent:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# Override the time-step dependency trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>Check if the model is parallelizable over objects:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/traits/parallel_traits.jl#L86-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)</code></pre><p>Apply function <code>f</code> to <code>node</code>, and then its children (hard-dependency nodes).</p><p>Mutate the vector <code>var</code> by pushing a pair of the node process name and the result of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)</code></pre><p>Apply function <code>f</code> to <code>node</code>, visit its hard dependency nodes (if <code>visit_hard_dep=true</code>), and  then its soft dependency children.</p><p>Mutate the vector <code>var</code> by pushing a pair of the node process name and the result of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}" href="#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(graph::DependencyGraph, f::Function, visit_hard_dep=true)</code></pre><p>Traverse the dependency <code>graph</code> and apply the function <code>f</code> to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if <code>visit_hard_dep=true</code>), and then the children of the soft-dependencies.</p><p>Return a vector of pairs of the node and the result of the function <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

function f(node)
    node.value
end

include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;))

vars = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

graph = dep(vars)
traverse_dependency_graph(graph, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/dependencies/dependency_graph.jl#L66-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}" href="#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}"><code>PlantSimEngine.update_mtg_models!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)</code></pre><p>Update the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so <a href="#PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, &lt;:ModelList}, Any}"><code>init_mtg_models!</code></a> must be called before <code>update_mtg_models!</code>.</p><p>The values are updated only for node attributes in <code>to_init</code>. Those attributes must have several time-steps, <em>i.e.</em> indexable by 1:n time-steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/mtg/init_mtg_models.jl#L272-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel" href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables_typed(model)
variables_typed(model, models...)</code></pre><p>Returns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Including an example script that implements dummy processes and models:
include(joinpath(pkgdir(PlantSimEngine), &quot;examples/dummy.jl&quot;));

PlantSimEngine.variables_typed(Process1Model(1.0))
(var1 = Float64, var2 = Float64, var3 = Float64)

PlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())

# output
(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)</code></pre><p><strong>See also</strong></p><p><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/models_inputs_outputs.jl#L160-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status" href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vars_not_init_(st&lt;:Status, var_names)</code></pre><p>Get which variable is not properly initialized in the status struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/processes/model_initialisation.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.schema-Union{Tuple{TimeStepTable{T}}, Tuple{T}} where T&lt;:Status" href="#Tables.schema-Union{Tuple{TimeStepTable{T}}, Tuple{T}} where T&lt;:Status"><code>Tables.schema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Tables.schema(m::TimeStepTable{Status})</code></pre><p>Create a schema for a <code>TimeStepTable{Status}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/e4dda58cf0df6c893fa4efdebc745ae8793b0321/src/component_models/TimeStepTable.jl#L51-L55">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FAQ/translate_a_model/">« I want to use PlantSimEngine for my model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 25 April 2023 16:52">Tuesday 25 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
