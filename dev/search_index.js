var documenterSearchIndex = {"docs":
[{"location":"design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to ease the process of modelling and simulation of plants, soil and atmosphere, or really any system (e.g. agroforestry system, agrivoltaics...). PlantSimEngine.jl aims at being the backbone tool for developing Functional-Structural Plant Models (FSPM) and crop models without the hassle of performance and other computer-science considerations.  ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))),\"examples\",\"light.jl\"))\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nleaf = ModelList(light_interception = Beer(0.5), status = (LAI = 2.0,))\nlight_interception!(leaf, meteo)","category":"page"},{"location":"design/#Definitions","page":"Design","title":"Definitions","text":"","category":"section"},{"location":"design/#Processes","page":"Design","title":"Processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A process is \"declared\", meaning we just define a process using @gen_process_methods, and then we implement models for its simulation. Declaring a process automatically generates three functions, for example light_interception from PlantBiophysics.jl has:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"light_interception: the generic function that makes a copy of the modelList and returns directly the status (not very efficient but easy to use)\nlight_interception!: the faster, mutating, generic function. Here the user need to extract the outputs from the status after the simulation (note the ! at the end of the name)\nlight_interception!_: the basic implementation with a method for each model. PlantSimEngine uses multiple dispatch to choose the right method based on the model type. This is the function we need to extend when implementing a new model for the process.","category":"page"},{"location":"design/#Models","page":"Design","title":"Models","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/light.jl.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Models can use three types of entries:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters are constant values that are used by the model to compute its outputs. Meteorological information are values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. Variables are either used or computed by the model and can optionally be initialized before the simulation. Constants are constant values, usually common between models, e.g. the universal gas constant. And extras are just extra values that can be used by a model, it is for example used to pass the current node of the Multi-Scale Tree Graph to be able to e.g. retrieve children or ancestors values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users can choose which model is used to simulate a process using the ModelList structure. ModelList is also used to store the values of the parameters, and to initialize variables.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example let's instantiate a ModelList with the Beer-Lambert model of light extinction. The model is implemented with the Beer structure and has only one parameter: the extinction coefficient (k).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine\n# Including the script defining light_interception and Beer:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))),\"examples\",\"light.jl\"))\nModelList(light_interception = Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"What happened here? We provided an instance of a model to the process it simulates. The model is provided as a keyword argument to the ModelList, with the process name given as the keyword, and the instantiated model as the value. The keyword must match exactly the name of the process it simulates because it is used to match the models to the function than run its simulation, e.g. light_interception for the light_interception process.","category":"page"},{"location":"design/#Parameters","page":"Design","title":"Parameters","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A parameter is a constant value that is used by a model to compute its outputs. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer-Lambert model is implemented with the Beer structure, which has only one field: k. We can see that using fieldnames:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(Beer)","category":"page"},{"location":"design/#Variables-(inputs,-outputs)","page":"Design","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Variables are either input or outputs (i.e. computed) by models, and can optionally be initialized before the simulation. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Hence, ModelList objects stores two fields:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(ModelList)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first field is a list of models associated to the processes they simulate. The second, :status, is used to hold all inputs and outputs of our models, called variables. For example the Beer model needs the leaf area index (LAI, m^{2} \\cdot m^{-2}) to run.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can see which variables are needed as inputs using inputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine\ninputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can also see the outputs of the model using outputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"outputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"If we instantiate a ModelList with the Beer-Lambert model, we can see that the :status field has two variables: LAI and PPDF. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_interception = Beer(0.5))\nkeys(m.status)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_interception = Beer(0.5))\n\nto_initialize(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"(m[:LAI], m[:PPFD])","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Uninitialized variables have the value returned by typemin(), e.g. -Inf for Float64:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"typemin(Float64)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns the variables that are needed by the model to run, but to_initialize returns the variables that are needed by the model to run and that are not initialized. Also to_initialize is more clever when coupling models (see below).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can initialize the variables by providing their values to the status at instantiation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_interception = Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or after instantiation using init_status!:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_interception = Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"is_initialized(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Some variables are inputs of models, but outputs of other models. When we couple models, we have to be careful to initialize only the variables that are not computed, and PlantSimEngine.jl is here to help users in this task.","category":"page"},{"location":"design/#Climate-forcing","page":"Design","title":"Climate forcing","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in Â°C), Rh (relative humidity, 0-1) and Wind (the wind speed in m s-1). We can declare such conditions like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"More details are available from the package documentation.","category":"page"},{"location":"design/#Simulation","page":"Design","title":"Simulation","text":"","category":"section"},{"location":"design/#Simulation-of-processes","page":"Design","title":"Simulation of processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Making a simulation is rather simple, we simply use the function with the name of the process we want to simulate, for example PlantBiophysics.jl implements:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"stomatal_conductance for the stomatal conductance\nphotosynthesis for the photosynthesis\nenergy_balance for the energy balance\nlight_interception for the energy balance","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nAll functions exist in a mutating and a non-mutating form. Just add ! at the end of the name of the function (e.g. energy_balance!) to use the mutating form for speed! ðŸš€","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The call to the function is the same whatever the model you choose for simulating the process. This is some magic allowed by PlantSimEngine.jl! A call to a function is made as follows:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"stomatal_conductance(model_list, meteo)\nphotosynthesis(model_list, meteo)\nenergy_balance(model_list, meteo)\nlight_interception(model_list, meteo)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The ModelList should be initialized for the given process before calling the function. See Variables (inputs, outputs) for more details.","category":"page"},{"location":"design/#Example-simulation","page":"Design","title":"Example simulation","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"For example we can simulate the light_interception of a leaf like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\n# Including the script defining light_interception and Beer:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))),\"examples\",\"light.jl\"))\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\n\nleaf = ModelList(\n    light_interception = Beer(0.5), \n    status = (LAI = 2.0,)\n)\n\nlight_interception!(leaf, meteo)\n\nleaf[:PPFD]","category":"page"},{"location":"design/#Outputs","page":"Design","title":"Outputs","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract the simulation outputs of a model list using the status function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nGetting the status is only useful when using the mutating version of the function (e.g. light_interception!), as the non-mutating version returns the output directly.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The status usually is stored in a TimeStepTable structure from PlantMeteo.jl with each time step being a Status, but it can be any Tables.jl structure, such as a DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's look at the status of our previous simulated leaf:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can extract the value of one variable using the status function, e.g. for the light intercepted:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf, :PPFD)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or similarly using the dot syntax:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf.status.PPFD","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or much simpler (and recommended), by indexing directly the model list:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf[:PPFD]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Another simple way to get the results is to transform the outputs into a DataFrame:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using DataFrames\nDataFrame(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThe output from DataFrame is adapted to the kind of simulation you did: one row per time-step, and per component models if you simulated several.","category":"page"},{"location":"design/#Model-coupling","page":"Design","title":"Model coupling","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to make model coupling painless for the modeler, and for the user. The modeler implements a model, and if the model needs another model to compute one of its variable, the modeler only needs to call the generic function for the process, and then the user choose which model is used for this computation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"See Model coupling for users and Model coupling for modelers for more details.","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Model-coupling-for-modelers","page":"Modelers","title":"Model coupling for modelers","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"To come. We will present an example model coupling here (e.g. FVCB, or a custom model)","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-process","page":"Processes","title":"Implement a new process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine\nusing PlantMeteo\nPlantSimEngine.@gen_process_methods growth","category":"page"},{"location":"extending/implement_a_process/#Introduction","page":"Processes","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. Let's learn about how to implement a new process with a simple example: implementing a growth model.","category":"page"},{"location":"extending/implement_a_process/#Implement-a-process","page":"Processes","title":"Implement a process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To implement a new process, we need to define the generic methods associated to it that helps run its simulation for:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"one or several time-steps\none or several objects\nan MTG from MultiScaleTreeGraph","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"...and all the above with a mutating function and a non-mutating one.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This is a lot of work! But fortunately PlantSimEngine provides a macro to generate all of the above: @gen_process_methods.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This macro takes only one argument: the name of the non-mutating function.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So for example all the photosynthesis methods in the PlantBiophysics.jl package are created using just this tiny line of code:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@gen_process_methods photosynthesis","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"If we want to simulate the growth of a plant, we could add a new process called growth. To create the generic functions to simulate the growth we would do:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@gen_process_methods \"growth\"","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"And that's it! Note that the function guides you in the steps you can make after creating a process. Let's break it up here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So what you just did is to create a new process called growth. By doing so, you created three new functions:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"growth!: the mutating function\ngrowth: the non-mutating function\ngrowth!_: the function that actually make the computation. You'll have to implement methods for each model you need, else it will not work.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now users can call growth! and growth on any number of time steps or objects, even on MTGs, and PlantSimEngine will handle everything.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Creating the process also defined a default abstract type for the process that is used as a supertype for the models types. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model. So in our case our process abstract type is named AbstractGrowthModel.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"note: Note\nIf you don't understand what a supertype is, no worries, you'll understand in the examples below","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-model-for-the-process","page":"Processes","title":"Implement a new model for the process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To better understand how models are implemented, you can read the detailed instructions from the previous section. But for the sake of completeness, we'll implement a growth model here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This growth model needs the carbohydrate assimilation that we could compute using e.g. the coupled energy balance process from PlantBiophysics.jl. Then the model removes the maintenance respiration and the growth respiration from that source of carbon, and increments the leaf biomass by the remaining carbon offer.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Let's implement this model below:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"# Let's import our package:\nusing PlantSimEngine\n# PlantMeteo for using the meteorology-related functions:\nusing PlantMeteo\n\n# Make the struct to hold the parameters, with its documentation:\n\"\"\"\n    DummyGrowth(Rm_factor, Rg_cost)\n    DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the leaf biomass growth of a plant.\n\n# Arguments\n\n- `Rm_factor`: the fraction of assimilation that goes into maintenance respiration\n- `Rg_cost`: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\"\"\"\nstruct DummyGrowth{T} <: AbstractGrowthModel\n    Rm_factor::T\n    Rg_cost::T\nend\n\n# Note that DummyGrowth is a subtype of AbstractGrowthModel, this is important\n\n# Instantiate the struct with default values + kwargs:\nfunction DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n    DummyGrowth(promote(Rm_factor,Rg_cost)...)\nend\n\n# Define inputs:\nfunction PlantSimEngine.inputs_(::DummyGrowth)\n    (A=-999.99,)\nend\n\n# Define outputs:\nfunction PlantSimEngine.outputs_(::DummyGrowth)\n    (Rm=-999.99, Rg=-999.99, leaf_allocation=-999.99, leaf_biomass=0.0)\nend\n\n# Tells Julia what is the type of elements:\nBase.eltype(x::DummyGrowth{T}) where {T} = T\n\n# Implement the growth model:\nfunction growth!_(::DummyGrowth, models, status, meteo, constants=Constants(), extra=nothing)\n\n    # The maintenance respiration is simply a factor of the assimilation:\n    status.Rm = status.A * models.growth.Rm_factor\n\n    # Let's say that all carbon is allocated to the leaves:\n    status.leaf_allocation = status.A - status.Rm\n\n    # And that this carbon is allocated with a cost (growth respiration Rg):\n    status.Rg = 1 - (status.leaf_allocation / models.growth.Rg_cost)\n\n    status.leaf_biomass = status.leaf_biomass + status.leaf_allocation - status.Rg\nend","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now we can make a simulation as usual:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        # Our process and associated model:\n        growth = DummyGrowth(),\n        status = (A = 20.0,)\n    )\n\ngrowth!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"We can also start the simulation later when the plant already has some biomass by initializing the leaf_biomass:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        growth = DummyGrowth(),\n        status = (A = 20.0, leaf_biomass = 2400.0)\n    )\n\ngrowth!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_model/#model_implementation_page","page":"Models","title":"Model implementation in 5 minutes","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"using PlantSimEngine\n@gen_process_methods \"light_interception\" verbose = false\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/#Introduction","page":"Models","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.","category":"page"},{"location":"extending/implement_a_model/#Inspiration","page":"Models","title":"Inspiration","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you want to implement a new model, the best way to do it is to start from another implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For a complete example, you can look at the code in PlantBiophysics.jl, were you will find e.g. a photosynthesis model, with the implementation of the FvCB model in this Julia file: src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"extending/implement_a_model/#Requirements","page":"Models","title":"Requirements","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In those files, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see Implement a new process).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In this page, we'll just implement a model for a process that exists already: the light interception. This process is defined in PlantBiophysics.jl, but also in an example script in this package here: examples/light.jl.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We can include this file like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"include(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"light.jl\"))","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But instead of just using it, we will review the script line by line.","category":"page"},{"location":"extending/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Models","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"extending/implement_a_model/#The-process","page":"Models","title":"The process","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We declare the light interception process at l.7 using @gen_process_methods: ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"@gen_process_methods \"light_interception\" verbose = false","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"See Implement a new process for more details on how that works and how to use the process.","category":"page"},{"location":"extending/implement_a_model/#The-structure","page":"Models","title":"The structure","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first thing to do to implement a model is to define a structure.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The purpose of the structure is two-fold:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"hold the parameter values\ndispatch to the right method when calling the process function","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The structure of the model (or type) is defined as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first line defines the name of the model (Beer), which is completely free, except it is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We also can see that we define the Beer structure as a subtype of AbstractLight_InterceptionModel. This step is very important as it tells to the package what kind of process the model simulates. AbstractLight_InterceptionModel is automatically created when defining the process \"light_interception\".","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In our case, it tells us that Beer is a model to simulate the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Then comes the parameters names, and their types. The type of the parameters is given by the user at instantiation in our example. This is done using the T notation as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"we say that our structure Beer is a parameterized struct by putting T in between brackets after the name of the struct\nWe put ::T after our parameter name in the struct. This way Julia knows that our parameter will be of type T.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The T is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But why not forcing the type such as the following:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Well, you can do that. But you'll lose a lot of the magic Julia has to offer this way.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For example a user could use the Particles type from MonteCarloMeasurements.jl to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.","category":"page"},{"location":"extending/implement_a_model/#The-method","page":"Models","title":"The method","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The models are implemented in a function named after the process and a \"!_\" as a suffix. The exclamation point is used in Julia to tell users the function is mutating, i.e. it modifies its input.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Your implementation should always modify the input status and return nothing. This ensures that models compute fast. The \"_\" suffix is used to tell users that this is the internal implementation, which is only used by modelers.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Remember that PlantSimEngine only exports the generic functions of the processes to users because they are the one that handles every other details, such as checking that the object is correctly initialized, and applying the computations over objects and time-steps. This is nice because as a developer you don't have to deal with those details, and you can just concentrate on your implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"However, you have to remember that if your model calls another one, you'll have to use the internal implementation directly to avoid the overheads of the generic functions (you don't want all these checks).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So if you want to implement a new light interception model, you have to make your own method for the light_interception!_ function. ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nWe need to import all the functions we need to use or extend, so Julia knows we are extending the methods from PlantSimEngine, and not defining our own functions. To do so, we prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So let's do it! Here is our own implementation of the light interception for a ModelList component models:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function light_interception!_(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first argument (::Beer) means this method will only execute when the function is called with a first argument that is of type Beer. This is our way of telling Julia that this method is implementing the Beer model for the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"An important thing to note is that our variables are stored in different structures:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"models: lists the processes and the models parameters (we use kfrom Beer here using models.light_interception.k)\nmeteo: the micro-climatic conditions\nstatus: the input and output variables of the models\nconstants: any constants given as a struct or a NamedTuple\nextras: any other value or object (e.g. it is used to pass the node when computing MTGs)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"note: Note\nThe micro-meteorological conditions are always given for one time-step inside the models methods, so they are always of Atmosphere type. The Tables.jl type (e.g. TimeStepTable or DataFrame) conditions are handled earlier by the generic functions, i.e. light_interception() and light_interception!(), not light_interception!_().","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK ! So that's it ? Almost. One last thing to do is to define a method for inputs/outputs so that PlantSimEngine knows which variables are needed for our model, and which it computes. Remember that the actual model is implemented for light_interception!_, so we have to tell PlantSimEngine which ones are needed, and what are their default value:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Inputs: :LAI, the leaf area index (mÂ² mâ»Â²)\nOutputs: :PPFD, the photosynthetic photon flux density (Î¼mol mâ»Â² sâ»Â¹)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here is how we communicate that to PlantSimEngine:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (PPFD=-Inf,)\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Note that both function end with an \"_\". This is because these functions are internal, they will not be called by the users directly. Users will use inputs and outputs instead, which call inputs_ and outputs_, but stripping out the default values.","category":"page"},{"location":"extending/implement_a_model/#The-utility-functions","page":"Models","title":"The utility functions","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Before running a simulation, you can do a little bit more for your implementation (optional).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"First, you can add a method for type promotion. It wouldn't make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To add type promotion to Beer2 we would do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function Beer2(k,x)\n    Beer2(promote(k,x))\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer2(0.6,2)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You don't see a problem? Well your users won't either. But there's one: Beer2 is a parametric type, so all fields share the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this force the user to give all parameters with the same type.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"And in our example above, the user provides 0.6 for k, which is a Float64, and 2 for x, which is an Int. ANd if you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert 2 to 2.0.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of k. So we can provide a default value like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer() = Beer(0.6)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now the user can call Beer with zero value, and k will default to 0.6.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Another useful thing to provide to the user is the ability to instantiate your model type with keyword values. You can do it by adding the following method:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(;k) = Beer(k)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Did you notice the ; before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call Beer like this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(k = 0.7)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"One more thing to implement is a method for the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run (i.e. if your model is coupled to another model).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The last optional thing to implement is a method for the eltype function:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Base.eltype(x::Beer{T}) where {T} = T","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This one helps Julia to know the type of the elements in the structure, and make it faster.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK that's it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue so I can improve it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: DOI)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine defines a framework for declaring processes and implementing associated models for their simulation. The package focuses on key aspects of simulation and modelling:","category":"page"},{"location":"","page":"Home","title":"Home","text":"easy definition of new processes, which can really be any process such as light interception, photosynthesis, growth, soil water transfer...\neasy, interactive prototyping of models, with constraints to help users avoid errors, but sensible defaults to avoid over-complicating the model writing process\nno hassle, the package manages automatically input and output variables, time-steps, objects, model coupling, and model switching\n(very) fast computing, think of 100th of nanoseconds for the full energy balance of a leaf (see PlantBiophysics.jl that uses PlantSimEngine)\neasily scalable, with methods for computing over objects, time-steps and even Multi-Scale Tree Graphs\ncomposable: use Unitful to propagate units, use MonteCarloMeasurements.jl to propagate measurement error","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! ðŸ˜ƒ","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Users","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls the stomatal_conductance_ function at some point. Note that it does not force any model for its computation, just the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We provide an example script that implements three dummy processes in examples/dummy. We also provide an example model implementation for each, that makes a sequential coupling, meaning that the third model uses the second one, which uses the first one.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"tip: Tip\nModel coupling is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is coupled to a photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Back to our example, we have three processes called \"process1\", \"process2\" and \"process3\". Then we have one model implementation for each, called Process1Model, Process2Model and Process3Model. So in practice, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's include this script so we can play around:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"include(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"tip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Here is how we can make the models coupling:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    process1 = Process1Model(2.0), \n    process2 = Process2Model(),\n    process3 = Process3Model()\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Note that the user only declares the models, not the way the models are coupled, because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Now the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their coupling.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"For example Process1Model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Process1Model(2.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"And the Process2Model model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"outputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"So considering those two models, we only need var1 and var2 to be initialized as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    process1 = Process1Model(2.0), \n    process2 = Process2Model(),\n    process3 = Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    process1 = Process1Model(2.0), \n    process2 = Process2Model(),\n    process3 = Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nprocess3(m, meteo)","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#API-documentation","page":"API","title":"API documentation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\n# Private = false","category":"page"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:ModelList","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::T) where {T<:ModelList}\n\nGeneric implementation of DataFrame for a single ModelList model.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:Union{AbstractArray{<:ModelList}, ModelList}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:AbstractDict}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:TimeStepTable}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,<:TimeStepTable})\n\nImplementation of DataFrame for a ModelList model with several time steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tâ‚—=[25.0, 26.0],\n    PPFD=[1000.0, 1200.0],\n    Câ‚›=[400.0, 400.0],\n    Dâ‚—=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tâ‚—=25.0, PPFD=1000.0, Câ‚›=400.0, Dâ‚—=1.0),\n        Status(Tâ‚—=26.0, PPFD=1200.0, Câ‚›=400.0, Dâ‚—=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.AbstractModel","page":"API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.ModelList","page":"API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    init_fun::Function=init_fun_default,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame).\n\ninit_fun: a function that initializes the status based on a vector of NamedTuples (see details).\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nThe argument init_fun is set by default to init_fun_default which initializes the status with a TimeStepTable of Status structures.\n\nIf you change init_fun by another function, make sure the type you are using (i.e. in place of TimeStepTable)  implements the Tables.jl interface (e.g. DataFrame does). And if you still use TimeStepTable but only change Status, make sure the type you give is indexable using the dot synthax (e.g. x.var).\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n);\n\ntypeof(models)\n\n# output\n[ Info: Some variables must be initialized before simulation: (process3 = (:var1, :var2),) (see `to_initialize()`)\nModelList{NamedTuple{(:process1, :process2, :process3), Tuple{Process1Model, Process2Model, Process3Model}}, TimeStepTable{Status{(:var4, :var6, :var5, :var1, :var2, :var3), NTuple{6, Base.RefValue{Float64}}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to typemin(Type), i.e. -Inf for floating point numbers. This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\nto_initialize(models)\n# output\n(process3 = (:var1, :var2),)\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nprocess3!(models,meteo)\n\nmodels[:var6]\n\n# output\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3),\n    type_promotion = Dict(Float64 => Float32)\n)\n\n# We used `type_promotion` to force the status into Float32:\n[typeof(models[i][1]) for i in keys(status(models))]\n\n# output\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0f0, var2=0.3f0),\n    type_promotion = Dict(Float64 => Float32)\n)\n\n# We used `type_promotion` to force the status into Float32:\n[typeof(models[i][1]) for i in keys(status(models))]\n\n# output\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\nWe can also use DataFrame as the status type:\n\nusing DataFrames\ndf = DataFrame(:var1 => [13.747, 13.8], :var2 => [1.0, 1.0])\nm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=df,\n    init_fun=x -> DataFrame(x)\n)\n\n# Note that we use `init_fun` to force the status into a `DataFrame`,\n# otherwise it would be automatically converted into a `TimeStepTable{Status}`.\n\nstatus(m)\n\n# output\n2Ã—6 DataFrame\n Row â”‚ var4     var6     var5     var1     var2     var3    \n     â”‚ Float64  Float64  Float64  Float64  Float64  Float64 \nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1 â”‚    -Inf     -Inf     -Inf   13.747      1.0     -Inf\n   2 â”‚    -Inf     -Inf     -Inf   13.8        1.0     -Inf\n\nNote that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Status","page":"API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> st = Status(Râ‚›=13.747, sky_fraction=1.0, d=0.03, PPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Râ‚›]\n13.747\n\njulia> st.Râ‚›\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Râ‚›] = 20.0\n20.0\n\njulia> st.Râ‚› = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:ModelList","page":"API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tâ‚— variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tâ‚— at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.EF-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are unitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x (please do it if you need it).\n\nCareful, the function mutates x in place for performance. We don't put the ! in the name just because it also returns it (impossible to mutate when x is nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.check_dimensions-Union{Tuple{A}, Tuple{T}, Tuple{T, TimeStepTable{A}}} where {T<:TimeStepTable, A<:PlantMeteo.AbstractAtmosphere}","page":"API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status should have the same number of time-steps (2) than weather data (3).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}","page":"API","title":"PlantSimEngine.convert_vars","text":"convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)\nconvert_vars(type_promotion::Nothing, ref_vars)\n\nConvert the status variables to the type specified in the type promotion dictionary.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dep-Tuple{}","page":"API","title":"PlantSimEngine.dep","text":"dep(models::ModelList; verbose::Bool=true)\n\nGet the model dependency tree given a ModelList. If one tree is returned, then all models are coupled. If several trees are returned, then only the models inside each tree are coupled, and the models in different trees are not coupled.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(vars)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dr-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmottâ€™s refined index of agreement dáµ£. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_dependency_tree-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.draw_dependency_tree","text":"draw_dependency_tree(\n    tree, node;\n    guides_style::String=TERM_THEME[].tree_guide_style,\n    dep_tree_guides=(space=\" \", vline=\"â”‚\", branch=\"â”œ\", leaf=\"â””\", hline=\"â”€\")\n)\n\nDraw the dependency tree.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency tree.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_panel-NTuple{4, Any}","page":"API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, tree, prefix, dep_tree_guides)\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_attr_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Nothing","page":"API","title":"PlantSimEngine.get_attr_i","text":"get_attr_i(node, attr, i<:Nothing)\nget_attr_i(node, attr, i)\n\nGet node attribute at ith value or only value if i<:Nothing\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tâ‚—=[25.0, 26.0], PPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_mtg_models!","page":"API","title":"PlantSimEngine.init_mtg_models!","text":"init_mtg_models!(\n    mtg::MultiScaleTreeGraph.Node,\n    models::Dict{String,<:ModelList},\n    i=nothing;\n    verbose=true,\n    attr_name=:models\n)\n\ninitialize the components of an MTG (i.e. nodes) with the corresponding models.\n\nThe function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.\n\nArguments\n\nmtg::MultiScaleTreeGraph.Node: the MTG tree.\nmodels::Dict{String,ModelList}: a dictionary of models named by components names\ni=nothing: the time-step to initialize. If nothing, initialize all the time-steps.\nverbose = true: return information during the processes\nattr_name = :models: the node attribute name used to store the models\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph\n\n# Make an MTG:\nmtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\nleaf = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"<\", \"Leaf\", 1, 2))\nleaf[:var1] = [15.0, 16.0]\nleaf[:var2] = 0.3\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Checking which variables are needed for our models:\n[component => to_initialize(model) for (component, model) in models]\n# OK we need to initialize Râ‚›, sky_fraction and the PPFD\n\n# We could compute them directly inside the MTG from available variables instead of \n# giving them as initialisations:\ntransform!(\n    mtg,\n    :var1 => (x -> x .+ 2.0) => :var2,\n    ignore_nothing = true\n)\n\n# Initialising all components with their corresponding models and initialisations at time-step 1:\ninit_mtg_models!(mtg, models, 1)\n# Note that this is possible only because the initialisation values are found in the MTG.\n# If the initialisations are constant values between components, we can directly initialize\n# them in the models definition (as we do in the begining).\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nIntialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.pre_allocate_attr!","text":"pre_allocate_attr!(node, nsteps; attr_name = :models)\n\nPre-allocate the node attributes based on the status of a component model and a given number of simulation steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pull_status!-Tuple{Any}","page":"API","title":"PlantSimEngine.pull_status!","text":"pull_status!(node)\n\nCopy the status of a node's component models (e.g. the outputs of a [ModelList]@ref simulation) into the MTG attributes. This function is used when we need to compute further the simulation outputs with e.g. transform! (see MultiScaleTreeGraph.jl docs).\n\nNotes\n\nCarefull, this function makes a copy, so the values are then present at two locations (can take a lot of memory space if using several plants).\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph\n\n# Make an MTG:\nmtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\nleaf = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"<\", \"Leaf\", 1, 2))\nleaf[:var1] = [15.0, 16.0]\nleaf[:var2] = 0.3\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Initialising all components with their corresponding models and initialisations:\ninit_mtg_models!(mtg, models, 1)\n\n# Make a simulation\ntransform!(mtg, :models => (x -> process3!(x, meteo)), ignore_nothing = true)\n# Pull the simulation results into the MTG attributes:\ntransform!(mtg, PlantSimEngine.pull_status!)\n# Now the simulated variables are available from the MTG attributes field:\nnames(mtg)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pull_status_one_step!-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.pull_status_one_step!","text":"pull_status_one_step!(node, step; attr_name = :models)\n\nCopy the status of a node's ModelList (i.e. the outputs of the simulations) into the pre-allocated MTG attributes, i.e. one value per step.\n\nSee pre_allocate_attr! for the pre-allocation step.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency tree d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of inputs.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => (:var4, :var5, :var1, :var2, :var3), \n    :process4 => (:var0,), \n    :process6 => (:var7,), \n    :process5 => (:var6, :var5)\n)\n\nout_ = Dict(\n    :process3 => (:var4, :var6, :var5, :var3), \n    :process4 => (:var1, :var2), \n    :process6 => (:var8,), \n    :process5 => (:var7,)\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.soft_dependencies-Tuple{Dict{Symbol, PlantSimEngine.HardDependencyNode}}","page":"API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyTree)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency tree d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyTree: the dependency tree.\n\nReturns\n\nsoft_dep::Dict{Symbol, Vector{Any}}: a dictionary with the soft dependencies of the processes \n\nin the dependency tree d.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency tree:\nhard_dep, dep_not_found = hard_dependencies(vars, verbose=verbose)\n\n# Get the soft dependencies tree:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.status-Tuple{Any}","page":"API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(v::T, vars...) where T <: Union{Missing,AbstractModel}\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyTree)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"))\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}","page":"API","title":"PlantSimEngine.update_mtg_models!","text":"update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)\n\nUpdate the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so init_mtg_models! must be called before update_mtg_models!.\n\nThe values are updated only for node attributes in to_init. Those attributes must have several time-steps, i.e. indexable by 1:n time-steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{Module}","page":"API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n5-element Vector{Symbol}:\n :var1\n :var2\n :var3\n :var4\n :var5\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(dirname(dirname(pathof(PlantSimEngine))), \"examples\", \"dummy.jl\"));\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"API/#Tables.schema-Union{Tuple{TimeStepTable{T}}, Tuple{T}} where T<:Status","page":"API","title":"Tables.schema","text":"Tables.schema(m::TimeStepTable{Status})\n\nCreate a schema for a TimeStepTable{Status}.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.@gen_process_methods-Tuple{Any, Vararg{Any}}","page":"API","title":"PlantSimEngine.@gen_process_methods","text":"@gen_process_methods(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and standard functions for a process, along with  their documentation and prints out a little tutorial about how to implement a model.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe three following functions are also generated (replace \"process\" by your own process name):\n\nprocess: a non mutating function that makes a copy of the object\nprocess!: a mutating function that updates the object status\nprocess!_: the actual workhorse function that does the computation, and is called by the \n\ntwo previous functions under the hood. Modelers implement their own method for this function  for their own model types.\n\nThe two first functions have several methods:\n\nThe base method that runs over one time-step and one object.\nThe method applying the computation over several objects (e.g. all leaves of a plant)\n\nin an Array\n\nThe same method over a Dict(-alike) of objects\nThe method that applies the computation over several meteo time steps and\n\npossibly several objects\n\nA method for calling the process without any meteo (e.g. for fitting)\nA method to apply the above over MTG nodes (see details)\n\nThe first argument to @gen_process_methods is the new process name,  the second is any additional documentation that should be added  to the process and process! functions, and the third determines whether  the short tutorial should be printed or not.\n\nExamples\n\n@gen_process_methods \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"}]
}
