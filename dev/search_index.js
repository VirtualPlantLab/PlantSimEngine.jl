var documenterSearchIndex = {"docs":
[{"location":"extending/inputs/#Input-types","page":"Input types","title":"Input types","text":"","category":"section"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"run! usually takes two inputs: a ModelList and data for the meteorology. The data for the meteorology is usually provided for one time step using an Atmosphere, or for several time-steps using a TimeStepTable{Atmosphere}. The ModelList can also be provided as a singleton, or as a vector or dictionary of.","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"run! knows how to handle these data formats via the PlantSimEngine.DataFormat trait (see this blog post to learn more about traits). For example, we tell PlantSimEngine that a TimeStepTable should be handled like a table by implementing the following trait:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"If you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:MyTableFormat}) = TableAlike()","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"There are two other traits available: SingletonAlike for a data format representing one time-step only, and TreeAlike for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).","category":"page"},{"location":"extending/inputs/#Special-considerations-for-new-input-types","page":"Input types","title":"Special considerations for new input types","text":"","category":"section"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on your use-cases. ","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"For example if you use models that need to get data from a different time step (e.g. a model that needs to get the previous day's temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"To do so, you need to implement the following methods for your structure that defines your rows:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"Base.parent: return the parent table of the row, e.g. the full DataFrame\nPlantMeteo.rownumber: return the row number of the row in the parent table, e.g. the row number in the DataFrame\n(Optionnally) PlantMeteo.row_from_parent(row, i): return row i from the parent table, e.g. the row i from the DataFrame. This is only needed if you want high performance, the default implementation calls Tables.rows(parent(row))[i].","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"compat: Compat\nPlantMeteo.rownumber is temporary. It soon will be replaced by DataAPI.rownumber instead, which will be also used by e.g. DataFrames.jl. See this Pull Request.","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-process","page":"Processes","title":"Implement a new process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine\nusing PlantMeteo\nPlantSimEngine.@process growth","category":"page"},{"location":"extending/implement_a_process/#Introduction","page":"Processes","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. Let's learn about how to implement a new process with a simple example: implementing a growth model.","category":"page"},{"location":"extending/implement_a_process/#Implement-a-process","page":"Processes","title":"Implement a process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To implement a new process, we need to define an abstract structure that will help us associate the models to this process. We also need to generate some boilerplate code, such as a method for the process function. Fortunately, PlantSimEngine provides a macro to generate all that at once: @process. This macro takes only one argument: the name of the process.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"For example, the photosynthesis process in PlantBiophysics.jl is declared using just this tiny line of code:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@process \"photosynthesis\"","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"If we want to simulate the growth of a plant, we could add a new process called growth:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@process \"growth\"","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"And that's it! Note that the function guides you in the steps you can make after creating a process. Let's break it up here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"tip: Tip\nIf you know what you're doing, you can directly define a process by hand just by defining an abstract type that is a subtype of AbstractModel:abstract type AbstractGrowthModel <: PlantSimEngine.AbstractModel endAnd by adding a method for the process_ function that returns the name of the process:PlantSimEngine.process_(::Type{AbstractGrowthModel}) = :growthBut this way, you don't get the nice tutorial adapted to your process 🙃.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So what you just did is to create a new process called growth. By doing so, you created a new abstract structure called AbstractGrowthModel, which is used as a supertype of the models. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"note: Note\nIf you don't understand what a supertype is, no worries, you'll understand by seeing the examples below","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-model-for-the-process","page":"Processes","title":"Implement a new model for the process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To better understand how models are implemented, you can read the detailed instructions from the next section. But for the sake of completeness, we'll implement a growth model here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This growth model needs the absorbed photosynthetically active radiation (aPPFD) as an input, and outputs the assimilation, the maintenance respiration, the growth respiration, the biomass increment and the biomass. The assimilation is computed as the product of the aPPFD and the light use efficiency (LUE). The maintenance respiration is a fraction of the assimilation, and the growth respiration is a fraction of the net primary productivity (NPP), which is the assimilation minus the maintenance respiration. The biomass increment is the NPP minus the growth respiration, and the biomass is the sum of the biomass increment and the previous biomass. Note that the previous biomass is always available in the status as long as you don't modify it.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"The model is available in the example script ToyAssimGrowthModel.jl, and is reproduced below:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"# Make the struct to hold the parameters, with its documentation:\n\"\"\"\n    ToyAssimGrowthModel(Rm_factor, Rg_cost)\n    ToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\n# Arguments\n\n- `LUE=0.2`: the light use efficiency, in gC mol[PAR]⁻¹\n- `Rm_factor=0.5`: the fraction of assimilation that goes into maintenance respiration\n- `Rg_cost=1.2`: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\n# Inputs\n\n- `aPPFD`: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\n# Outputs\n\n- `carbon_assimilation`: the assimilation, in gC m⁻² time-step⁻¹\n- `Rm`: the maintenance respiration, in gC m⁻² time-step⁻¹\n- `Rg`: the growth respiration, in gC m⁻² time-step⁻¹\n- `biomass_increment`: the daily biomass increment, in gC m⁻² time-step⁻¹\n- `biomass`: the plant biomass, in gC m⁻² time-step⁻¹\n\"\"\"\nstruct ToyAssimGrowthModel{T} <: AbstractGrowthModel\n    LUE::T\n    Rm_factor::T\n    Rg_cost::T\nend\n\n# Note that ToyAssimGrowthModel is a subtype of AbstractGrowthModel, this is important\n\n# Instantiate the `struct` with keyword arguments and default values:\nfunction ToyAssimGrowthModel(; LUE=0.2, Rm_factor=0.5, Rg_cost=1.2)\n    ToyAssimGrowthModel(promote(LUE, Rm_factor, Rg_cost)...)\nend\n\n# Define inputs:\nfunction PlantSimEngine.inputs_(::ToyAssimGrowthModel)\n    (aPPFD=-Inf,)\nend\n\n# Define outputs:\nfunction PlantSimEngine.outputs_(::ToyAssimGrowthModel)\n    (carbon_assimilation=-Inf, Rm=-Inf, Rg=-Inf, biomass_increment=-Inf, biomass=0.0)\nend\n\n# Tells Julia what is the type of elements:\nBase.eltype(x::ToyAssimGrowthModel{T}) where {T} = T\n\n# Implement the growth model:\nfunction PlantSimEngine.run!(::ToyAssimGrowthModel, models, status, meteo, constants, extra)\n\n    # The assimilation is simply the absorbed photosynthetic photon flux density (aPPFD) times the light use efficiency (LUE):\n    status.carbon_assimilation = status.aPPFD * models.growth.LUE\n    # The maintenance respiration is simply a factor of the assimilation:\n    status.Rm = status.carbon_assimilation * models.growth.Rm_factor\n    # Note that we use models.growth.Rm_factor to access the parameter of the model\n\n    # Net primary productivity of the plant (NPP) is the assimilation minus the maintenance respiration:\n    NPP = status.carbon_assimilation - status.Rm\n\n    # The NPP is used with a cost (growth respiration Rg):\n    status.Rg = 1 - (NPP / models.growth.Rg_cost)\n\n    # The biomass increment is the NPP minus the growth respiration:\n    status.biomass_increment = NPP - status.Rg\n\n    # The biomass is the biomass from the previous time-step plus the biomass increment:\n    status.biomass += status.biomass_increment\nend\n\n# And optionally, we can tell PlantSimEngine that we can safely parallelize our model over space (objects):\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyAssimGrowthModel}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now we can make a simulation as usual:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"model = ModelList(ToyAssimGrowthModel(), status = (aPPFD = 20.0,))\nrun!(model)\nmodel[:biomass] # biomass in gC m⁻²","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"We can also run the simulation over more time-steps:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"model = ModelList(\n    ToyAssimGrowthModel(),\n    status=(aPPFD=[10.0, 30.0, 25.0],),\n)\n\nrun!(model)\n\nmodel.status[:biomass] # biomass in gC m⁻²","category":"page"},{"location":"extending/implement_a_model/#model_implementation_page","page":"Models","title":"Model implementation in 5 minutes","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"using PlantSimEngine\n@process \"light_interception\" verbose = false\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/#Introduction","page":"Models","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.","category":"page"},{"location":"extending/implement_a_model/#Inspiration","page":"Models","title":"Inspiration","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you want to implement a new model, the best way to do it is to start from another implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For a complete example, you can look at the code in PlantBiophysics.jl, were you will find e.g. a photosynthesis model, with the implementation of the FvCB model in this Julia file: src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine also provide toy models that can be used as a base to better understand how to implement a new model: ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The Beer model for light interception in examples/Beer.jl\nA toy LAI development in examples/ToyLAIModel.jl","category":"page"},{"location":"extending/implement_a_model/#Requirements","page":"Models","title":"Requirements","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In those files, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see Implement a new process).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In this page, we'll just implement a model for a process that already exists: the light interception. This process is defined in PlantBiophysics.jl, and also made available as an example model from the Examples sub-module. You can access the script from here: examples/Beer.jl.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We can import the model like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But instead of just using it, we will review the script line by line.","category":"page"},{"location":"extending/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Models","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"extending/implement_a_model/#The-process","page":"Models","title":"The process","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We declare the light interception process at l.7 using @process: ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"See Implement a new process for more details on how that works and how to use the process.","category":"page"},{"location":"extending/implement_a_model/#The-structure","page":"Models","title":"The structure","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"hold the parameter values\ndispatch to the right run! method when calling it","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The structure of the model (or type) is defined as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first line defines the name of the model (Beer), which is completely free, except it is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We also can see that we define the Beer structure as a subtype of AbstractLight_InterceptionModel. This step is very important as it tells to the package what kind of process the model simulates. AbstractLight_InterceptionModel is automatically created when defining the process \"light_interception\".","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In our case, it tells us that Beer is a model to simulate the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Then comes the parameters names, and their types. The type of parameters is given by the user at instantiation in our example. This is done using the T notation as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"we say that our structure Beer is a parameterized struct by putting T in between brackets after the name of the struct\nWe put ::T after our parameter name in the struct. This way Julia knows that our parameter will be of type T.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The T is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But why not forcing the type such as the following:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Well, you can do that. But you'll lose a lot of the magic Julia has to offer this way.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For example a user could use the Particles type from MonteCarloMeasurements.jl to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.","category":"page"},{"location":"extending/implement_a_model/#The-method","page":"Models","title":"The method","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The models are implemented by adding a method for its type to the run! function. The exclamation point at the end of the function name is used in Julia to tell users that the function is mutating, i.e. it modifies its input.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The function takes six arguments:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"the type of your model\nmodels: a ModelList object, which contains all the models of the simulation\nstatus: a Status object, which contains the current values (i.e. state) of the variables for one time-step (e.g. the value of the plant LAI at time t)\nmeteo: (usually) an Atmosphere object, or a row of the meteorological data, which contains the current values of the meteorological variables for one time-step (e.g. the value of the PAR at time t)\nconstants: a Constants object, or a NamedTuple, which contains the values of the constants for the simulation (e.g. the value of the Stefan-Boltzmann constant)\nextras: any other object you want to pass to your model. This is for advanced users, and is not used in this example. Note that it is used to pass the Node when simulating a MultiScaleTreeGraph.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Your implementation can use any variables or parameters in these objects. The only thing you have to do is to make sure that the variables you use are defined in the Status object, the meteorology, and the Constants object.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The variables you use from the Status must be declared as inputs of your model. And the ones you modify must be declared as outputs. We'll that below.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nModels implementations are done for one time-step by design. The values of the previous time-step is always available in the status (e.g. status.biomass) as long as the variable is an output of your model. This is because at the end of a time-step, the Status object is recycled for the next time-step and so the latest computed values are always available. This is why it is possible to increment a value every time-step using e.g. status.biomass += 1.0. By design models don't have access to values prior to the one before. If you're not convinced by this approach, ask yourself how the plant knows the value of e.g. LAI from 15 days ago. It doesn't. It only knows its current state. Most of the time-sensitive variables really are just an accumulation of values until a threshold anyway. BUt if you really need to use values from the past (e.g. 15 time-steps before), you can add a variable to the Status object that is uses like a queue (see e.g. DataStructures.jl).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine then automatically deals with every other detail, such as checking that the object is correctly initialized, applying the computations over objects and time-steps. This is nice because as a developer you don't have to deal with those details, and you can just concentrate on your model implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nYou need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So let's do it! Here is our own implementation of the light interception for a ModelList component models:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first argument (::Beer) means this method will only execute when the function is called with a first argument that is of type Beer. This is our way of telling Julia that this method implements the Beer model for the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"An important thing to note is that the model parameters are available from the ModelList that is passed via the models argument. Then parameters are found in field called by the process name, and the parameter name. For example, the k parameter of the Beer model is found in models.light_interception.k.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"One last thing to do is to define the inputs and outputs of our model. This is done by adding a method for the inputs and outputs functions. These functions take the type of the model as argument, and return a NamedTuple with the names of the variables as keys, and their default values as values.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In our case, the Beer model has one input and one output:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Inputs: :LAI, the leaf area index (m² m⁻²)\nOutputs: :aPPFD, the photosynthetic photon flux density (μmol m⁻² s⁻¹)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here is how we communicate that to PlantSimEngine:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Note that both functions end with an \"_\". This is because these functions are internal, they will not be called by the users directly. Users will use inputs and outputs instead, which call inputs_ and outputs_, but stripping out the default values.","category":"page"},{"location":"extending/implement_a_model/#Dependencies","page":"Models","title":"Dependencies","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To do so, we can add a method to the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You can read more about dependencies in Model coupling for modelers and Model coupling for users.","category":"page"},{"location":"extending/implement_a_model/#The-utility-functions","page":"Models","title":"The utility functions","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Before running a simulation, you can do a little bit more for your implementation (optional).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"First, you can add a method for type promotion. It wouldn't make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To add type promotion to Beer2 we would do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function Beer2(k,x)\n    Beer2(promote(k,x))\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer2(0.6,2)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You don't see a problem? Well your users won't either. But there's one: Beer2 is a parametric type, so all fields share the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this force the user to give all parameters with the same type.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"And in our example above, the user provides 0.6 for k, which is a Float64, and 2 for x, which is an Int. ANd if you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert 2 to 2.0.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of k. So we can provide a default value like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer() = Beer(0.6)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now the user can call Beer with zero value, and k will default to 0.6.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Another useful thing is the ability to instantiate your model type with keyword arguments, i.e. naming the arguments. You can do it by adding the following method:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(;k) = Beer(k)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Did you notice the ; before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call Beer like this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(k = 0.7)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The last optional thing to implement is a method for the eltype function:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Base.eltype(x::Beer{T}) where {T} = T","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This one helps Julia know the type of the elements in the structure, and make it faster.","category":"page"},{"location":"extending/implement_a_model/#Traits","page":"Models","title":"Traits","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine defines traits to get additional information about the models. At the moment, there are two traits implemented that help the package to know if a model can be run in parallel over space (i.e. objects) and/or time (i.e. time-steps).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"By default, all models are assumed to be not parallelizable over objects and time-steps, because it is the safest default. If your model is parallelizable, you should add the trait to the model.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For example, if we want to add the trait for parallelization over objects to our Beer model, we would do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"And if we want to add the trait for parallelization over time-steps to our Beer model, we would do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"note: Note\nA model is parallelizable over objects if it does not call another model directly inside its code. Similarly, a model is parallelizable over time-steps if it does not get values from other time-steps directly inside its code. In practice, most of the models are parallelizable one way or another, but it is safer to assume they are not.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK that's it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue.","category":"page"},{"location":"model_switching/#Model-switching","page":"Model Switching","title":"Model switching","text":"","category":"section"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine, PlantMeteo, CSV, DataFrames\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n \nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models, meteo_day)\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\nrun!(models2, meteo_day)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"One of the main objective of PlantSimEngine is allowing users to switch between model implementations for a given process without making any change to the code. ","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"The package was carefully designed around this idea to make it easy and computationally efficient. This is done by using the ModelList, which is used to list models, and the run! function to run the simulation following the dependency graph and leveraging Julia's multiple dispatch to run the models.","category":"page"},{"location":"model_switching/#ModelList","page":"Model Switching","title":"ModelList","text":"","category":"section"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"The ModelList is a container that holds a list of models, their parameter values, and the status of the variables associated to them.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Model coupling is done by adding models to the ModelList. Let's create a ModelList with several models from the example scripts in the examples folder:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Importing the models from the scripts:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Coupling the models in a ModelList:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"models = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"PlantSimEngine uses the ModelList to compute the dependency graph of the models. Here we have seven models, one for each process. The dependency graph is computed automatically by PlantSimEngine, and is used to run the simulation in the correct order.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"We can run the simulation by calling the run! function with a meteorology. Here we use an example meteorology:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"tip: Tip\nTo reproduce this meteorology, you can check the code presented in this section in the FAQ","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"We can now run the simulation:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"run!(models, meteo_day)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nYou'll notice a warning returned by run! here. If you read its content, you'll see it says that ToyRUEGrowthModel does not allow for parallel computations over time-steps. This is because it uses values from the previous time-steps in its computations. By default, run! makes the simulations in parallel, so to avoid the warning, you must explicitly tell it to use a sequential execution instead. To do so, you can use the executor=SequentialEx() keyword argument.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And then we can access the status of the ModelList using the status function:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"status(models)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Now what if we want to switch the model that computes growth ? We can do this by simply replacing the model in the ModelList, and PlantSimEngine will automatically update the dependency graph, and adapt the simulation to the new model.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Let's switch ToyRUEGrowthModel by ToyAssimGrowthModel:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"models2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(), # This was `ToyRUEGrowthModel(0.2)` before\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"ToyAssimGrowthModel is a little bit more complex than ToyRUEGrowthModel, as it also computes the maintenance and growth respiration of the plant, so it has more parameters (we use the default values here).","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"We can run a new simulation:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"run!(models2, meteo_day)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And we can see that the status of the variables is different from the previous simulation:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"status(models2)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nIn our example we replaced a soft-dependency model, but the same principle applies to hard-dependency models.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And that's it! We can switch between models without changing the code, and without having to recompute the dependency graph manually. This is a very powerful feature of PlantSimEngine!💪","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nThis was a very standard but easy example. Sometimes other models will require to add other models to the ModelList. For example ToyAssimGrowthModel could have required a maintenance respiration model. In this case PlantSimEngine will tell you that this kind of model is required for the simulation.","category":"page"},{"location":"model_execution/#Model-execution","page":"Execution","title":"Model execution","text":"","category":"section"},{"location":"model_execution/#Simulation-order","page":"Execution","title":"Simulation order","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the ModelList to automatically compute a dependency graph between the models and run the simulation in the correct order. When running a simulation with run!, the models are then executed following this simple set of rules:","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Independent models are run first. A model is independent if it can be run independently from other models, only using initializations (or nothing). \nThen, models that have a dependency on other models are run. The first ones are the ones that depend on an independent model. Then the ones that are children of the second ones, and then their children ... until no children are found anymore. There are two types of children models (i.e. dependencies): hard and soft dependencies:\nHard dependencies are always run before soft dependencies. A hard dependency is a model that list dependencies in their own method for dep. See this example that shows Process2Model defining a hard dependency on any model that simulate process1. Inner hard dependency graphs (i.e. consecutive hard-dependency children) are considered as a single soft dependency.\nSoft dependencies are then run sequentially. A model has a soft dependency on another model if one or more of its inputs is computed by another model. If a soft dependency has several parent nodes (e.g. two different models compute two inputs of the model), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"},{"location":"model_execution/#Parallel-execution","page":"Execution","title":"Parallel execution","text":"","category":"section"},{"location":"model_execution/#FLoops","page":"Execution","title":"FLoops","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the Floops package to run the simulation in sequential, parallel (multi-threaded) or distributed (multi-process) computations over objects, time-steps and independent processes. ","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"That means that you can provide any compatible executor to the executor argument of run!. By default, run! uses the ThreadedEx executor, which is a multi-threaded executor. You can also use the SequentialExfor sequential execution (non-parallel), or DistributedEx for distributed computations.","category":"page"},{"location":"model_execution/#Parallel-traits","page":"Execution","title":"Parallel traits","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses Holy traits to define if a model can be run in parallel.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"note: Note\nA model is executable in parallel over time-steps if it does not uses or set values from other time-steps, and over objects if it does not uses or set values from other objects.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"You can define a model as executable in parallel by defining the traits for time-steps and objects. For example, the ToyLAIModel model from the examples folder can be run in parallel over time-steps and objects, so it defines the following traits:","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsObjectIndependent()","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"By default all models are considered not executable in parallel, because it is the safest option to avoid bugs that are difficult to catch, so you only need to define these traits if it is executable in parallel for them.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"tip: Tip\nA model that is defined executable in parallel will not necessarily will. First, the user has to pass a parallel executor to run! (e.g. ThreadedEx). Second, if the model is coupled with another model that is not executable in parallel, PlantSimEngine will run all models in sequential.","category":"page"},{"location":"model_execution/#Further-executors","page":"Execution","title":"Further executors","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"You can also take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Finally, you can take a look into Transducers.jl's documentation for more information, for example if you don't know what is an executor, you can look into this explanation.","category":"page"},{"location":"model_execution/#Tutorial","page":"Execution","title":"Tutorial","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"You can learn how to run a simulation from the home page, or from the documentation of PlantBiophysics.jl.","category":"page"},{"location":"design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to ease the process of modelling and simulation of plants, soil and atmosphere, or really any system (e.g. agroforestry system, agrivoltaics...). PlantSimEngine.jl aims at being the backbone tool for developing Functional-Structural Plant Models (FSPM) and crop models without the hassle of performance and other computer-science considerations.  ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nrun!(leaf, meteo)","category":"page"},{"location":"design/#Definitions","page":"Design","title":"Definitions","text":"","category":"section"},{"location":"design/#Processes","page":"Design","title":"Processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A process is \"declared\", meaning we just define a process using @process, and then we implement models for its simulation. Declaring a process generates some boilerplate code for its simulation: ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"an abstract type for the process\na method for the process function, that is used internally","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example, the light_interception process is declared using:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@process light_interception","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Which would generate a tutorial to help the user implement a model for the process.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The abstract process type is then used as a supertype of all models implementations for the process, and is named Abstract<process_name>Process, e.g. AbstractLight_InterceptionModel.","category":"page"},{"location":"design/#Models-(ModelList)","page":"Design","title":"Models (ModelList)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/Beer.jl.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Models can use three types of entries:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters are constant values that are used by the model to compute its outputs. Meteorological information are values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. Variables are either used or computed by the model and can optionally be initialized before the simulation. Constants are constant values, usually common between models, e.g. the universal gas constant. And extras are just extra values that can be used by a model, it is for example used to pass the current node of the Multi-Scale Tree Graph to be able to e.g. retrieve children or ancestors values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users can choose which model is used to simulate a process using the ModelList structure. ModelList is also used to store the values of the parameters, and to initialize variables.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example let's instantiate a ModelList with the Beer-Lambert model of light extinction. The model is implemented with the Beer structure and has only one parameter: the extinction coefficient (k).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Importing the package:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Import the examples defined in the Examples sub-module (light_interception and Beer):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine.Examples","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"And then making a ModelList with the Beer model:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"ModelList(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"What happened here? We provided an instance of the Beer model to a ModelList to simulate the light interception process.","category":"page"},{"location":"design/#Parameters","page":"Design","title":"Parameters","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A parameter is a constant value that is used by a model to compute its outputs. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer-Lambert model is implemented with the Beer structure, which has only one field: k. We can see that using fieldnames on the model structure:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(Beer)","category":"page"},{"location":"design/#Variables-(inputs,-outputs)","page":"Design","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Variables are either input or outputs (i.e. computed) of models. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Hence, ModelList objects stores two fields:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(ModelList)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first field is a list of models associated to the processes they simulate. The second, :status, is used to hold all inputs and outputs of our models, called variables. For example the Beer model needs the leaf area index (LAI, m² m⁻²) to run.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can see which variables are needed as inputs using inputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"inputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"and the outputs of the model using outputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"outputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"If we instantiate a ModelList with the Beer-Lambert model, we can see that the :status field has two variables: LAI and PPFD. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nkeys(status(m))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nto_initialize(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"(m[:LAI], m[:aPPFD])","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Uninitialized variables are initialized to the value given in the inputs or outputs methods, which is usually equal to typemin(), e.g. -Inf for Float64.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns the variables that are needed by the model to run, but to_initialize returns the variables that are needed by the model to run and that are not initialized in the ModelList. Also to_initialize is more clever when coupling models (see below).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can initialize the variables by providing their values to the status at instantiation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or after instantiation using init_status!:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"is_initialized(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Some variables are inputs of models, but outputs of other models. When we couple models, PlantSimEngine.jl is clever and only requests the variables that are not computed by other models.","category":"page"},{"location":"design/#Climate-forcing","page":"Design","title":"Climate forcing","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed, m s⁻¹). In our example, we also need the incoming photosynthetically active radiation flux (Ri_PAR_f, W m⁻²). We can declare such conditions like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"More details are available from the package documentation.","category":"page"},{"location":"design/#Simulation","page":"Design","title":"Simulation","text":"","category":"section"},{"location":"design/#Simulation-of-processes","page":"Design","title":"Simulation of processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Making a simulation is rather simple, we simply use run! on the ModelList:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The call to run! is the same whatever the models you choose for simulating the processes. This is some magic allowed by PlantSimEngine.jl! Here is an example:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"run!(model_list, meteo)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The ModelList should be initialized for the given process before calling the function. See Variables (inputs, outputs) for more details.","category":"page"},{"location":"design/#Example-simulation","page":"Design","title":"Example simulation","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"For example we can simulate the light_interception of a leaf like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\nrun!(leaf, meteo)\n\nleaf[:aPPFD]","category":"page"},{"location":"design/#Outputs","page":"Design","title":"Outputs","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract the simulation outputs of a model list using the status function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The status is usually stored in a TimeStepTable structure from PlantMeteo.jl, which is a fast DataFrame-alike structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's look at the status of our previous simulated leaf:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can extract the value of one variable using the status function, e.g. for the intercepted light:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf, :aPPFD)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or similarly using the dot syntax:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf.status.aPPFD","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or much simpler (and recommended), by indexing directly into the model list:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf[:aPPFD]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Another simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using DataFrames\nDataFrame(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThe output from DataFrame is adapted to the kind of simulation you did: one row per time-step, and per component models if you simulated several.","category":"page"},{"location":"design/#Model-coupling","page":"Design","title":"Model coupling","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to make model coupling painless for modelers and users. Please see Model coupling for users and Model coupling for modelers for more details.","category":"page"},{"location":"fitting/#Parameter-fitting","page":"Fitting","title":"Parameter fitting","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"fitting/#The-fit-method","page":"Fitting","title":"The fit method","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Models are often calibrated using data, but the calibration process is not always the same depending on the model, and the data available to the user.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"PlantSimEngine defines a generic fit function that allows modelers provide a fitting algorithm for their model, and for users to use this method to calibrate the model using data.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The function does nothing in this package, it is only defined to provide a common interface for all the models. It is up to the modeler to implement the method for their model. ","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The method is implemented as a function with the following design pattern: the call to the function should take the model type as the first argument (T::Type{<:AbstractModel}), the data as the second argument (as a Table.jl compatible type, such as DataFrame), and any more information as keyword arguments, e.g. constants or parameters initializations with default values when necessary.","category":"page"},{"location":"fitting/#Example-with-Beer","page":"Fitting","title":"Example with Beer","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The example script (see src/examples/Beer.jl) that implements the Beer model provides an example of how to implement the fit method for a model:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The function takes a Beer type as the first argument, the data as a Tables.jl compatible type, such as a DataFrame as the second argument, and the J_to_umol constant as a keyword argument, which is used to convert between μ mol m⁻² s⁻¹ and J m⁻² s⁻¹.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"df should contain the columns PPFD (μ mol m⁻² s⁻¹), LAI (m² m⁻²) and Ri_PAR_f (W m⁻²). The function then computes k based on these values, and returns it as a NamedTuple of the form (parameter_name=parameter_value,).","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Here's an example of how to use the fit method:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Importing the script first: ","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Defining the meteo data:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Computing the PPFD values from the Ri_PAR_f values using the Beer model (with k=0.6):","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"m = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Now we can define the \"data\" to fit the model using the simulated PPFD values:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"And finally we can fit the model using the fit method:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"fit(Beer, df)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"note: Note\nThis is a dummy example to show that the fitting method works. A real application would fit the parameter values on the data directly.","category":"page"},{"location":"FAQ/translate_a_model/#I-want-to-use-PlantSimEngine-for-my-model","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using PlantSimEngine\nusing CairoMakie\nusing CSV, DataFrames\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n# Note: meteo_day is defined below if you want to reproduce it, then use this to write it:\n# PlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If you already have a model, you can easily use PlantSimEngine to couple it with other models with minor adjustments.","category":"page"},{"location":"FAQ/translate_a_model/#Toy-LAI-Model","page":"I want to use PlantSimEngine for my model","title":"Toy LAI Model","text":"","category":"section"},{"location":"FAQ/translate_a_model/#Model-description","page":"I want to use PlantSimEngine for my model","title":"Model description","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Let's take an example with a simple LAI model that we define below:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"\"\"\"\nSimulate leaf area index (LAI, m² m⁻²) for a crop based on the amount of degree-days since sowing with a simple double-logistic function.\n\n# Arguments\n\n- `TT_cu`: degree-days since sowing\n- `max_lai=8`: Maximum value for LAI\n- `dd_incslope=500`: degree-days at which we get the maximal increase in LAI\n- `inc_slope=5`: slope of the increasing part of the LAI curve\n- `dd_decslope=1000`: degree-days at which we get the maximal decrease in LAI\n- `dec_slope=2`: slope of the decreasing part of the LAI curve\n\"\"\"\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This model takes the number of days since sowing as input and returns the simulated LAI. We can plot the simulated LAI for a year:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"FAQ/translate_a_model/#Changes-for-PlantSimEngine","page":"I want to use PlantSimEngine for my model","title":"Changes for PlantSimEngine","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"The model can be implemented using PlantSimEngine as follows:","category":"page"},{"location":"FAQ/translate_a_model/#Define-a-process","page":"I want to use PlantSimEngine for my model","title":"Define a process","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If the process of LAI dynamic is not implement yet, we can define it like so:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"@process LAI_Dynamic","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model","page":"I want to use PlantSimEngine for my model","title":"Define the model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We have to define a structure for our model that will contain the parameters of the model:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"struct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We can also define default values for the parameters by defining a method with keyword arguments:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"ToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This way users can create a model with default parameters just by calling ToyLAIModel(), or they can specify only the parameters they want to change, e.g. ToyLAIModel(inc_slope=80.0)","category":"page"},{"location":"FAQ/translate_a_model/#Define-inputs-/-outputs","page":"I want to use PlantSimEngine for my model","title":"Define inputs / outputs","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define the inputs and outputs of the model, and the default value at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"PlantSimEngine.inputs_(::ToyLAIModel) = (TT_cu=-Inf,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we use -Inf for the default value, it is the recommended value for Float64 (-999 for Int), as it is a valid value for this type, and is easy to catch in the outputs if not properly set because it propagates nicely. You can also use NaN instead.","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model-function","page":"I want to use PlantSimEngine for my model","title":"Define the model function","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Finally, we can define the model function that will be called at each time step:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"function PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.TT_cu) / model.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.TT_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we don't return the value of the LAI in the definition of the function. This is because we rather update its value in the status directly. The status is a structure that efficiently stores the state of the model at each time step, and it contains all variables either declared as inputs or outputs of the model. This way, we can access the value of the LAI at any time step by calling status.LAI.","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nThe function is defined for one time step only, and is called at each time step automatically by PlantSimEngine. This means that we don't have to loop over the time steps in the function.","category":"page"},{"location":"FAQ/translate_a_model/#defining_the_meteo","page":"I want to use PlantSimEngine for my model","title":"Running a simulation","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Now that we have everything set up, we can run a simulation. The first step here is to define the weather:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"# Import the packages we need:\nusing PlantMeteo, Dates, DataFrames\n\n# Define the period of the simulation:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# Get the weather data for CIRAD's site in Montpellier, France:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# Compute the degree-days with a base temperature of 10°C:\nmeteo.TT = max.(meteo.T .- 10.0, 0.0)\n\n# Aggregate the weather data to daily values:\nmeteo_day = to_daily(meteo, :TT => (x -> sum(x) / 24) => :TT)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define our list of models, passing the values for TT_cu in the status at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"m = ModelList(\n    ToyLAIModel(),\n    status = (TT_cu = cumsum(meteo_day.TT),),\n)\n\nrun!(m)\n\nlines(m[:TT_cu], m[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Model-coupling-for-modelers","page":"Modelers","title":"Model coupling for modelers","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"This section uses notions from the previous section. If you are not familiar with the concepts of model coupling in PlantSimEngine, please read the previous section first: Model coupling for users.","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Hard-coupling","page":"Modelers","title":"Hard coupling","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A model that calls explicitly another process is called a hard-coupled model. It is implemented by calling the process function directly.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Let's go through the example processes and models from a script provided by the package here examples/dummy.jl","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"In this script, we declare seven processes and seven models, one for each process. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model...","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Process2Model calls Process1Model explicitly, which defines Process1Model as a hard-dependency of Process2Model. The is as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"function PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # computing var3 using process1:\n    run!(models.process1, models, status, meteo, constants)\n    # computing var4 and var5:\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"We see that coupling a model (Process2Model) to another process (process1) is done by calling the run! function again. The run! function is called with the same arguments as the run! function of the model that calls it, except that we pass the process we want to simulate as the first argument.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"note: Note\nWe don't enforce any type of model to simulate process1. This is the reason why we can switch so easily between model implementations for any process, by just changing the model in the ModelList.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A hard-dependency must always be declared to PlantSimEngine. This is done by adding a method to the dep function. For example, the hard-dependency to process1 into Process2Model is declared as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"PlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"This way PlantSimEngine knows that Process2Model needs a model for the simulation of the process1 process. Note that we don't add any constraint to the type of model we have to use (we use AbstractProcess1Model), because we want any model implementation to work with the coupling, as we only are interested in the value of a variable, not the way it is computed.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Even if it is discouraged, you may have a valid reason to force the coupling with a particular model, or a kind of models though. For example, if we want to use only Process1Model for the simulation of process1, we would declare the dependency as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"PlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Soft-coupling","page":"Modelers","title":"Soft coupling","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A model that takes outputs of another model as inputs is called a soft-coupled model. There is nothing to do on the modeler side to declare a soft-dependency. The detection is done automatically by PlantSimEngine using the inputs and outputs of the models.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]","category":"page"},{"location":"API/#API-documentation","page":"API","title":"API documentation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.AbstractModel","page":"API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.ModelList","page":"API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    init_fun::Function=init_fun_default,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\nnsteps=nothing: the number of time steps to pre-allocated. If nothing, the number of time steps is deduced from the status (or 1 if no status is given).\ninit_fun: a function that initializes the status based on a vector of NamedTuples (see details).\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nThe argument init_fun is set by default to init_fun_default which initializes the status with a TimeStepTable of Status structures.\n\nIf you change init_fun by another function, make sure the type you are using (i.e. in place of TimeStepTable)  implements the Tables.jl interface (e.g. DataFrame does). And if you still use TimeStepTable but only change Status, make sure the type you give is indexable using the dot synthax (e.g. x.var).\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, TimeStepTable{Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}, Tuple{}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> run!(models,meteo)\n\njulia> models[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\nWe can also use DataFrame as the status type:\n\njulia> using DataFrames;\n\njulia> df = DataFrame(:var1 => [13.747, 13.8], :var2 => [1.0, 1.0]);\n\njulia> m = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=df, init_fun=x -> DataFrame(x));\n\nNote that we use init_fun to force the status into a DataFrame, otherwise it would be automatically converted into a TimeStepTable{Status}.\n\njulia> status(m)\n2×6 DataFrame\n Row │ var5     var4     var6     var1     var3     var2    \n     │ Float64  Float64  Float64  Float64  Float64  Float64 \n─────┼──────────────────────────────────────────────────────\n   1 │    -Inf     -Inf     -Inf   13.747     -Inf      1.0\n   2 │    -Inf     -Inf     -Inf   13.8       -Inf      1.0\n\nNote that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.MultiScaleModel","page":"API","title":"PlantSimEngine.MultiScaleModel","text":"MultiScaleModel(model, mapping)\n\nA structure to make a model multi-scale. It defines a mapping between the variables of a  model and the nodes symbols from which the values are taken from.\n\nArguments\n\nmodel<:AbstractModel: the model to make multi-scale\nmapping<:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}: a vector of pairs of symbols and strings or vectors of strings\n\nThe mapping can be of the form:\n\n[:variable_name => \"Plant\"]: We take one value from the Plant node\n[:variable_name => [\"Leaf\"]]: We take a vector of values from the Leaf nodes\n[:variable_name => [\"Leaf\", \"Internode\"]]: We take a vector of values from the Leaf and Internode nodes\n[:variable_name => \"Plant\" => :variable_name_in_plant_scale]: We take one value from another variable name in the Plant node\n[:variable_name => [\"Leaf\" => :variable_name_1, \"Internode\" => :variable_name_2]]: We take a vector of values from the Leaf and Internode nodes with different names\n[PreviousTimeStep(:variable_name) => ...]: We flag the variable to be initialized with the value from the previous time step, and we do not use it to build the dep graph\n[:variable_name => :variable_name_from_another_model]: We take the value from another model at the same scale but rename it\n[PreviousTimeStep(:variable_name),]: We just flag the variable as a PreviousTimeStep to not use it to build the dep graph\n\nDetails about the different forms:\n\nThe variable variable_name of the model will be taken from the Plant node, assuming only one node has the Plant symbol.\n\nIn this case the value available from the status will be a scalar, and so the user must guaranty that only one node of type Plant is available in the MTG.\n\nThe variable variable_name of the model will be taken from the Leaf nodes. Notice it is given as a vector, indicating that the values will be taken \n\nfrom all the nodes of type Leaf. The model should be able to handle a vector of values. Note that even if there is only one node of type Leaf, the value will be taken as a vector of one element.\n\nThe variable variable_name of the model will be taken from the Leaf and Internode nodes. The values will be taken from all the nodes of type Leaf \n\nand Internode.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_in_plant_scale in the Plant node. This is useful\n\nwhen the variable name in the model is different from the variable name in the scale it is taken from.\n\nThe variable variable_name of the model will be taken from the variable called variable_name_1 in the Leaf node and variable_name_2 in the Internode node.\nThe variable variable_name of the model uses the value computed on the previous time-step. This implies that the variable is not used to build the dependency graph\n\nbecause the dependency graph only applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe variable variable_name of the model will be taken from another model at the same scale, but with another variable name.\nThe variable variable_name of the model is just flagged as a PreviousTimeStep variable, so it is not used to build the dependency graph.\n\nNote that the mapping does not make any copy of the values, it only references them. This means that if the values are updated in the status of one node, they will be updated in the other nodes.\n\nExamples\n\njulia> using PlantSimEngine;\n\nIncluding example processes and models:\n\njulia> using PlantSimEngine.Examples;\n\nLet's take a model:\n\njulia> model = ToyCAllocationModel()\nToyCAllocationModel()\n\nWe can make it multi-scale by defining a mapping between the variables of the model and the nodes symbols from which the values are taken from:\n\nFor example, if the carbon_allocation comes from the Leaf and Internode nodes, we can define the mapping as follows:\n\njulia> mapping = [:carbon_allocation => [\"Leaf\", \"Internode\"]]\n1-element Vector{Pair{Symbol, Vector{String}}}:\n :carbon_allocation => [\"Leaf\", \"Internode\"]\n\nThe mapping is a vector of pairs of symbols and strings or vectors of strings. In this case, we have only one pair to define the mapping between the carbon_allocation variable and the Leaf and Internode nodes.\n\nWe can now make the model multi-scale by passing the model and the mapping to the MultiScaleModel constructor :\n\njulia> multiscale_model = PlantSimEngine.MultiScaleModel(model, mapping)\nMultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]])\n\nWe can access the mapping and the model:\n\njulia> PlantSimEngine.mapping_(multiscale_model)\n1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:\n :carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]\n\njulia> PlantSimEngine.model_(multiscale_model)\nToyCAllocationModel()\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.PreviousTimeStep","page":"API","title":"PlantSimEngine.PreviousTimeStep","text":"PreviousTimeStep(variable)\n\nA structure to manually flag a variable in a model to use the value computed on the previous time-step.  This implies that the variable is not used to build the dependency graph because the dependency graph only  applies on the current time-step. This is used to avoid circular dependencies when a variable depends on itself. The value can be initialized in the Status if needed.\n\nThe process is added when building the MultiScaleModel, to avoid conflicts between processes with the same variable name. For exemple one process can define a variable :carbon_biomass as a PreviousTimeStep, but the othe process would use  the variable as a dependency for the current time-step (and it would be fine because theyr don't share the same issue of cyclic dependency).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Status","page":"API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> using PlantSimEngine\n\njulia> st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Rₛ]\n13.747\n\njulia> st.Rₛ\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Rₛ] = 20.0\n20.0\n\njulia> st.Rₛ = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.EF-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}","page":"API","title":"PlantSimEngine.add_organ!","text":"add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)\n\nAdd an organ to the graph, automatically taking care of initialising the status of the organ (multiscale-)variables.\n\nThis function should be called from a model that implements organ emergence, for example in function of thermal time.\n\nArguments\n\nnode: the node to which the organ is added (the parent organ of the new organ)\nsim_object: the simulation object, e.g. the GraphSimulation object from the extra argument of a model.\nlink: the link type between the new node and the organ:\n\"<\": the new node is following the parent organ\n\"+\": the new node is branching the parent organ\n\"/\": the new node is decomposing the parent organ, i.e. we change scale\nsymbol: the symbol of the organ, e.g. \"Leaf\"\nscale: the scale of the organ, e.g. 2.\nindex: the index of the organ, e.g. 1. The index may be used to easily identify branching order, or growth unit index on the axis. It is different from the node id that is unique.\nid: the unique id of the new node. If not provided, a new id is generated.\nattributes: the attributes of the new node. If not provided, an empty dictionary is used.\ncheck: a boolean indicating if variables initialisation should be checked. Passed to init_node_status!.\n\nReturns\n\nstatus: the status of the new node\n\nExamples\n\nSee the ToyInternodeEmergence example model from the Examples module (also found in the examples folder), or the test-mtg-dynamic.jl test file for an example usage.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dep","page":"API","title":"PlantSimEngine.dep","text":"dep(m::ModelList, nsteps=1; verbose::Bool=true)\ndep(mapping::Dict{String,T}; verbose=true)\n\nGet the model dependency graph given a ModelList or a multiscale model mapping. If one graph is returned,  then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph. It is set to 1 in the case of a  multiscale mapping.\n\nDetails\n\nThe dependency graph is computed by searching the inputs of each process in the outputs of its own scale, or the other scales. There are five cases for every model (one model simulates one process):\n\nThe process has no inputs. It is completely independent, and is placed as one of the roots of the dependency graph.\nThe process needs inputs from models at its own scale. We put it as a child of this other process.\nThe process needs inputs from another scale. We put it as a child of this process at another scale.\nThe process needs inputs from its own scale and another scale. We put it as a child of both.\nThe process is a hard dependency of another process (only possible at the same scale). In this case, the process is set as a hard-dependency of the \n\nother process, and its simulation is handled directly from this process.\n\nFor the 4th case, the process have two parent processes. This is OK because the process will only be computed once during simulation as we check if both  parents were run before running the process. \n\nNote that in the 5th case, we still need to check if a variable is needed from another scale. In this case, the parent node is  used as a child of the process at the other scale. Note there can be several levels of hard dependency graph, so this is done recursively.\n\nHow do we do all that? We identify the hard dependencies first. Then we link the inputs/outputs of the hard dependencies roots  to other scales if needed. Then we transform all these nodes into soft dependencies, that we put into a Dict of Scale => Dict(process => SoftDependencyNode). Then we traverse all these and we set nodes that need outputs from other nodes as inputs as children/parents. If a node has no dependency, it is set as a root node and pushed into a new Dict (independantprocessroot). This Dict is the returned dependency graph. And  it presents root nodes as independent starting points for the sub-graphs, which are the models that are coupled together. We can then traverse each of  these graphs independently to retrieve the models that are coupled together, in the right order of execution.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nmodels = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;models...)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.dr-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.fit","page":"API","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/Beer.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of PPFD, LAI  and Ri_PAR_f. \n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated PPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"API","title":"PlantSimEngine.inputs","text":"inputs(mapping::Dict{String,T})\n\nGet the inputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"API","title":"PlantSimEngine.outputs","text":"outputs(sim::GraphSimulation, sink)\n\nGet the outputs from a simulation made on a plant graph.\n\nDetails\n\nThe first method returns a vector of NamedTuple, the second formats it  sing the sink function, for exemple a DataFrame.\n\nArguments\n\nsim::GraphSimulation: the simulation object, typically returned by run!.\nsink: a sink compatible with the Tables.jl interface (e.g. a DataFrame)\nrefvectors: if false (default), the function will remove the RefVector values, otherwise it will keep them\nno_value: the value to replace nothing values. Default is nothing. Usually used to replace nothing values \n\nby missing in DataFrames.\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph, DataFrames, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nmapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), )\n\nmtg = import_mtg_example();\n\nsim = run!(mtg, mapping, meteo, outputs = Dict(\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :soil_water_content, :carbon_allocation),\n    \"Internode\" => (:carbon_allocation,),\n    \"Plant\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n));\n\noutputs(sim, DataFrames)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"API","title":"PlantSimEngine.outputs","text":"outputs(mapping::Dict{String,T})\n\nGet the outputs of the models in a mapping, for each process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.run!","page":"API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\nrun!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or a plant graph (MTG).\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters, not available for simulation of plant graphs (the simulation object is passed using this).\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nmapping: a mapping between the MTG and the model list.\nnsteps: the number of time-steps to run, only needed if no meteo is given (else it is infered from it).\noutputs: the outputs to get in dynamic for each node type of the MTG.\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nUsers can ask for parallel execution by providing a compatible executor to the executor argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the Examples sub-module:\n\njulia> using PlantSimEngine.Examples;\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> run!(models, meteo);\n\nGet the results:\n\njulia> (models[:var4],models[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.status-Tuple{Any}","page":"API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including example models and processes:\nusing PlantSimEngine.Examples;\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(; verbose=true, vars...)\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\nto_initialize(mapping::Dict{String,T}, graph=nothing)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nArguments\n\nverbose: if true, print information messages.\nvars...: the models and processes to consider.\nm::T: a ModelList.\nm::DependencyGraph: a DependencyGraph.\nmapping::Dict{String,T}: a mapping that associates models to organs.\ngraph: a graph representing a plant or a scene, e.g. a multiscale tree graph. The graph is used to check if variables that are not initialized can be found in the graph nodes attributes.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\nto_initialize(m)\n\nOr with a mapping:\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmapping = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"Internode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\nto_initialize(mapping)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(m::AbstractDependencyNode)\n\nReturn the variables that must be initialized providing a set of models and processes. The function just returns the inputs and outputs of each model, with their default values. To take into account model coupling, use the function at an upper-level instead, i.e.  to_initialize(m::ModelList) or to_initialize(m::DependencyGraph).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{Module}","page":"API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}","page":"API","title":"PlantSimEngine.variables","text":"variables(m::AbstractDependencyNode)\n\nReturns a tuple with the name of the inputs and outputs variables needed by a model in  a dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"API","title":"PlantSimEngine.variables","text":"variables(mapping::Dict{String,T})\n\nGet the variables (inputs and outputs) of the models in a mapping, for each  process and organ type.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nNewcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of AbstractModel:\n\nabstract type MyNewProcess <: AbstractModel end\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"API/#Un-exported","page":"API","title":"Un-exported","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat). ","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S, V}}, Tuple{V}, Tuple{S}, Tuple{T}} where {T, S<:Status, V}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S,V}) where {T,S<:Status,V}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S, V}}, Tuple{V}, Tuple{S}, Tuple{T}} where {T, S<:TimeStepTable, V}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,<:TimeStepTable})\n\nImplementation of DataFrame for a ModelList model with several time steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.AbstractNodeMapping","page":"API","title":"PlantSimEngine.AbstractNodeMapping","text":"AbstractNodeMapping\n\nAbstract type for the type of node mapping, e.g. single node mapping or multiple node mapping.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\nTreeAlike: The data is a tree-like object, e.g. a Node.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for GraphSimulation,  SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.DependencyGraph","page":"API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.DependencyTrait","page":"API","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\nReturns information about the eventual dependence of a model T to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.\n\nThe following dependence traits are supported:\n\nTimeStepDependencyTrait: Trait that defines whether a model can be parallelizable over time-steps for its computation.\nObjectDependencyTrait: Trait that defines whether a model can be parallelizable over objects for its computation.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.GraphSimulation","page":"API","title":"PlantSimEngine.GraphSimulation","text":"GraphSimulation(graph, mapping)\nGraphSimulation(graph, statuses, dependency_graph, models, outputs)\n\nA type that holds all information for a simulation over a graph.\n\nArguments\n\ngraph: an graph, such as an MTG\nmapping: a dictionary of model mapping\nstatuses: a structure that defines the status of each node in the graph\nstatus_templates: a dictionary of status templates\nreverse_multiscale_mapping: a dictionary of mapping for other scales\nvar_need_init: a dictionary indicating if a variable needs to be initialized\ndependency_graph: the dependency graph of the models applied to the graph\nmodels: a dictionary of models\noutputs: a dictionary of outputs\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.MappedVar","page":"API","title":"PlantSimEngine.MappedVar","text":"MappedVar(source_organ, variable, source_variable, source_default)\n\nA variable mapped to another scale.\n\nArguments\n\nsource_organ: the organ(s) that are targeted by the mapping\nvariable: the name of the variable that is mapped\nsource_variable: the name of the variable from the source organ (the one that computes the variable)\nsource_default: the default value of the variable\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\nPlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.MultiNodeMapping","page":"API","title":"PlantSimEngine.MultiNodeMapping","text":"MultiNodeMapping(scale)\n\nType for the multiple node mapping, e.g. [:carbon_assimilation => [\"Leaf\"],]. Note that \"Leaf\" is given as a vector, which means :carbon_assimilation will be a vector of values taken from each \"Leaf\" in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.ObjectDependencyTrait","page":"API","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.\n\nThe following dependency traits are supported:\n\nIsObjectDependent: The model depends on other objects for its computation, it cannot be run in parallel.\nIsObjectIndependent: The model does not depend on other objects for its computation, it can be run in parallel.\n\nAll models are object dependent by default (i.e. IsObjectDependent). This is probably not right for the majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsObjectIndependent)\n\nIt is easy to override this trait for models that are object independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # false\n\nDefine a model that is object dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.RefVariable","page":"API","title":"PlantSimEngine.RefVariable","text":"RefVariable(reference_variable)\n\nA structure to manually flag a variable in a model to use the value of another variable at the same scale. This is used for variable renaming, when a variable is computed by a model but is used by another model with a different name.\n\nNote: we don't really rename the variable in the status (we need it for the other models), but we create a new one that is a reference to the first one.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.RefVector","page":"API","title":"PlantSimEngine.RefVector","text":"RefVector(field::Symbol, sts...)\nRefVector(field::Symbol, sts::Vector{<:Status})\nRefVector(v::Vector{Base.RefValue{T}})\n\nA vector of references to a field of a vector of structs. This is used to efficiently pass the values between scales.\n\nArguments\n\nfield: the field of the struct to reference\nsts...: the structs to reference\nsts::Vector{<:Status}: a vector of structs to reference\n\nExamples\n\njulia> using PlantSimEngine\n\nLet's take two Status structs:\n\njulia> status1 = Status(a = 1.0, b = 2.0, c = 3.0);\n\njulia> status2 = Status(a = 2.0, b = 3.0, c = 4.0);\n\nWe can make a RefVector of the field a of the structs st1 and st2:\n\njulia> rv = PlantSimEngine.RefVector(:a, status1, status2)\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWhich is equivalent to:\n\njulia> rv = PlantSimEngine.RefVector(:a, [status1, status2])\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\nWe can access the values of the RefVector:\n\njulia> rv[1]\n1.0\n\nUpdating the value in the RefVector will update the value in the original struct:\n\njulia> rv[1] = 10.0\n10.0\n\njulia> status1.a\n10.0\n\nWe can also make a RefVector from a vector of references:\n\njulia> vec = [Ref(1.0), Ref(2.0), Ref(3.0)]\n3-element Vector{Base.RefValue{Float64}}:\n Base.RefValue{Float64}(1.0)\n Base.RefValue{Float64}(2.0)\n Base.RefValue{Float64}(3.0)\n\njulia> rv = PlantSimEngine.RefVector(vec)\n3-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> rv[1]\n1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.SelfNodeMapping","page":"API","title":"PlantSimEngine.SelfNodeMapping","text":"SelfNodeMapping()\n\nType for the self node mapping, i.e. a node that maps onto itself. This is used to flag variables that will be referenced as a scalar value by other models. It can happen in two conditions:     - the variable is computed by another scale, so we need this variable to exist as an input to this scale (it is not      computed at this scale otherwise)     - the variable is used as input to another scale but as a single value (scalar), so we need to reference it as a scalar.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.SingleNodeMapping","page":"API","title":"PlantSimEngine.SingleNodeMapping","text":"SingleNodeMapping(scale)\n\nType for the single node mapping, e.g. [:soil_water_content => \"Soil\",]. Note that \"Soil\" is given as a scalar, which means that :soil_water_content will be a scalar value taken from the unique \"Soil\" node in the plant graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"API","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.\n\nThe following dependency traits are supported:\n\nIsTimeStepDependent: The model depends on other time-steps for its computation, it cannot be run in parallel.\nIsTimeStepIndependent: The model does not depend on other time-steps for its computation, it can be run in parallel.\n\nAll models are time-step dependent by default (i.e. IsTimeStepDependent). This is probably not right for the  majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsTimeStepIndependent)\n\nIt is easy to override this trait for models that are time-step independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # false\n\nDefine a model that is time-step dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.UninitializedVar","page":"API","title":"PlantSimEngine.UninitializedVar","text":"UninitializedVar(variable, value)\n\nA variable that is not initialized yet, it is given a name and a default value.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:ModelList","page":"API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tₗ at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}","page":"API","title":"PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!","text":"add_mapped_variables_with_outputs_as_inputs!(mapped_vars)\n\nAdd the variables that are computed at a scale and written to another scale into the mapping.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion; init_fun=init_fun_default)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\nusing PlantSimEngine.Examples\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status should have the same number of time-steps (2) than weather data (3).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}","page":"API","title":"PlantSimEngine.convert_reference_values!","text":"convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nConvert the variables that are MappedVar{SelfNodeMapping} or MappedVar{SingleNodeMapping} to RefValues that reference a  common value for the variable; and convert MappedVar{MultiNodeMapping} to RefVectors that reference the values for the variable in the source organs.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.convert_vars","page":"API","title":"PlantSimEngine.convert_vars","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.convert_vars!","page":"API","title":"PlantSimEngine.convert_vars!","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\nConvert the status variables to the type specified in the type promotion dictionary. Note: the mutating version only works with a dictionary of variables.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}","page":"API","title":"PlantSimEngine.convert_vars!","text":"convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)\n\nConverts the types of the variables in a mapping (mapped_vars) using the type_promotion dictionary.\n\nThe mapping should be a dictionary with organ name as keys and a dictionary of variables as values, with variable names as symbols and variable value as value.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.default_variables_from_mapping","page":"API","title":"PlantSimEngine.default_variables_from_mapping","text":"default_variables_from_mapping(mapped_vars, verbose=true)\n\nGet the default values for the mapped variables by recursively searching from the mapping to find the original mapped value.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_panel-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => namedtuple of variables => value.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\njulia> flatten_vars([:process1 => (var1 = -Inf, var2 = -Inf), :process2 => (var3 = -Inf, var4 = -Inf)])\n(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_mapping-Tuple{Any}","page":"API","title":"PlantSimEngine.get_mapping","text":"get_mapping(m)\n\nGet the mapping of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of pairs of symbols and strings or vectors of strings\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_models-Tuple{Any}","page":"API","title":"PlantSimEngine.get_models","text":"get_models(m)\n\nGet the models of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a vector of models\n\nExamples\n\njulia> using PlantSimEngine;\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nIf we just give a MultiScaleModel, we get its model as a one-element vector:\n\njulia> models = MultiScaleModel( model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], );\n\njulia> PlantSimEngine.get_models(models)\n1-element Vector{ToyCAllocationModel}:\n ToyCAllocationModel()\n\nIf we give a tuple of models, we get each model in a vector:\n\njulia> models2 = (  MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );\n\nNotice that we provide \"Soil\", not [\"Soil\"] in the mapping because a single value is expected for the mapping here.\n\njulia> PlantSimEngine.get_models(models2)\n2-element Vector{AbstractModel}:\n ToyAssimModel{Float64}(0.2)\n ToyCDemandModel{Float64}(10.0, 200.0)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_multiscale_default_value","page":"API","title":"PlantSimEngine.get_multiscale_default_value","text":"get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])\n\nGet the default value of a variable from a mapping.\n\nArguments\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: the variables mapped to each organ.\nval::Any: the variable to get the default value of.\nmapping_stacktrace::Vector{Any}: the stacktrace of the search for the value in ascendind the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.get_nsteps-Tuple{Any}","page":"API","title":"PlantSimEngine.get_nsteps","text":"get_nsteps(t)\n\nGet the number of steps in the object.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_status-Tuple{Any}","page":"API","title":"PlantSimEngine.get_status","text":"get_status(m)\n\nGet the status of a dictionary of model mapping.\n\nArguments\n\nm::Dict{String,Any}: a dictionary of model mapping\n\nReturns a Status or nothing.\n\nExamples\n\nSee get_models for examples.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_vars_not_propagated-Tuple{Any}","page":"API","title":"PlantSimEngine.get_vars_not_propagated","text":"get_vars_not_propagated(status)\n\nReturns all variables that are given for several time-steps in the status.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.hard_dependencies-Tuple{Any}","page":"API","title":"PlantSimEngine.hard_dependencies","text":"hard_dependencies(models; verbose::Bool=true)\nhard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)\n\nCompute the hard dependencies between models.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{T}, Tuple{N}, Tuple{NamedTuple{N, T}, Any}} where {N, T}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_node_status!","page":"API","title":"PlantSimEngine.init_node_status!","text":"init_node_status!(\n    node, \n    statuses, \n    mapped_vars, \n    reverse_multiscale_mapping,\n    vars_need_init=Dict{String,Any}(),\n    type_promotion=nothing;\n    check=true,\n    attribute_name=:plantsimengine_status)\n)\n\nInitialise the status of a plant graph node, taking into account the multiscale mapping, and add it to the statuses dictionary.\n\nArguments\n\nnode: the node to initialise\nstatuses: the dictionary of statuses by node type\nmapped_vars: the template of status for each node type\nreverse_multiscale_mapping: the variables that are mapped to other scales\nvar_need_init: the variables that are not initialised or computed by other models\nnodes_with_models: the nodes that have a model defined for their symbol\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors (see details)\nattribute_name: the name of the attribute to store the status in the node, by default: :plantsimengine_status\n\nDetails\n\nMost arguments can be computed from the graph and the mapping:\n\nstatuses is given by the first initialisation: statuses = Dict(i => Status[] for i in nodes_with_models)\nmapped_vars is computed using mapped_variables(), see code in init_statuses\nvars_need_init is computed using `varsneedinit = Dict(org => filter(x -> isa(last(x), UninitializedVar), vars) |> keys for (org, vars) in mapped_vars) |>\n\nfilter(x -> length(last(x)) > 0)`\n\nThe check argument is a boolean indicating if variables initialisation should be checked. In the case that some variables need initialisation (partially initialized mapping), we check if the value can be found  in the node attributes (using the variable name). If true, the function returns an error if the attribute is missing, otherwise it uses the default value from the model.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_simulation-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.init_simulation","text":"init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)\n\nInitialise the simulation. Returns:\n\nthe mtg\na status for each node by organ type, considering multi-scale variables\nthe dependency graph of the models\nthe models parsed as a Dict of organ type => NamedTuple of process => model mapping\nthe pre-allocated outputs\n\nArguments\n\nmtg: the MTG\nmapping::Dict{String,Any}: a dictionary of model mapping\nnsteps: the number of steps of the simulation\noutputs: the dynamic outputs needed for the simulation\ntype_promotion: the type promotion to use for the variables\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\nverbose: print information about errors in the mapping\n\nDetails\n\nThe function first computes a template of status for each organ type that has a model in the mapping. This template is used to initialise the status of each node of the MTG, taking into account the user-defined  initialisation, and the (multiscale) mapping. The mapping is used to make references to the variables that are defined at another scale, so that the values are automatically updated when the variable is changed at the other scale. Two types of multiscale variables are available: RefVector and MappedVar. The first one is used when the variable is mapped to a vector of nodes, and the second one when it is mapped to a single node. This  is given by the user through the mapping, using a string for a single node (e.g. => \"Leaf\"), and a vector of strings for a vector of nodes (e.g. => [\"Leaf\"] for one type of node or => [\"Leaf\", \"Internode\"] for several). \n\nThe function also computes the dependency graph of the models, i.e. the order in which the models should be called, considering the dependencies between them. The dependency graph is used to call the models in the right order when the simulation is run.\n\nNote that if a variable is not computed by models or initialised from the mapping, it is searched in the MTG attributes.  The value is not a reference to the one in the attribute of the MTG, but a copy of it. This is because we can't reference  a value in a Dict. If you need a reference, you can use a Ref for your variable in the MTG directly, and it will be  automatically passed as is.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_statuses","page":"API","title":"PlantSimEngine.init_statuses","text":"init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)\n\nGet the status of each node in the MTG by node type, pre-initialised considering multi-scale variables.\n\nArguments\n\nmtg: the plant graph\nmapping: a dictionary of model mapping\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\ntype_promotion: the type promotion to use for the variables\nverbose: print information when compiling the mapping\ncheck: whether to check the mapping for errors. Passed to init_node_status!.\n\nReturn\n\nA NamedTuple of status by node type, a dictionary of status templates by node type, a dictionary of variables mapped to other scales, a dictionary of variables that need to be initialised or computed by other models, and a vector of nodes that have a model defined for their symbol:\n\n(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}","page":"API","title":"PlantSimEngine.is_graph_cyclic","text":"is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)\n\nCheck if the dependency graph is cyclic.\n\nArguments\n\ndependency_graph::DependencyGraph: the dependency graph to check.\nfull_stack::Bool=false: if true, return the full stack of nodes that makes the cycle, otherwise return only the cycle.\nwarn::Bool=true: if true, print a stylised warning message when a cycle is detected.\n\nReturn a boolean indicating if the graph is cyclic, and the stack of nodes as a vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.mapped_variables","page":"API","title":"PlantSimEngine.mapped_variables","text":"mapped_variables(mapping, dependency_graph=hard_dependencies(mapping; verbose=false); verbose=false)\n\nGet the variables for each organ type from a dependency graph, with MappedVars for the multiscale mapping.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nverbose::Bool: whether to print the stacktrace of the search for the default value in the mapping.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.mapped_variables_no_outputs_from_other_scale","page":"API","title":"PlantSimEngine.mapped_variables_no_outputs_from_other_scale","text":"mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=hard_dependencies(mapping; verbose=false))\n\nGet the variables for each organ type from a dependency graph, without the variables that are outputs from another scale.\n\nArguments\n\nmapping::Dict{String,T}: the mapping between models and scales.\ndependency_graph::DependencyGraph: the first-order dependency graph where each model in the mapping is assigned a node. \n\nHowever, models that are identified as hard-dependencies are not given individual nodes. Instead, they are nested as child  nodes under other models.\n\nDetails\n\nThis function returns a dictionary with the (multiscale-) inputs and outputs variables for each organ type. \n\nNote that this function does not include the variables that are outputs from another scale and not computed by this scale, see mapped_variables_with_outputs_as_inputs for that.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.model_-Tuple{AbstractModel}","page":"API","title":"PlantSimEngine.model_","text":"model_(m::AbstractModel)\n\nGet the model of an AbstractModel (it is the model itself if it is not a MultiScaleModel).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"API","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel for different objects, or false otherwise. \n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over objects, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.parallelizable-Tuple{T} where T","page":"API","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model T or the whole dependency graph is parallelizable, i.e. if the model can be computed in parallel for different time-steps or objects. The default implementation returns false for all models.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is parallelizable:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable:\n\nparallelizable(MyModel()) # true\n\nOr if we want to be more explicit:\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pre_allocate_outputs-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.pre_allocate_outputs","text":"pre_allocate_outputs(statuses, outs, nsteps; check=true)\n\nPre-allocate the outputs of needed variable for each node type in vectors of vectors. The first level vectors have length nsteps, and the second level vectors have length n_nodes of this type.\n\nNote that we pre-allocate the vectors for the time-steps, but not for each organ, because we don't  know how many nodes will be in each organ in the future (organs can appear or disapear).\n\nArguments\n\nstatuses: a dictionary of status by node type\nouts: a dictionary of outputs by node type\nnsteps: the number of time-steps\ncheck: whether to check the mapping for errors. Default (true) returns an error if some variables do not exist.\n\nIf false and some variables are missing, return an info, remove the unknown variables and continue.\n\nReturns\n\nA dictionary of pre-allocated output of vector of time-step and vector of node of that type.\n\nExamples\n\njulia> using PlantSimEngine, MultiScaleTreeGraph, PlantSimEngine.Examples\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\nDefine the models mapping:\n\njulia> mapping = Dict( \"Plant\" =>  ( MultiScaleModel(  model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \n        MultiScaleModel(  model=ToyPlantRmModel(), mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],] ), ),\"Internode\" => ( ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004), Status(TT=10.0, carbon_biomass=1.0) ), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025), Status(aPPFD=1300.0, TT=10.0, carbon_biomass=1.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nImporting an example MTG provided by the package:\n\njulia> mtg = import_mtg_example();\n\njulia> statuses, = PlantSimEngine.init_statuses(mtg, mapping);\n\njulia> outs = Dict(\"Leaf\" => (:carbon_assimilation, :carbon_demand), \"Soil\" => (:soil_water_content,));\n\nPre-allocate the outputs as a dictionary:\n\njulia> preallocated_vars = PlantSimEngine.pre_allocate_outputs(statuses, outs, 2);\n\nThe dictionary has a key for each organ from which we want outputs:\n\njulia> collect(keys(preallocated_vars))\n2-element Vector{String}:\n \"Soil\"\n \"Leaf\"\n\nEach organ has a dictionary of variables for which we want outputs from,  with the pre-allocated empty vectors (one per time-step that will be filled with one value per node):\n\njulia> collect(keys(preallocated_vars[\"Leaf\"]))\n3-element Vector{Symbol}:\n :carbon_assimilation\n :node\n :carbon_demand\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.propagate_values!-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.propagate_values!","text":"propagate_values!(status1::Dict, status2::Dict, vars_not_propagated::Set)\n\nPropagates the values of all variables in status1 to status2, except for vars in vars_not_propagated.\n\nArguments\n\nstatus1::Dict: A dictionary containing the current values of variables.\nstatus2::Dict: A dictionary to which the values of variables will be propagated.\nvars_not_propagated::Set: A set of variables whose values should not be propagated.\n\nExamples\n\njulia> status1 = Status(var1 = 15.0, var2 = 0.3);\n\njulia> status2 = Status(var1 = 16.0, var2 = -Inf);\n\njulia> vars_not_propagated = (:var1,);\n\n\njldoctest st1 julia> PlantSimEngine.propagatevalues!(status1, status2, varsnot_propagated);\n\n\n\njldoctest st1 julia> status2.var2 == status1.var2 true\n\n\n\njldoctest st1 julia> status2.var1 == status1.var1 false ```\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.ref_var-Tuple{Any}","page":"API","title":"PlantSimEngine.ref_var","text":"ref_var(v)\n\nCreate a reference to a variable. If the variable is already a Base.RefValue, it is returned as is, else it is returned as a Ref to the copy of the value, or a Ref to the RefVector (in case v is a RefVector).\n\nExamples\n\njulia> using PlantSimEngine;\n\njulia> PlantSimEngine.ref_var(1.0)\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var([1.0])\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(Base.RefValue(1.0))\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var(Base.RefValue([1.0]))\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))\nBase.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"API","title":"PlantSimEngine.reverse_mapping","text":"reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)\nreverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\nGet the reverse mapping of a dictionary of model mapping, i.e. the variables that are mapped to other scales, or in other words, what variables are given to other scales from a given scale. This is used for e.g. knowing which scales are needed to add values to others.\n\nArguments\n\nmapping::Dict{String,Any}: A dictionary of model mapping.\nall::Bool: Whether to get all the variables that are mapped to other scales, including the ones that are mapped as single values.\n\nReturns\n\nA dictionary of organs (keys) with a dictionary of organs => vector of pair of variables. You can read the output as: \"for each organ (source organ), to which other organ (target organ) it is giving values for its own variables. Then for each of these source organs, which variable it is giving to the target organ (first symbol in the pair), and to which variable it is mapping the value into the target organ (second symbol in the pair)\".\n\nExamples\n\njulia> using PlantSimEngine\n\nImport example models (can be found in the examples folder of the package, or in the Examples sub-modules): \n\njulia> using PlantSimEngine.Examples;\n\njulia> mapping = Dict( \"Plant\" => MultiScaleModel( model=ToyCAllocationModel(), mapping=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \"Internode\" => ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapping=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\nNotice we provide \"Soil\", not [\"Soil\"] in the mapping of the ToyAssimModel for the Leaf. This is because we expect a single value for the soil_water_content to be mapped here (there is only one soil). This allows  to get the value as a singleton instead of a vector of values.\n\njulia> PlantSimEngine.reverse_mapping(mapping)\nDict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:\n  \"Soil\"      => Dict(\"Leaf\"=>Dict(:soil_water_content=>:soil_water_content))\n  \"Internode\" => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n  \"Leaf\"      => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"API","title":"PlantSimEngine.save_results!","text":"save_results!(object::GraphSimulation, i)\n\nSave the results of the simulation for time-step i into the  object. For a GraphSimulation object, this will save the results from the status(object) in the outputs(object).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{5, Any}","page":"API","title":"PlantSimEngine.search_inputs_in_multiscale_output","text":"search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies at other scales.\norgan::String: the organ for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => [:subprocess => (:var1, :var2)].\nsoft_dep_graphs::Dict{String, ...}: a dict of organ => (softdepgraph, inputs, outputs).\nrev_mapping::Dict{Symbol, Symbol}: a dict of mapped variable => source variable (this is the reverse mapping).\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies variables found in outputs of other scales for each process, e.g.:\n\nDict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:\n    \"Internode\" => Dict(:carbon_demand=>[:carbon_demand])\n    \"Leaf\"      => Dict(:carbon_assimilation=>[:carbon_assimilation], :carbon_demand=>[:carbon_demand])\n\nThis means that the variable :carbon_demand is computed by the process :carbon_demand at the scale \"Internode\", and the variable :carbon_assimilation  is computed by the process :carbon_assimilation at the scale \"Leaf\". Those variables are used as inputs for the process that we just passed.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.soft_dependencies","page":"API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}","page":"API","title":"PlantSimEngine.status_from_template","text":"status_from_template(d::Dict{Symbol,Any})\n\nCreate a status from a template dictionary of variables and values. If the values  are already RefValues or RefVectors, they are used as is, else they are converted to Refs.\n\nArguments\n\nd::Dict{Symbol,Any}: A dictionary of variables and values.\n\nReturns\n\nA Status.\n\nExamples\n\njulia> using PlantSimEngine\n\njulia> a, b = PlantSimEngine.status_from_template(Dict(:a => 1.0, :b => 2.0));\n\njulia> a\n1.0\n\njulia> b\n2.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"API","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel over time-steps, or false otherwise.\n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over time-steps, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\nobject_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over objects:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}","page":"API","title":"PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!","text":"transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)\n\nFind variables that are inputs to other scales as a SingleNodeMapping and declare them as MappedVar from themselves in the source scale. This helps us declare it as a reference when we create the template status objects.\n\nThese node are found in the mapping as [:variable_name => \"Plant\"] (notice that \"Plant\" is a scalar value).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\n# Including example processes and models:\nusing PlantSimEngine.Examples;\n\nfunction f(node)\n    node.value\nend\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables_multiscale","page":"API","title":"PlantSimEngine.variables_multiscale","text":"variables_multiscale(node, organ, mapping, st=NamedTuple())\n\nGet the variables of a HardDependencyNode, taking into account the multiscale mapping, i.e. defining variables as MappedVar if they are mapped to another scale. The default values are  taken from the model if not given by the user (st), and are marked as UninitializedVar if  they are inputs of the node.\n\nReturn a NamedTuple with the variables and their default values.\n\nArguments\n\nnode::HardDependencyNode: the node to get the variables from.\norgan::String: the organ type, e.g. \"Leaf\".\nvars_mapping::Dict{String,T}: the mapping of the models (see details below).\nst::NamedTuple: an optional named tuple with default values for the variables.\n\nDetails\n\nThe vars_mapping is a dictionary with the organ type as key and a dictionary as value. It is  computed from the user mapping like so:\n\nfull_vars_mapping = Dict(first(mod) => Dict(get_mapping(last(mod))) for mod in mapping)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}","page":"API","title":"PlantSimEngine.variables_outputs_from_other_scale","text":"variables_outputs_from_other_scale(mapped_vars)\n\nFor each organ in the mapped_vars, find the variables that are outputs from another scale and not computed at this scale otherwise. This function is used with mapped_variables\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"API/#Example-models","page":"API","title":"Example models","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"PlantSimEngine provides example processes and models to users. They are available from a sub-module called Examples. To get access to these models, you can simply use this sub-module:","category":"page"},{"location":"API/","page":"API","title":"API","text":"using PlantSimEngine.Examples","category":"page"},{"location":"API/","page":"API","title":"API","text":"The models are detailed below.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine.Examples]\nPublic = true\nPrivate = true","category":"page"},{"location":"API/#PlantSimEngine.Examples","page":"API","title":"PlantSimEngine.Examples","text":"A sub-module with example models.\n\nExamples used in the documentation for a set of multiscale models. The models can be found in the examples folder of the package, and are stored  in the following files:\n\nToyAssimModel.jl\nToyCDemandModel.jl\nToyCAllocationModel.jl\nToySoilModel.jl\n\nExamples\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nToyAssimModel()\n\n\n\n\n\n","category":"module"},{"location":"API/#PlantSimEngine.Examples.AbstractCarbon_AllocationModel","page":"API","title":"PlantSimEngine.Examples.AbstractCarbon_AllocationModel","text":"carbon_allocation process abstract model. \n\nAll models implemented to simulate the carbon_allocation process must be a subtype of this type, e.g.  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","page":"API","title":"PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","text":"carbon_assimilation process abstract model. \n\nAll models implemented to simulate the carbon_assimilation process must be a subtype of this type, e.g.  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractCarbon_BiomassModel","page":"API","title":"PlantSimEngine.Examples.AbstractCarbon_BiomassModel","text":"carbon_biomass process abstract model. \n\nAll models implemented to simulate the carbon_biomass process must be a subtype of this type, e.g.  struct MyCarbon_BiomassModel <: AbstractCarbon_BiomassModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractCarbon_DemandModel","page":"API","title":"PlantSimEngine.Examples.AbstractCarbon_DemandModel","text":"carbon_demand process abstract model. \n\nAll models implemented to simulate the carbon_demand process must be a subtype of this type, e.g.  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractDegreedaysModel","page":"API","title":"PlantSimEngine.Examples.AbstractDegreedaysModel","text":"Degreedays process abstract model. \n\nAll models implemented to simulate the Degreedays process must be a subtype of this type, e.g.  struct MyDegreedaysModel <: AbstractDegreedaysModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractDegreedaysModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractGrowthModel","page":"API","title":"PlantSimEngine.Examples.AbstractGrowthModel","text":"growth process abstract model. \n\nAll models implemented to simulate the growth process must be a subtype of this type, e.g.  struct MyGrowthModel <: AbstractGrowthModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractGrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractLai_DynamicModel","page":"API","title":"PlantSimEngine.Examples.AbstractLai_DynamicModel","text":"LAI_Dynamic process abstract model. \n\nAll models implemented to simulate the LAI_Dynamic process must be a subtype of this type, e.g.  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","page":"API","title":"PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","text":"leaf_surface process abstract model. \n\nAll models implemented to simulate the leaf_surface process must be a subtype of this type, e.g.  struct MyLeaf_SurfaceModel <: AbstractLeaf_SurfaceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLeaf_SurfaceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractLight_InterceptionModel","page":"API","title":"PlantSimEngine.Examples.AbstractLight_InterceptionModel","text":"light_interception process abstract model. \n\nAll models implemented to simulate the light_interception process must be a subtype of this type, e.g.  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractLight_PartitioningModel","page":"API","title":"PlantSimEngine.Examples.AbstractLight_PartitioningModel","text":"light_partitioning process abstract model. \n\nAll models implemented to simulate the light_partitioning process must be a subtype of this type, e.g.  struct MyLight_PartitioningModel <: AbstractLight_PartitioningModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractLight_PartitioningModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","page":"API","title":"PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","text":"maintenance_respiration process abstract model. \n\nAll models implemented to simulate the maintenance_respiration process must be a subtype of this type, e.g.  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","page":"API","title":"PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","text":"organ_emergence process abstract model. \n\nAll models implemented to simulate the organ_emergence process must be a subtype of this type, e.g.  struct MyOrgan_EmergenceModel <: AbstractOrgan_EmergenceModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractOrgan_EmergenceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess1Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess1Model","text":"process1 process abstract model. \n\nAll models implemented to simulate the process1 process must be a subtype of this type, e.g.  struct MyProcess1Model <: AbstractProcess1Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess1Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess2Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess2Model","text":"process2 process abstract model. \n\nAll models implemented to simulate the process2 process must be a subtype of this type, e.g.  struct MyProcess2Model <: AbstractProcess2Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess2Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess3Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess3Model","text":"process3 process abstract model. \n\nAll models implemented to simulate the process3 process must be a subtype of this type, e.g.  struct MyProcess3Model <: AbstractProcess3Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess3Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess4Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess4Model","text":"process4 process abstract model. \n\nAll models implemented to simulate the process4 process must be a subtype of this type, e.g.  struct MyProcess4Model <: AbstractProcess4Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess4Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess5Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess5Model","text":"process5 process abstract model. \n\nAll models implemented to simulate the process5 process must be a subtype of this type, e.g.  struct MyProcess5Model <: AbstractProcess5Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess5Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess6Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess6Model","text":"process6 process abstract model. \n\nAll models implemented to simulate the process6 process must be a subtype of this type, e.g.  struct MyProcess6Model <: AbstractProcess6Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess6Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractProcess7Model","page":"API","title":"PlantSimEngine.Examples.AbstractProcess7Model","text":"process7 process abstract model. \n\nAll models implemented to simulate the process7 process must be a subtype of this type, e.g.  struct MyProcess7Model <: AbstractProcess7Model end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractProcess7Model)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.AbstractSoil_WaterModel","page":"API","title":"PlantSimEngine.Examples.AbstractSoil_WaterModel","text":"soil_water process abstract model. \n\nAll models implemented to simulate the soil_water process must be a subtype of this type, e.g.  struct MySoil_WaterModel <: AbstractSoil_WaterModel end.\n\nYou can list all models implementing this process using subtypes:\n\nExamples\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Beer","page":"API","title":"PlantSimEngine.Examples.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nRequired inputs: LAI in m² m⁻². Required meteorology data: Ri_PAR_f, the incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹).\n\nOutput: aPPFD, the absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process1Model","page":"API","title":"PlantSimEngine.Examples.Process1Model","text":"Process1Model(a)\n\nA dummy model implementing a \"process1\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process2Model","page":"API","title":"PlantSimEngine.Examples.Process2Model","text":"Process2Model()\n\nA dummy model implementing a \"process2\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process3Model","page":"API","title":"PlantSimEngine.Examples.Process3Model","text":"Process3Model()\n\nA dummy model implementing a \"process3\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process4Model","page":"API","title":"PlantSimEngine.Examples.Process4Model","text":"Process4Model()\n\nA dummy model implementing a \"process4\" process for testing purposes. It computes the inputs needed for the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process5Model","page":"API","title":"PlantSimEngine.Examples.Process5Model","text":"Process5Model()\n\nA dummy model implementing a \"process5\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process6Model","page":"API","title":"PlantSimEngine.Examples.Process6Model","text":"Process6Model()\n\nA dummy model implementing a \"process6\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3, but also from process 7 that is itself independant.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.Process7Model","page":"API","title":"PlantSimEngine.Examples.Process7Model","text":"Process7Model()\n\nA dummy model implementing a \"process7\" process for testing purposes. It is independent (needs :var0 only as for Process4Model), but its outputs are used by Process6Model, so it is a soft-coupling.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyAssimGrowthModel","page":"API","title":"PlantSimEngine.Examples.ToyAssimGrowthModel","text":"ToyAssimGrowthModel(Rm_factor, Rg_cost)\nToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\nRm_factor=0.5: the fraction of assimilation that goes into maintenance respiration\nRg_cost=1.2: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the assimilation, in gC m⁻² time-step⁻¹\nRm: the maintenance respiration, in gC m⁻² time-step⁻¹\nRg: the growth respiration, in gC m⁻² time-step⁻¹\nbiomass_increment: the daily biomass increment, in gC m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyAssimModel","page":"API","title":"PlantSimEngine.Examples.ToyAssimModel","text":"ToyAssimModel(LUE)\n\nComputes the assimilation of a plant (= photosynthesis).\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\nsoil_water_content: the soil water content, in %\n\nOutputs\n\ncarbon_assimilation: the assimilation or photosynthesis, also sometimes denoted A, in gC m⁻² time-step⁻¹\n\nDetails\n\nThe assimilation is computed as the product of the absorbed photosynthetic photon flux density (aPPFD) and the light use efficiency (LUE), so the units of the assimilation usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of aPPFD, e.g.  if aPPFD is in mol[PAR] plant⁻¹ time-step⁻¹, the assimilation will be in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyCAllocationModel","page":"API","title":"PlantSimEngine.Examples.ToyCAllocationModel","text":"ToyCAllocationModel()\n\nComputes the carbon allocation to each organ of a plant based on the plant total carbon offer and individual organ demand. This model should be used at the plant scale, because it first computes the carbon availaible for allocation as the minimum between the total demand  (sum of organs' demand) and total carbon offer (sum of organs' assimilation - total maintenance respiration), and then allocates the carbon relative  to each organ's demand.\n\nInputs\n\ncarbon_assimilation: a vector of the assimilation of all photosynthetic organs, usually in gC m⁻² time-step⁻¹\nRm: the maintenance respiration of the plant, usually in gC m⁻² time-step⁻¹\ncarbon_demand: a vector of the carbon demand of the organs, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the carbon assimilation, usually in gC m⁻² time-step⁻¹\n\nDetails\n\nThe units usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of the inputs, e.g. in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyCBiomassModel","page":"API","title":"PlantSimEngine.Examples.ToyCBiomassModel","text":"ToyCBiomassModel(construction_cost)\n\nComputes the carbon biomass of an organ based on the carbon allocation and construction cost.\n\nArguments\n\nconstruction_cost: the construction cost of the organ, usually in gC gC⁻¹. Should be understood as the amount of carbon needed to build 1g of carbon biomass.\n\nInputs\n\ncarbon_allocation: the carbon allocation to the organ for the time-step, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_biomass_increment: the increment of carbon biomass, usually in gC time-step⁻¹\ncarbon_biomass: the carbon biomass, usually in gC\ngrowth_respiration: the growth respiration, usually in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyCDemandModel","page":"API","title":"PlantSimEngine.Examples.ToyCDemandModel","text":"ToyCDemandModel(optimal_biomass, development_duration)\nToyCDemandModel(; optimal_biomass, development_duration)\n\nComputes the carbon demand of an organ depending on its biomass under optimal conditions and the duration of its development in degree days. The model assumes that the carbon demand is linear througout the duration of the development.\n\nArguments\n\noptimal_biomass: the biomass of the organ under optimal conditions, in gC\ndevelopment_duration: the duration of the development of the organ, in degree days\n\nInputs\n\nTT: the thermal time, in degree days\n\nOutputs\n\ncarbon_demand: the carbon demand, in gC\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyDegreeDaysCumulModel","page":"API","title":"PlantSimEngine.Examples.ToyDegreeDaysCumulModel","text":"ToyDegreeDaysCumulModel(;init_TT=0.0, T_base=10.0, T_max=43.0)\n\nComputes the thermal time in degree days and cumulated degree-days based on the average daily temperature (T), the initial cumulated degree days, the base temperature below which there is no growth, and the maximum  temperature for growh.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyInternodeEmergence","page":"API","title":"PlantSimEngine.Examples.ToyInternodeEmergence","text":"ToyInternodeEmergence(;init_TT=0.0, TT_emergence = 300)\n\nComputes the organ emergence based on cumulated thermal time since last event.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyLAIModel","page":"API","title":"PlantSimEngine.Examples.ToyLAIModel","text":"ToyLAIModel(;max_lai=8.0, dd_incslope=800, inc_slope=110, dd_decslope=1500, dec_slope=20)\n\nComputes the Leaf Area Index (LAI) based on a sigmoid function of thermal time.\n\nArguments\n\nmax_lai: the maximum LAI value\ndd_incslope: the thermal time at which the LAI starts to increase\ninc_slope: the slope of the increase\ndd_decslope: the thermal time at which the LAI starts to decrease\ndec_slope: the slope of the decrease\n\nInputs\n\nTT_cu: the cumulated thermal time since the beginning of the simulation, usually in °C days\n\nOutputs\n\nLAI: the Leaf Area Index, usually in m² m⁻²\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","page":"API","title":"PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","text":"ToyLAIfromLeafAreaModel()\n\nComputes the Leaf Area Index (LAI) of the scene based on the plants leaf area.\n\nArguments\n\nscene_area: the area of the scene, usually in m²\n\nInputs\n\nsurface: a vector of plant leaf surfaces, usually in m²\n\nOutputs\n\nLAI: the Leaf Area Index of the scene, usually in m² m⁻²\ntotal_surface: the total surface of the plants, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyLeafSurfaceModel","page":"API","title":"PlantSimEngine.Examples.ToyLeafSurfaceModel","text":"ToyLeafSurfaceModel(SLA)\n\nComputes the individual leaf surface from its biomass using the SLA.\n\nArguments\n\nSLA: the specific leaf area, usually in m² gC⁻¹. Should be understood as the surface area of a leaf per unit of carbon biomass.\n\nValues typically range from 0.002 to 0.027 m² gC⁻¹.\n\nInputs\n\ncarbon_biomass: the carbon biomass of the leaf, usually in gC\n\nOutputs\n\nsurface: the leaf surface, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyLightPartitioningModel","page":"API","title":"PlantSimEngine.Examples.ToyLightPartitioningModel","text":"ToyLightPartitioningModel()\n\nComputes the light partitioning based on relative surface.\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density at the larger scale (e.g. scene), in mol[PAR] m⁻² time-step⁻¹ \n\nOutputs\n\naPPFD: the assimilation or photosynthesis, also sometimes denoted A, in gC time-step⁻¹\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyMaintenanceRespirationModel","page":"API","title":"PlantSimEngine.Examples.ToyMaintenanceRespirationModel","text":"RmQ10FixedN(Q10, Rm_base, T_ref, P_alive, nitrogen_content)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nRm_base: Base maintenance respiration (gC gDM⁻¹ time-step⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nnitrogen_content: nitrogen content of the organ (gN gC⁻¹)\n\nInputs\n\ncarbon_biomass: the carbon biomass of the organ in gC\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","page":"API","title":"PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","text":"ToyPlantLeafSurfaceModel()\n\nComputes the leaf surface at plant scale by summing the individual leaf surfaces.\n\nInputs\n\nleaf_surfaces: a vector of leaf surfaces, usually in m²\n\nOutputs\n\nsurface: the leaf surface at plant scale, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyPlantRmModel","page":"API","title":"PlantSimEngine.Examples.ToyPlantRmModel","text":"ToyPlantRmModel()\n\nTotal plant maintenance respiration based on the sum of Rm_organs, the maintenance respiration of the organs.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC time-step⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToyRUEGrowthModel","page":"API","title":"PlantSimEngine.Examples.ToyRUEGrowthModel","text":"ToyRUEGrowthModel(efficiency)\n\nComputes the carbon biomass increment of a plant based on the radiation use efficiency principle.\n\nArguments\n\nefficiency: the radiation use efficiency, in gC[biomass] mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\nbiomass_increment: the daily biomass increment, in gC[biomass] m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC[biomass] m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.ToySoilWaterModel","page":"API","title":"PlantSimEngine.Examples.ToySoilWaterModel","text":"ToySoilWaterModel(values=[0.5])\n\nA toy model to compute the soil water content. The model simply take a random value in the values range using rand.\n\nOutputs\n\nsoil_water_content: the soil water content (%).\n\nArguments\n\nvalues: a range of soil_water_content values to sample from. Can be a vector of values [0.5,0.6] or a range 0.1:0.1:1.0. Default is [0.5].\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Examples.import_mtg_example-Tuple{}","page":"API","title":"PlantSimEngine.Examples.import_mtg_example","text":"import_mtg_example()\n\nReturns an example multiscale tree graph (MTG) with a scene, a soil, and a plant with two internodes and two leaves.\n\nExamples\n\njulia> using PlantSimEngine.Examples\n\njulia> import_mtg_example()\n/ 1: Scene\n├─ / 2: Soil\n└─ + 3: Plant\n   └─ / 4: Internode\n      ├─ + 5: Leaf\n      └─ < 6: Internode\n         └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.fit-Tuple{Type{PlantSimEngine.Examples.Beer}, Any}","page":"API","title":"PlantSimEngine.fit","text":"fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n\nCompute the k parameter of the Beer-Lambert law from measurements.\n\nArguments\n\n::Type{Beer}: the model type\ndf: a DataFrame with the following columns:\naPPFD: the measured absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹\nLAI: the measured leaf area index in m² m⁻²\nRi_PAR_f: the measured incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹)\n\nExamples\n\nImport the example models defined in the Examples sub-module:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\n\nCreate a model list with a Beer model, and fit it to the data:\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.run!-2","page":"API","title":"PlantSimEngine.run!","text":"run!(::Beer, object, meteo, constants=Constants(), extra=nothing)\n\nComputes the photosynthetic photon flux density (aPPFD, µmol m⁻² s⁻¹) absorbed by an  object using the incoming PAR radiation flux (Ri_PAR_f, W m⁻²) and the Beer-Lambert law of light extinction.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for LAI (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\nextra = nothing: extra arguments, not used here.\n\nExamples\n\nm = ModelList(Beer(0.5), status=(LAI=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_q=300.0)\n\nrun!(m, meteo)\n\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"reducing_dof/#Reducing-the-DoF","page":"Reducing DoF","title":"Reducing the DoF","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"reducing_dof/#Introduction","page":"Reducing DoF","title":"Introduction","text":"","category":"section"},{"location":"reducing_dof/#Why-reducing-the-degrees-of-freedom","page":"Reducing DoF","title":"Why reducing the degrees of freedom","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Reducing the degrees of freedom in a model, by forcing certain variables to measurements, can be useful for several reasons:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It can prevent overfitting by constraining the model and making it less complex.\nIt can help to better calibrate the other components of the model by reducing the co-variability of the variables (see Parameter degeneracy).\nIt can lead to more interpretable models by identifying the most important variables and relationships.\nIt can improve the computational efficiency of the model by reducing the number of variables that need to be estimated.\nIt can also help to ensure that the model is consistent with known physical or observational constraints and improve the credibility of the model and its predictions.\nIt is important to note that over-constraining a model can also lead to poor fits and false conclusions, so it is essential to carefully consider which variables to constrain and to what measurements.","category":"page"},{"location":"reducing_dof/#Parameter-degeneracy","page":"Reducing DoF","title":"Parameter degeneracy","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"The concept of \"degeneracy\" or \"parameter degeneracy\" in a model occurs when two or more variables in a model are highly correlated, and small changes in one variable can be compensated by small changes in another variable, so that the overall predictions of the model remain unchanged. Degeneracy can make it difficult to estimate the true values of the variables and to determine the unique solutions of the model. It also makes the model sensitive to the initial conditions (e.g. the parameters) and the optimization algorithm used.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Degeneracy is related to the concept of \"co-variability\" or \"collinearity\", which refers to the degree of linear relationship between two or more variables. In a degenerate model, two or more variables are highly co-variate, meaning that they are highly correlated and can produce similar predictions. By fixing one variable to a measured value, the model will have less flexibility to adjust the other variables, which can help to reduce the co-variability and improve the robustness of the model.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"This is an important topic in plant/crop modelling, as the models are very often degenerate. It is most often referred to as \"multicollinearity\" in the field. In the context of model calibration, it is also known as \"parameter degeneracy\" or \"parameter collinearity\". In the context of model reduction, it is also known as \"redundancy\" or \"redundant variables\".","category":"page"},{"location":"reducing_dof/#Reducing-the-DoF-in-PlantSimEngine","page":"Reducing DoF","title":"Reducing the DoF in PlantSimEngine","text":"","category":"section"},{"location":"reducing_dof/#Soft-coupled-models","page":"Reducing DoF","title":"Soft-coupled models","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"PlantSimEngine provides a simple way to reduce the degrees of freedom in a model by constraining the values of some variables to measurements.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's define a model list as usual with the seven processes from examples/dummy.jl:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's say that m is our complete model, and that we want to reduce the degrees of freedom by constraining the value of var9 to a measurement, which was previously computed by Process7Model, a soft-dependency model. It is very easy to do this in PlantSimEngine: just remove the model from the model list and give the value of the measurement in the status:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nrun!(m2, meteo)\n\nstatus(m2)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"And that's it ! The models that depend on var9 will now use the measured value of var9 instead of the one computed by Process7Model.","category":"page"},{"location":"reducing_dof/#Hard-coupled-models","page":"Reducing DoF","title":"Hard-coupled models","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It is a bit more complicated to reduce the degrees of freedom in a model that is hard-coupled to another model, because it calls the run! method of the other model.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"In this case, we need to replace the old model with a new model that forces the value of the variable to the measurement. This is done by giving the measurements as inputs of the new model, and returning nothing so the value is unchanged. ","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Starting from the model list with the seven processes from above, but this time let's say that we want to reduce the degrees of freedom by constraining the value of var3 to a measurement, which was previously computed by Process1Model, a hard-dependency model. It is very easy to do this in PlantSimEngine: just replace the model by a new model that forces the value of var3 to the measurement:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"struct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Now we can create a new model list with the new model for process7:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nrun!(m3, meteo)\n\nstatus(m3)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"note: Note\nWe could also eventually provide the measured variable using the meteo data, but it is not recommended. The meteo data is meant to be used for the meteo variables only, and not for the model variables. It is better to use the status for that.","category":"page"},{"location":"model_coupling/multiscale/#Multi-scale-modeling","page":"Multi-scale modelling","title":"Multi-scale modeling","text":"","category":"section"},{"location":"model_coupling/multiscale/#What-is-multi-scale-modeling?","page":"Multi-scale modelling","title":"What is multi-scale modeling?","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Multi-scale modeling is the process of simulating a system at multiple levels of detail simultaneously. For example, some models can run at the organ scale while others run at the plot scale. Each model can access variables at its scale and other scales if needed, allowing for a more comprehensive system representation. It can also help identify emergent properties that are not apparent at a single level of detail. ","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"For example, a model of photosynthesis at the leaf scale can be combined with a model of carbon allocation at the plant scale to simulate the growth and development of the plant. Another example is a combination of models to simulate the energy balance of a forest. To simulate it, you need a model for each organ type of the plant, another for the soil, and finally, one at the plot scale, integrating all others.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"PlantSimEngine provides a framework for multi-scale modeling to seamlessly integrate models at different scales, keeping all nice functionalities provided at one scale. A nice feature is that models do not need to be aware of the scale at which they are running, nor about the scales at which their inputs are computed, or outputs will be given, which means the model can be reused at different scales or no scale.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"PlantSimEngine automatically computes the dependency graph between mono and multi-scale models, considering every combination of models at any scale, to determine the order of model execution. This means that the user does not need to worry about the order of model execution and can focus on the model definition and the mapping between models and scales.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Using PlantSimEngine for multi-scale modeling is relatively easy and follows the same rules as mono-scale models. Let's dive into the details with a short tutorial.","category":"page"},{"location":"model_coupling/multiscale/#Simple-mapping-between-models-and-scales","page":"Multi-scale modelling","title":"Simple mapping between models and scales","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"To get started, we have to define a mapping between models and scales.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Let's import the PlantSimEngine package and example models we will use in this tutorial:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"using PlantSimEngine\nusing PlantSimEngine.Examples # Import some example models","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nThe Examples submodule exports a few simple models we will use in this tutorial. The models are also found in the examples folder of the package.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We now have access to models for the simulation of different processes. We can associate each model with a scale by defining a mapping between models and scales. The mapping is a dictionary with the name of the scale as the key and the model as the value. For example, we can define a mapping to simulate the assimilation process at the leaf scale with ToyAssimModel as follows:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"mapping = Dict(\"Leaf\" => ToyAssimModel())","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"In this example, the dictionary's key is the name of the scale (\"Leaf\"), and the value is the model. The model is an example model provided by PlantSimEngine, so we must prefix it with the module name.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We can check if the mapping is valid by calling to_initialize:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"to_initialize(mapping)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The to_initialize function checks if models from any scale need further initialization before simulation. This is the case when some input variables of the model are not computed by another model. In this example, the ToyAssimModel needs :aPPFD and :soil_water_content as inputs. To run a simulation, we must provide a value for the variables or a model that simulates them.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The initialization values for the variables can be provided using the Status type along with the model, e.g.:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"mapping = Dict(\n    \"Leaf\" => (\n        ToyAssimModel(),\n        Status(aPPFD=1300.0, soil_water_content=0.5),\n    ),\n)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nThe model and the Status are provided as a Tuple to the \"Leaf\" scale.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"If we re-execute to_initialize, we get an empty dictionary, meaning the mapping is valid, and we can start the simulation:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"to_initialize(mapping)","category":"page"},{"location":"model_coupling/multiscale/#Multiscale-mapping-between-models-and-scales","page":"Multi-scale modelling","title":"Multiscale mapping between models and scales","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"In our previous example, we provided the value for the soil_water_content variable. However, we could also provide a model that simulates it at the soil scale. The only difference now is that we have to tell PlantSimEngine that our  ToyAssimModel is now multiscale and takes the soil_water_content variable from the \"Soil\" scale. We can do that by wrapping the ToyAssimModel in a MultiScaleModel:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"mapping = Dict(\n    \"Soil\" => ToySoilWaterModel(),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\" => :soil_water_content,],\n        ),\n        Status(aPPFD=1300.0),        \n    ),\n);\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The MultiScaleModel takes two arguments: the model and the mapping between the model and the scales. The mapping is a vector of pairs of pairs mapping the variable's name with the name of the scale its value comes from, and the name of the variable at that scale. In this example, we map the soil_water_content variable at scale \"Leaf\" to the soil_water_content variable at the \"Soil\" scale. If the name of the variable is the same between both scales, we can omit the variable name at the origin scale, e.g. [:soil_water_content => \"Soil\"].","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nThe variable aPPFD is still provided in the Status type as a constant value.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We can check again if the mapping is valid by calling to_initialize:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"to_initialize(mapping)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"to_initialize returns an empty dictionary, meaning the mapping is valid.","category":"page"},{"location":"model_coupling/multiscale/#More-on-MultiScaleModel","page":"Multi-scale modelling","title":"More on MultiScaleModel","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"MultiScaleModel is a wrapper around a model that allows it to take inputs or give outputs from other scales. It takes two arguments: the model and the mapping between the model and the scales. The mapping is a vector of pairs of pairs mapping the variable's name with the name of the scale its value comes from, and its name at that scale.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The variable can map a single value if there is only one node to map to or a vector of values if there are several. It can also map to several types of nodes at the same time.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Let's take a look at a more complex example of a mapping:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapping=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\", :aPPFD => \"Plant\"],\n        ),\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=0.5),\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"In this example, we expect to make a simulation at five different scales: \"Scene\", \"Plant\", \"Internode\", \"Leaf\", and \"Soil\". The \"Scene\" scale represents the whole scene, where one or several plants can live. The \"Plant\" scale is, well, the whole plant scale, \"Internode\" and \"Leaf\" are organ scales, and \"Soil\" is the soil scale. This mapping is used to compute the carbon allocation (ToyCAllocationModel) to the different organs of the plant (\"Leaf\" and \"Internode\") from the assimilation at the \"Leaf\" scale (i.e. the offer) and their carbon demand (ToyCDemandModel). The \"Soil\" scale is used to compute the soil water content (ToySoilWaterModel), which is needed to calculate the assimilation at the \"Leaf\" scale (ToyAssimModel). We also can note that we compute the maintenance respiration at the \"Leaf\" and \"Internode\" scales (ToyMaintenanceRespirationModel), which is summed up to compute the total maintenance respiration at the \"Plant\" scale (ToyPlantRmModel). ","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We see that all scales are interconnected, with computations at the organ scale that may depend on the soil scale and at the plant scale that depends on the organ scale and scene scale.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Something important to note here is that we have different ways to define the mapping for the MultiScaleModel. For example, we have :carbon_assimilation => [\"Leaf\"] at the plant scale for ToyCAllocationModel. This mapping means that the variable carbon_assimilation is mapped to the \"Leaf\" scale. However, we could also have :carbon_assimilation => \"Leaf\", which is not completely equivalent.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nNote the difference between :carbon_assimilation => [\"Leaf\"] and :carbon_assimilation => \"Leaf\" is that \"Leaf\" is given as a vector in the first definition, and as a scalar in the second one.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The difference is that the first one maps to a vector of values, while the second one maps to a single value. The first one is useful when we don't know how many nodes there will be in the plant of type \"Leaf\". In this case, the values are available as a vector in the carbon_assimilation variable of the status inside the model. The second one should only be used if we are sure that there will be only one node at this scale, and in this case, the one and single value is given as a scalar in the carbon_assimilation variable of the status inside the model.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"A third form for the mapping would be :carbon_assimilation => [\"Leaf\", \"Internode\"]. This form is useful when we need values for a variable from several scales simultaneously. In this case, the values are available as a vector in the carbon_assimilation variable of the status inside the model, sorted in the same order as nodes are traversed in the graph.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"A last form is to map to a specific variable name at the target scale, e.g. :Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]. This form is useful when the variable name is different between scales, and we want to map to a specific variable name at the target scale. In this example, the variable Rm_organs at plant scale takes its values (is mapped) from the variable Rm at the \"Leaf\" and \"Internode\" scales.","category":"page"},{"location":"model_coupling/multiscale/#Running-a-simulation","page":"Multi-scale modelling","title":"Running a simulation","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Now that we have a valid mapping, we can run a simulation. Running a multiscale simulation requires two more things compared to what we saw previously: a plant graph and the definition of the output variables we want dynamically for each scale.","category":"page"},{"location":"model_coupling/multiscale/#Plant-graph","page":"Multi-scale modelling","title":"Plant graph","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We can import an example multi-scale tree graph like so:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"mtg = import_mtg_example()","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nYou can use import_mtg_example only if you previously imported the Examples sub-module of PlantSimEngine, i.e. using PlantSimEngine.Examples.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"This graph has a root node that defines a scene, then a soil, and a plant with two internodes and two leaves.","category":"page"},{"location":"model_coupling/multiscale/#Output-variables","page":"Multi-scale modelling","title":"Output variables","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Models can access only one time step at a time, so the output at the end of a simulation is only the last time step. However, we can define a list of variables we want to get dynamically for each time step and each scale. This list is given as a dictionary with the name of the scale as the key and a vector of variables as the value. For example, we can define a list of variables we want to get at each time step for different scales as follows:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"outs = Dict(\n    \"Scene\" => (:TT, :TT_cu, :node),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"These variables will be available in the outputs field of the simulation object, with a value for each time step. ","category":"page"},{"location":"model_coupling/multiscale/#Meteorological-data","page":"Multi-scale modelling","title":"Meteorological data","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"As for mono-scale models, we need to provide meteorological data to run a simulation. We can use the PlantMeteo package to generate some dummy data for two time steps:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f = 200.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f = 180.0)\n]\n)","category":"page"},{"location":"model_coupling/multiscale/#Simulation","page":"Multi-scale modelling","title":"Simulation","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Let's make a simulation using the graph and outputs we just defined:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"sim = run!(mtg, mapping, meteo, outputs = outs);\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"And that's it! ","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We can now access the outputs for each scale as a dictionary of vectors of values per variable and scale like this:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"outputs(sim);\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Or as a DataFrame using the DataFrames package:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"using DataFrames\noutputs(sim, DataFrame)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The values for the last time-step of the simulation are also available from the statuses:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"status(sim);\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"This is a dictionary with the scale as the key and a vector of Status as values, one per node of that scale. So, in this example, the \"Leaf\" scale has two nodes, so the value is a vector of two Status objects, and the \"Soil\" scale has only one node, so the value is a vector of one Status object.","category":"page"},{"location":"model_coupling/multiscale/#Avoiding-cyclic-dependencies","page":"Multi-scale modelling","title":"Avoiding cyclic dependencies","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"When defining a mapping between models and scales, it is important to avoid cyclic dependencies. A cyclic dependency occurs when a model at a given scale depends on a model at another scale that depends on the first model. Cyclic dependencies are bad because they lead to an infinite loop in the simulation (the dependency graph keeps cycling indefinitely).","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"PlantSimEngine will detect cyclic dependencies and raise an error if one is found. The error message indicates the models involved in the cycle, and the model that is causing the cycle will be highlighted in red.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"For example the following mapping will raise an error:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"details: Details\n<summary>Example mapping</summary>mapping_cyclic = Dict(\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n        Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6),\n    ),\n    \"Internode\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(TT=10.0, carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        ToyCBiomassModel(1.2),\n        Status(TT=10.0),\n    )\n)","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Let's see what happens when we try to build the dependency graph for this mapping:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"julia> dep(mapping_cyclic)\nERROR: Cyclic dependency detected in the graph. Cycle:\n Plant: ToyPlantRmModel\n └ Leaf: ToyMaintenanceRespirationModel\n  └ Leaf: ToyCBiomassModel\n   └ Plant: ToyCAllocationModel\n    └ Plant: ToyPlantRmModel\n\n You can break the cycle using the `PreviousTimeStep` variable in the mapping.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"How can we interpret the message? We have a list of five models involved in the cycle. The first model is the one causing the cycle, and the others are the ones that depend on it. In this case, the ToyPlantRmModel is the one causing the cycle, and the others are inter-dependent. We can read this as follows:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"ToyPlantRmModel depends on ToyMaintenanceRespirationModel, the plant-scale respiration sums up all organs respiration;\nToyMaintenanceRespirationModel depends on ToyCBiomassModel, the organs respiration depends on the organs biomass;\nToyCBiomassModel depends on ToyCAllocationModel, the organs biomass depends on the organs carbon allocation;\nAnd finally ToyCAllocationModel depends on ToyPlantRmModel again, hence the cycle because the carbon allocation depends on the plant scale respiration.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The models can not be ordered in a way that satisfies all dependencies, so the cycle can not be broken. To solve this issue, we need to re-think how models are mapped together, and break the cycle.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"There are several ways to break a cyclic dependency:","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"Merge models: If two models depend on each other because they need e.g. recursive computations, they can be merged into a third model that handles the computation and takes the two models as hard dependencies. Hard dependencies are models that are explicitly called by another model and do not participate on the building of the dependency graph.\nChange models: Of course models can be interchanged to avoid cyclic dependencies, but this is not really a solution, it is more a workaround.\nPreviousTimeScale: We can break the dependency graph by defining some variables as taken from the previous time step. A very well known example is the computation of the light interception by a plant that depends on the leaf area, which is usually the result of a model that also depends on the light interception. The cyclic dependency is usually broken by using the leaf area from the previous time step in the interception model, which is a good approximation for most cases.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"We can fix our previous mapping by computing the organs respiration using the carbon biomass from the previous time step instead. Let's see how to fix the cyclic dependency in our mapping (look at the leaf and internode scales):","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"details: Details\nmapping_nocyclic = Dict(\n        \"Plant\" => (\n            MultiScaleModel(\n                model=ToyCAllocationModel(),\n                mapping=[\n                    :carbon_demand => [\"Leaf\", \"Internode\"],\n                    :carbon_allocation => [\"Leaf\", \"Internode\"]\n                ],\n            ),\n            MultiScaleModel(\n                model=ToyPlantRmModel(),\n                mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n            ),\n            Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6, carbon_assimilation=5.0),\n        ),\n        \"Internode\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n                mapping=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (first break)\n            ),\n            Status(TT=10.0, carbon_biomass=1.0),\n        ),\n        \"Leaf\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n                mapping=[PreviousTimeStep(:carbon_biomass),], #! this is where we break the cyclic dependency (second break)\n            ),\n            ToyCBiomassModel(1.2),\n            Status(TT=10.0),\n        )\n    );\nnothing # hide","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"The ToyMaintenanceRespirationModel models are now defined as MultiScaleModel, and the carbon_biomass variable is wrapped in a PreviousTimeStep structure. This structure tells PlantSimEngine to take the value of the variable from the previous time step, breaking the cyclic dependency.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"note: Note\nPreviousTimeStep tells PlantSimEngine to take the value of the previous time step for the variable it wraps, or the value at initialization for the first time step. The value at initialization is the one provided by default in the models inputs, but is usually provided in the Status structure to override this default. A PreviousTimeStep is used to wrap the input variable of a model, with or without a mapping to another scale e.g. Previous(:carbon_biomass) => \"Leaf\".","category":"page"},{"location":"model_coupling/multiscale/#Wrapping-up","page":"Multi-scale modelling","title":"Wrapping up","text":"","category":"section"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"In this section, we saw how to define a mapping between models and scales, run a simulation, and access the outputs.","category":"page"},{"location":"model_coupling/multiscale/","page":"Multi-scale modelling","title":"Multi-scale modelling","text":"This is just a simple example, but PlantSimEngine can be used to define and combine much more complex models at multiple scales of detail. With its modular architecture and intuitive API, PlantSimEngine is a powerful tool for multi-scale plant growth and development modeling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nrun!(model)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\nrun!(model2, meteo_day)\n","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: Aqua QA) (Image: DOI) (Image: JOSS)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine is a comprehensive package for simulating and modelling plants, soil and atmosphere. It provides tools to prototype, evaluate, test, and deploy plant/crop models at any scale. At its core, PlantSimEngine is designed with a strong emphasis on performance and efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines a framework for declaring processes and implementing associated models for their simulation. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It focuses on key aspects of simulation and modeling such as: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easy definition of new processes, such as light interception, photosynthesis, growth, soil water transfer...\nFast, interactive prototyping of models, with constraints to help users avoid errors, but sensible defaults to avoid over-complicating the model writing process\nNo hassle, the package manages automatically input and output variables, time-steps, objects, soft and hard coupling of models with a dependency graph\nSwitch between models without changing any code, with a simple syntax to define the model to use for a given process\nReduce the degrees of freedom by fixing variables, passing measurements, or using a simpler model for a given process\n🚀(very) fast computation 🚀, think of 100th of nanoseconds for one model, two coupled models (see this benchmark script), or the full energy balance of a leaf using PlantBiophysics.jl that uses PlantSimEngine\nOut of the box Sequential, Parallel (Multi-threaded) or Distributed (Multi-Process) computations over objects, time-steps and independent processes (thanks to Floops.jl)\nEasily scalable, with methods for computing over objects, time-steps and even Multi-Scale Tree Graphs\nComposable, allowing the use of any types as inputs such as Unitful to propagate units, or MonteCarloMeasurements.jl to propagate measurement error","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easy to use, and to help users avoid errors when implementing, coupling and simulating models.","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example of a model that simulates the growth of a plant, using a simple exponential growth model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine\nusing PlantSimEngine\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Define the model:\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # Pass the cumulated degree-days as input to the model\n)\n\nrun!(model) # run the model\n\nstatus(model) # extract the status, i.e. the output of the model","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note   The ToyLAIModel is available from the examples folder, and is a simple exponential growth model. It is used here for the sake of simplicity, but you can use any model you want, as long as it follows PlantSimEngine interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course you can plot the outputs quite easily:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add CairoMakie\nusing CairoMakie\n\nlines(model[:TT_cu], model[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Cumulated growing degree days since sowing (°C)\"))","category":"page"},{"location":"#Model-coupling","page":"Home","title":"Model coupling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Model coupling is done automatically by the package, and is based on the dependency graph between the models. To couple models, we just have to add them to the ModelList. For example, let's couple the ToyLAIModel with a model for light interception based on Beer's law:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# Import the examples defined in the `Examples` sub-module\nusing PlantSimEngine.Examples\n\n# Import the example meteorological data:\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# Define the list of models for coupling:\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # Pass the cumulated degree-days as input to `ToyLAIModel`, this could also be done using another model\n)\n\n# Run the simulation:\nrun!(model2, meteo_day)\n\nstatus(model2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ModelList couples the models by automatically computing the dependency graph of the models. The resulting dependency graph is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"╭──── Dependency graph ──────────────────────────────────────────╮\n│  ╭──── LAI_Dynamic ─────────────────────────────────────────╮  │\n│  │  ╭──── Main model ────────╮                              │  │\n│  │  │  Process: LAI_Dynamic  │                              │  │\n│  │  │  Model: ToyLAIModel    │                              │  │\n│  │  │  Dep: nothing          │                              │  │\n│  │  ╰────────────────────────╯                              │  │\n│  │                  │  ╭──── Soft-coupled model ─────────╮  │  │\n│  │                  │  │  Process: light_interception    │  │  │\n│  │                  └──│  Model: Beer                    │  │  │\n│  │                     │  Dep: (LAI_Dynamic = (:LAI,),)  │  │  │\n│  │                     ╰─────────────────────────────────╯  │  │\n│  ╰──────────────────────────────────────────────────────────╯  │\n╰────────────────────────────────────────────────────────────────╯","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can plot the results by indexing the model with the variable name (e.g. model2[:LAI]):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, model2[:TT_cu], model2[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, model2[:TT_cu], model2[:aPPFD], color=:firebrick1)\n\nfig","category":"page"},{"location":"#Multiscale-modelling","page":"Home","title":"Multiscale modelling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Multi-scale modeling section for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be easily scalable, and can be used to simulate models at different scales. For example, you can simulate a model at the leaf scale, and then couple it with models at any other scale, e.g. internode, plant, soil, scene scales. Here's an example of a simple model that simulates plant growth using sub-models operating at different scales:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapping=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapping=[:soil_water_content => \"Soil\"],\n        ),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapping=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapping=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        MultiScaleModel(\n            model=ToyInternodeEmergence(TT_emergence=20.0),\n            mapping=[:TT_cu => \"Scene\"],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapping=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can import an example plant from the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mtg = import_mtg_example()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make a fake meteorological data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"meteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=300.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f=500.0)\n]\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"And run the simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"out_vars = Dict(\n    \"Scene\" => (:TT_cu,),\n    \"Plant\" => (:carbon_allocation, :carbon_assimilation, :soil_water_content, :aPPFD, :TT_cu, :LAI),\n    \"Leaf\" => (:carbon_demand, :carbon_allocation),\n    \"Internode\" => (:carbon_demand, :carbon_allocation),\n    \"Soil\" => (:soil_water_content,),\n)\n\nout = run!(mtg, mapping, meteo, outputs=out_vars, executor=SequentialEx());\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then extract the outputs in a DataFrame and sort them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames\ndf_out = outputs(out, DataFrame)\nsort!(df_out, [:timestep, :node])","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example output of a multiscale simulation is shown in the documentation of PlantBiophysics.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Plant growth simulation)","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! 😃","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Simple case","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"using PlantSimEngine, PlantMeteo\n# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls again run! inside its implementation at some point. Note that it does not force any kind of conductance model over another, just that there is one to simulate the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"We provide an example script that implements seven dummy processes in examples/dummy. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model... ","category":"page"},{"location":"model_coupling/model_coupling_user/#Hard-coupled-models","page":"Simple case","title":"Hard coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"The Process3Model calls Process2Model, and Process2Model calls Process1Model. This explicit call is called a hard-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"The other models for the other processes are called Process4Model, Process5Model... and they do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"tip: Tip\nHard-coupling of models is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is hard-coupled to a photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Back to our example, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Let's use the Examples sub-module so we can play around:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"# Import the example models defined in the `Examples` sub-module:\nusing PlantSimEngine.Examples","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"tip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Here is how we can make the model coupling:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"m = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"We can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Note that the user only declares the models, not the way the models are coupled because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Now the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their hard or soft-coupling.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"For example, Process1Model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"inputs(Process1Model(2.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"And Process2Model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"inputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"We see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"outputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"So considering those two models, we only need var1 and var2 to be initialized, as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"page"},{"location":"model_coupling/model_coupling_user/#Soft-coupled-models","page":"Simple case","title":"Soft coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"All following models (Process4Model to Process7Model) do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Let's make a new model list including the soft-coupled models:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"With this list of models, we only need to initialize var0, that is an input of Process4Model and Process7Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"to_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"We can initialize it like so:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"model_coupling/model_coupling_user/#Simulation-order","page":"Simple case","title":"Simulation order","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"When calling run!, the models are run in the right order using a dependency graph that is computed automatically based on the hard and soft dependencies of the models following a simple set of rules:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Simple case","title":"Simple case","text":"Independent models are run first. A model is independent if it can be run alone, or only using initializations. It is not dependent on any other model.\nFrom their children dependencies:\nHard dependencies are always run before soft dependencies. Inner hard dependency graphs are considered as a whole, i.e. as a single soft dependency.\nSoft dependencies are then run sequentially. If a soft dependency has several parent nodes (i.e. its inputs are computed by several models), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"}]
}
