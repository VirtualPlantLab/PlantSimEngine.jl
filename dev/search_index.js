var documenterSearchIndex = {"docs":
[{"location":"extending/inputs/#Input-types","page":"Input types","title":"Input types","text":"","category":"section"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"run! usually takes two inputs: a ModelList and data for the meteorology. The data for the meteorology is usually provided for one time step using an Atmosphere, or for several time-steps using a TimeStepTable{Atmosphere}. The ModelList can also be provided as a singleton, or as a vector or dictionary of.","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"run! knows how to handle these data formats via the PlantSimEngine.DataFormat trait (see this blog post. For example, we tell PlantSimEngine that a TimeStepTable should be handled like a table by implementing the following trait:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"If you need to use a different data format for the meteorology, you can implement a new trait for it. For example, if you have a table-alike data format, you can implement the trait like this:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"DataFormat(::Type{<:MyTableFormat}) = TableAlike()","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"There are two other traits available: SingletonAlike for a data format representing one time-step only, and TreeAlike for trees, which is used for MultiScaleTreeGraphs nodes (not generic at this time).","category":"page"},{"location":"extending/inputs/#Special-considerations-for-new-input-types","page":"Input types","title":"Special considerations for new input types","text":"","category":"section"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"If you want to use a custom data format for the inputs, you need to make sure some methods are implemented for your data format depending on the your cases. ","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"For example if you use models that need to get data from a different time step (e.g. a model that needs to get the previous day's temperature), you need to make sure that the data from the other time-steps can be accessed from the current time-step.","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"To do so, you need to implement the following methods for your structure that defines your rows:","category":"page"},{"location":"extending/inputs/","page":"Input types","title":"Input types","text":"Base.parent: return the parent table of the row, e.g. the full DataFrame\nPlantMeteo.rownumber: return the row number of the row in the parent table, e.g. the row number in the DataFrame\n(Optionnally) PlantMeteo.row_from_parent(row, i): return row i from the parent table, e.g. the row i from the DataFrame. This is only needed if you want high performance, the default implementation calls Tables.rows(parent(row))[i].","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-process","page":"Processes","title":"Implement a new process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine\nusing PlantMeteo\nPlantSimEngine.@process growth","category":"page"},{"location":"extending/implement_a_process/#Introduction","page":"Processes","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. Let's learn about how to implement a new process with a simple example: implementing a growth model.","category":"page"},{"location":"extending/implement_a_process/#Implement-a-process","page":"Processes","title":"Implement a process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To implement a new process, we need to define an abstract structure that will help us associate the models to this process. We also need to generate some boilerplate code, such as a method for the process function. Fortunately, PlantSimEngine provides a macro to generate all that at once: @process. This macro takes only one argument: the name of the process.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"For example, the photosynthesis process in PlantBiophysics.jl is declared using just this tiny line of code:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@process photosynthesis","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"If we want to simulate the growth of a plant, we could add a new process called growth:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@process \"growth\"","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"And that's it! Note that the function guides you in the steps you can make after creating a process. Let's break it up here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So what you just did is to create a new process called growth. By doing so, you created a new abstract structure called AbstractGrowthModel. It is used as a supertype for the types used for model implementation. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"note: Note\nIf you don't understand what a supertype is, no worries, you'll understand by seeing the examples below","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-model-for-the-process","page":"Processes","title":"Implement a new model for the process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To better understand how models are implemented, you can read the detailed instructions from the previous section. But for the sake of completeness, we'll implement a growth model here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This growth model needs the carbohydrate assimilation that we could compute using e.g. the coupled energy balance process from PlantBiophysics.jl. Then the model removes the maintenance respiration and the growth respiration from that source of carbon, and increments the leaf biomass by the remaining carbon offer.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Let's implement this model below:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine, PlantMeteo # PlantMeteo is used for the meteorology\n\n# Make the struct to hold the parameters, with its documentation:\n\"\"\"\n    DummyGrowth(Rm_factor, Rg_cost)\n    DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the leaf biomass growth of a plant.\n\n# Arguments\n\n- `Rm_factor`: the fraction of assimilation that goes into maintenance respiration\n- `Rg_cost`: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\"\"\"\nstruct DummyGrowth{T} <: AbstractGrowthModel\n    Rm_factor::T\n    Rg_cost::T\nend\n\n# Note that DummyGrowth is a subtype of AbstractGrowthModel, this is important\n\n# Instantiate the struct with default values + kwargs:\nfunction DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n    DummyGrowth(promote(Rm_factor,Rg_cost)...)\nend\n\n# Define inputs:\nfunction PlantSimEngine.inputs_(::DummyGrowth)\n    (A=-Inf,)\nend\n\n# Define outputs:\nfunction PlantSimEngine.outputs_(::DummyGrowth)\n    (Rm=-Inf, Rg=-Inf, leaf_allocation=-Inf, leaf_biomass=0.0)\nend\n\n# Tells Julia what is the type of elements:\nBase.eltype(x::DummyGrowth{T}) where {T} = T\n\n# Implement the growth model:\nfunction PlantSimEngine.run!(::DummyGrowth, models, status, meteo, constants, extra)\n\n    # The maintenance respiration is simply a factor of the assimilation:\n    status.Rm = status.A * models.growth.Rm_factor\n    # Note that we use models.growth.Rm_factor to access the parameter of the model\n\n    # Let's say that all carbon is allocated to the leaves:\n    status.leaf_allocation = status.A - status.Rm\n\n    # And that this carbon is allocated with a cost (growth respiration Rg):\n    status.Rg = 1 - (status.leaf_allocation / models.growth.Rg_cost)\n\n    status.leaf_biomass = status.leaf_biomass + status.leaf_allocation - status.Rg\nend","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now we can make a simulation as usual:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(DummyGrowth(), status = (A = 20.0,))\n\nrun!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"We can also start the simulation later when the plant already has some biomass by initializing the leaf_biomass:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(DummyGrowth(), status = (A = 20.0, leaf_biomass = 2400.0))\n\nrun!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_model/#model_implementation_page","page":"Models","title":"Model implementation in 5 minutes","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"using PlantSimEngine\n@process \"light_interception\" verbose = false\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/#Introduction","page":"Models","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new light interception model.","category":"page"},{"location":"extending/implement_a_model/#Inspiration","page":"Models","title":"Inspiration","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you want to implement a new model, the best way to do it is to start from another implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For a complete example, you can look at the code in PlantBiophysics.jl, were you will find e.g. a photosynthesis model, with the implementation of the FvCB model in this Julia file: src/photosynthesis/FvCB.jl; an energy balance model with the implementation of the Monteith model in src/energy/Monteith.jl; or a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"extending/implement_a_model/#Requirements","page":"Models","title":"Requirements","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In those files, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you create your own process, the function will print a short tutorial on how to do all that, adapted to the process you just created (see Implement a new process).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In this page, we'll just implement a model for a process that already exists: the light interception. This process is defined in PlantBiophysics.jl, but also in an example script in PlantSimEngine.jl here: examples/light.jl.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We can include this file like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"include(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But instead of just using it, we will review the script line by line.","category":"page"},{"location":"extending/implement_a_model/#Example:-the-Beer-Lambert-model","page":"Models","title":"Example: the Beer-Lambert model","text":"","category":"section"},{"location":"extending/implement_a_model/#The-process","page":"Models","title":"The process","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We declare the light interception process at l.7 using @process: ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"@process \"light_interception\" verbose = false","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"See Implement a new process for more details on how that works and how to use the process.","category":"page"},{"location":"extending/implement_a_model/#The-structure","page":"Models","title":"The structure","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To implement a model, the first thing to do is to define a structure. The purpose of this structure is two-fold:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"hold the parameter values\ndispatch to the right run! method when calling it","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The structure of the model (or type) is defined as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first line defines the name of the model (Beer), which is completely free, except it is good practice to use camel case for the name, i.e. using capital letters for the words and no separator LikeThis. ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We also can see that we define the Beer structure as a subtype of AbstractLight_InterceptionModel. This step is very important as it tells to the package what kind of process the model simulates. AbstractLight_InterceptionModel is automatically created when defining the process \"light_interception\".","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In our case, it tells us that Beer is a model to simulate the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Then comes the parameters names, and their types. The type of parameters is given by the user at instantiation in our example. This is done using the T notation as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"we say that our structure Beer is a parameterized struct by putting T in between brackets after the name of the struct\nWe put ::T after our parameter name in the struct. This way Julia knows that our parameter will be of type T.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The T is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But why not forcing the type such as the following:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Well, you can do that. But you'll lose a lot of the magic Julia has to offer this way.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For example a user could use the Particles type from MonteCarloMeasurements.jl to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.","category":"page"},{"location":"extending/implement_a_model/#The-method","page":"Models","title":"The method","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The models are implemented by adding a method for its type to the run! function. The exclamation point at the end of the function name is used in Julia to tell users that the function is mutating, i.e. it modifies its input.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The function takes six arguments:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"the type of your model\nmodels: a ModelList object, which contains all the models of the simulation\nstatus: a Status object, which contains the current values (i.e. state) of the variables for one time-step (e.g. the value of the plant LAI at time t)\nmeteo: (usually) an Atmosphere object, or a row of the meteorological data, which contains the current values of the meteorological variables for one time-step (e.g. the value of the PAR at time t)\nconstants: a Constants object, or a NamedTuple, which contains the values of the constants for the simulation (e.g. the value of the Stefan-Boltzmann constant)\nextras: any other object you want to pass to your model. This is for advanced users, and is not used in this example. Note that it is used to pass the Node when simulating a MultiScaleTreeGraph.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Your implementation can use any variables or parameters in these objects. The only thing you have to do is to make sure that the variables you use are defined in the Status object, the meteorology, and the Constants object.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The variables you use from the Status must be declared as inputs of your model. And the ones you modify must be declared as outputs. We'll that below.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nModels implementations are done for one time-step by design. If you want to implement a model that uses the previous time-step, you'll have to do it yourself. This is because the Status object only contains the current values of the variables, and not the previous ones. This is by design, because it enforces a clear definition of the models, and avoids the user to make mistakes. If you really need to use the previous time-step, you can add a variable to the Status object that contains the previous value(s) of the variable you want to use (e.g. LAI_prev). Note that it is not recommended though. If you're not convinced by this approach, ask yourself how the plant knows the value of e.g. LAI from 15 days ago. It doesn't. It only knows its current state. Most of the time-sensitive variables really are just an accumulation of values until a threshold anyway.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine then automatically deals with every other detail, such as checking that the object is correctly initialized, applying the computations over objects and time-steps. This is nice because as a developer you don't have to deal with those details, and you can just concentrate on your model implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nYou need to import all the functions you want to extend, so Julia knows your intention of adding a method to the function from PlantSimEngine, and not defining your own function. To do so, you have to prefix the said functions by the package name, or import them before e.g.: import PlantSimEngine: inputs_, outputs_","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So let's do it! Here is our own implementation of the light interception for a ModelList component models:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first argument (::Beer) means this method will only execute when the function is called with a first argument that is of type Beer. This is our way of telling Julia that this method implements the Beer model for the light interception process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"An important thing to note is that the model parameters are available from the ModelList that is passed via the models argument. Then parameters are found in field called by the process name, and the parameter name. For example, the k parameter of the Beer model is found in models.light_interception.k.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"One last thing to do is to define the inputs and outputs of our model. This is done by adding a method for the inputs and outputs functions. These functions take the type of the model as argument, and return a NamedTuple with the names of the variables as keys, and their default values as values.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In our case, the Beer model has one input and one output:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Inputs: :LAI, the leaf area index (mÂ² mâ»Â²)\nOutputs: :PPFD, the photosynthetic photon flux density (Î¼mol mâ»Â² sâ»Â¹)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here is how we communicate that to PlantSimEngine:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (PPFD=-Inf,)\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Note that both functions end with an \"_\". This is because these functions are internal, they will not be called by the users directly. Users will use inputs and outputs instead, which call inputs_ and outputs_, but stripping out the default values.","category":"page"},{"location":"extending/implement_a_model/#Dependencies","page":"Models","title":"Dependencies","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If your model explicitly calls another model, you need to tell PlantSimEngine about it. This is called a hard dependency, in opposition to a soft dependency, which is when your model uses a variable from another model, but does not call it explicitly.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To do so, we can add a method to the dep function that tells PlantSimEngine which processes (and models) are needed for the model to run.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb in PlantBiophysics.jl to see how it works:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You can read more about dependencies in Model coupling for modelers and Model coupling for users.","category":"page"},{"location":"extending/implement_a_model/#The-utility-functions","page":"Models","title":"The utility functions","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Before running a simulation, you can do a little bit more for your implementation (optional).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"First, you can add a method for type promotion. It wouldn't make any sense for our example because we have only one parameter. But we can make another example with a new model that would be called Beer2 that would take two parameters:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"To add type promotion to Beer2 we would do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function Beer2(k,x)\n    Beer2(promote(k,x))\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This would allow users to instantiate the model parameters using different types of inputs. For example they may use this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer2(0.6,2)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You don't see a problem? Well your users won't either. But there's one: Beer2 is a parametric type, so all fields share the same type T. This is the T in Beer2{T} and then in k::T and x::T. And this force the user to give all parameters with the same type.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"And in our example above, the user provides 0.6 for k, which is a Float64, and 2 for x, which is an Int. ANd if you don't have type promotion, Julia will return an error because both should be either Float64 or Int. That's were the promotion comes in handy, it will convert all your inputs to a common type (when possible). In our example it will convert 2 to 2.0.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of k. So we can provide a default value like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer() = Beer(0.6)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now the user can call Beer with zero value, and k will default to 0.6.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Another useful thing is the ability to instantiate your model type with keyword arguments, i.e. naming the arguments. You can do it by adding the following method:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(;k) = Beer(k)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Did you notice the ; before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call Beer like this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Beer(k = 0.7)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This is nice when we have a lot of parameters and some with default values, but again, this is completely optional.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The last optional thing to implement is a method for the eltype function:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Base.eltype(x::Beer{T}) where {T} = T","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This one helps Julia know the type of the elements in the structure, and make it faster.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK that's it! Now we have a full new model implementation for the light interception process! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue.","category":"page"},{"location":"model_switching/#Model-switching","page":"Model Switching","title":"Model switching","text":"","category":"section"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=1.0,)\n)\nrun!(m, meteo)\nstruct AnotherProcess1Model <: AbstractProcess1Model\n    a\n    b # this is a new parameter\nend\nPlantSimEngine.inputs_(::AnotherProcess1Model) = (var1=-Inf, var2=-Inf, var10=-Inf,)\nPlantSimEngine.outputs_(::AnotherProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::AnotherProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    status.var3 = models.process1.a + status.var1 * status.var2 + status.var10\nend\nm2 = ModelList(\n    AnotherProcess1Model(2.0, 0.5), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=1.0, var10=2.0)\n)\nrun!(m2, meteo)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"One of the main objective of PlantSimEngine is allowing users to switch between model implementations for a given process without making any change to the code. ","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"The package was carefully designed around this idea to make it easy and computationally efficient. This is done by using the ModelList, which is used to list models, and the run! function to run the simulation following the dependency graph and leveraging Julia's multiple dispatch to run the models.","category":"page"},{"location":"model_switching/#ModelList","page":"Model Switching","title":"ModelList","text":"","category":"section"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"The ModelList is a container that holds a list of models, their parameter values, and the status of the variables associated to them.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Model coupling is done by adding models to the ModelList. Let's create a ModelList with the seven models from the example script examples/dummy.jl:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"using PlantSimEngine\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Include the dummy models:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=1.0,)\n)\n\nnothing # hide","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"PlantSimEngine uses the ModelList to compute the dependency graph of the models. Here we have seven models, one for each process. The dependency graph is computed automatically by PlantSimEngine, and is used to run the simulation in the correct order.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"We can run the simulation by calling the run! function with a meteorology:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"meteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\n\nrun!(m, meteo)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And then we can access the status of the variables:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"status(m)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Now what if we want to switch the model for process 1? We can do this by simply replacing the model in the ModelList, and PlantSimEngine will automatically update the dependency graph, and adapt the simulation to the new model.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"First, let's create a new model for process 1. This model is a copy of the old model, but with one more input (var10) and one more parameter (b):","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"struct AnotherProcess1Model <: AbstractProcess1Model\n    a\n    b # this is a new parameter\nend\nPlantSimEngine.inputs_(::AnotherProcess1Model) = (var1=-Inf, var2=-Inf, var10=-Inf)\nPlantSimEngine.outputs_(::AnotherProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::AnotherProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    status.var3 = models.process1.a + status.var1 * status.var2 + models.process1.b * status.var10\nend","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"Now we can switch the model used for process 1 by simply replacing the old model (Process1Model) by the new one AnotherProcess1Model in the ModelList:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"m2 = ModelList(\n    AnotherProcess1Model(2.0, 0.5), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=1.0, var10=2.0)\n)\n\nnothing # hide","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And run the simulation with the new model:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"run!(m2, meteo)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And we can see that the status of the variables is different from the previous simulation:","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"status(m2)","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"note: Note\nIn our example we replaced a hard-dependency model, but the same principle applies to soft-dependency models.","category":"page"},{"location":"model_switching/","page":"Model Switching","title":"Model Switching","text":"And that's it! We can switch between models without changing the code, and without having to recompute the dependency graph manually. This is a very powerful feature of PlantSimEngine!ðŸ’ª","category":"page"},{"location":"model_execution/#Model-execution","page":"Execution","title":"Model execution","text":"","category":"section"},{"location":"model_execution/#Simulation-order","page":"Execution","title":"Simulation order","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the ModelList to automatically compute a dependency graph between the models and run the simulation in the correct order. When running a simulation with run!, the models are then executed following this simple set of rules:","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Independent models are run first. A model is independent if it can be run independently from other models, only using initializations (or nothing). \nThen, models that have a dependency on other models are run. The first ones are the ones that depend on an independent model. Then the ones that are children of the second ones, and then their children ... until no children are found anymore. There are two types of children models (i.e. dependencies): hard and soft dependencies:\nHard dependencies are always run before soft dependencies. A hard dependency is a model that list dependencies in their own method for dep. See this example that shows Process2Model defining a hard dependency on any model that simulate process1. Inner hard dependency graphs (i.e. consecutive hard-dependency children) are considered as a single soft dependency.\nSoft dependencies are then run sequentially. A model has a soft dependency on another model if one or more of its inputs is computed by another model. If a soft dependency has several parent nodes (e.g. two different models compute two inputs of the model), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"},{"location":"model_execution/#Parallel-execution","page":"Execution","title":"Parallel execution","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"PlantSimEngine.jl uses the Floops package to run the simulation in sequential, parallel (multi-threaded) or distributed (multi-process) computations over objects, time-steps and independent processes. ","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"That means that you can provide any compatible executor to the executor argument of run!. By default, run! uses the ThreadedEx executor, which is a multi-threaded executor. You can also use the SequentialExfor sequential execution (non-parallel), or DistributedEx for distributed computations.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"You can also take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.","category":"page"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"Finally, you can take a look into Transducers.jl's documentation for more information, for example if you don't know what is an executor, you can look into this explanation.","category":"page"},{"location":"model_execution/#Tutorial","page":"Execution","title":"Tutorial","text":"","category":"section"},{"location":"model_execution/","page":"Execution","title":"Execution","text":"You can learn how to run a simulation from the documentation of PlantBiophysics.jl.","category":"page"},{"location":"design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to ease the process of modelling and simulation of plants, soil and atmosphere, or really any system (e.g. agroforestry system, agrivoltaics...). PlantSimEngine.jl aims at being the backbone tool for developing Functional-Structural Plant Models (FSPM) and crop models without the hassle of performance and other computer-science considerations.  ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nrun!(leaf, meteo)","category":"page"},{"location":"design/#Definitions","page":"Design","title":"Definitions","text":"","category":"section"},{"location":"design/#Processes","page":"Design","title":"Processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A process is \"declared\", meaning we just define a process using @process, and then we implement models for its simulation. Declaring a process generates some boilerplate code for its simulation: ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"an abstract type for the process\na method for the process function, that is used internally","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example, the light_interception process is declared using:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@process light_interception","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Which would generate a tutorial to help the user implement a model for the process.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The abstract process type is then used as a supertype of all models implementations for the process, and is named Abstract<process_name>Process, e.g. AbstractLight_InterceptionModel.","category":"page"},{"location":"design/#Models-(ModelList)","page":"Design","title":"Models (ModelList)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process is simulated using a particular implementation, or a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction. The process of light_interception and the Beer model are provided as an example  script in this package too at examples/light.jl.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Models can use three types of entries:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters are constant values that are used by the model to compute its outputs. Meteorological information are values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. Variables are either used or computed by the model and can optionally be initialized before the simulation. Constants are constant values, usually common between models, e.g. the universal gas constant. And extras are just extra values that can be used by a model, it is for example used to pass the current node of the Multi-Scale Tree Graph to be able to e.g. retrieve children or ancestors values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users can choose which model is used to simulate a process using the ModelList structure. ModelList is also used to store the values of the parameters, and to initialize variables.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example let's instantiate a ModelList with the Beer-Lambert model of light extinction. The model is implemented with the Beer structure and has only one parameter: the extinction coefficient (k).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Importing the package:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Including the script that defines light_interception and Beer:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"include(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"And then making a ModelList with the Beer model:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"ModelList(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"What happened here? We provided an instance of the Beer model to a ModelList to simulate the light interception process.","category":"page"},{"location":"design/#Parameters","page":"Design","title":"Parameters","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A parameter is a constant value that is used by a model to compute its outputs. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer-Lambert model is implemented with the Beer structure, which has only one field: k. We can see that using fieldnames on the model structure:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(Beer)","category":"page"},{"location":"design/#Variables-(inputs,-outputs)","page":"Design","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Variables are either input or outputs (i.e. computed) of models. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Hence, ModelList objects stores two fields:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(ModelList)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first field is a list of models associated to the processes they simulate. The second, :status, is used to hold all inputs and outputs of our models, called variables. For example the Beer model needs the leaf area index (LAI, mÂ² mâ»Â²) to run.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can see which variables are needed as inputs using inputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"inputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"and the outputs of the model using outputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"outputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"If we instantiate a ModelList with the Beer-Lambert model, we can see that the :status field has two variables: LAI and PPFD. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nkeys(status(m))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\nto_initialize(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"(m[:LAI], m[:PPFD])","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Uninitialized variables are initialized to the value given in the inputs or outputs methods, which is usually equal to typemin(), e.g. -Inf for Float64.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns the variables that are needed by the model to run, but to_initialize returns the variables that are needed by the model to run and that are not initialized in the ModelList. Also to_initialize is more clever when coupling models (see below).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can initialize the variables by providing their values to the status at instantiation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or after instantiation using init_status!:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"is_initialized(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Some variables are inputs of models, but outputs of other models. When we couple models, PlantSimEngine.jl is clever and only requests the variables that are not computed by other models.","category":"page"},{"location":"design/#Climate-forcing","page":"Design","title":"Climate forcing","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: TimeStepTable.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in Â°C), Rh (relative humidity, 0-1) and Wind (the wind speed, m sâ»Â¹). In our example, we also need the incoming photosynthetically active radiation flux (Ri_PAR_f, W mâ»Â²). We can declare such conditions like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"More details are available from the package documentation.","category":"page"},{"location":"design/#Simulation","page":"Design","title":"Simulation","text":"","category":"section"},{"location":"design/#Simulation-of-processes","page":"Design","title":"Simulation of processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Making a simulation is rather simple, we simply use run! on the ModelList:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The call to run! is the same whatever the models you choose for simulating the processes. This is some magic allowed by PlantSimEngine.jl! Here is an example:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"run!(model_list, meteo)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The ModelList should be initialized for the given process before calling the function. See Variables (inputs, outputs) for more details.","category":"page"},{"location":"design/#Example-simulation","page":"Design","title":"Example simulation","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"For example we can simulate the light_interception of a leaf like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantMeteo\n\n# Including the script defining light_interception and Beer:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\nrun!(leaf, meteo)\n\nleaf[:PPFD]","category":"page"},{"location":"design/#Outputs","page":"Design","title":"Outputs","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract the simulation outputs of a model list using the status function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The status is usually stored in a TimeStepTable structure from PlantMeteo.jl, which is a fast DataFrame-alike structure with each time step being a Status. It can be also be any Tables.jl structure, such as a regular DataFrame. The weather is also usually stored in a TimeStepTable but with each time step being an Atmosphere.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's look at the status of our previous simulated leaf:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can extract the value of one variable using the status function, e.g. for the intercepted light:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf, :PPFD)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or similarly using the dot syntax:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf.status.PPFD","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or much simpler (and recommended), by indexing directly into the model list:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf[:PPFD]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Another simple way to get the results is to transform the outputs into a DataFrame. Which is very easy because the TimeStepTable implements the Tables.jl interface:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using DataFrames\nDataFrame(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThe output from DataFrame is adapted to the kind of simulation you did: one row per time-step, and per component models if you simulated several.","category":"page"},{"location":"design/#Model-coupling","page":"Design","title":"Model coupling","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to make model coupling painless for modelers and users. Please see Model coupling for users and Model coupling for modelers for more details.","category":"page"},{"location":"fitting/#Parameter-fitting","page":"Fitting","title":"Parameter fitting","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\ndf = DataFrame(PPFD=m[:PPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"fitting/#The-fit-method","page":"Fitting","title":"The fit method","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Models are often calibrated using data, but the calibration process is not always the same depending on the model, and the data available to the user.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"PlantSimEngine defines a generic fit function that allows modelers provide a fitting algorithm for their model, and for users to use this method to calibrate the model using data.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The function does nothing in this package, it is only defined to provide a common interface for all the models. It is up to the modeler to implement the method for their model. ","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The method is implemented as a function with the following design pattern: the call to the function should take the model type as the first argument (T::Type{<:AbstractModel}), the data as the second argument (as a Table.jl compatible type, such as DataFrame), and any more information as keyword arguments, e.g. constants or parameters initializations with default values when necessary.","category":"page"},{"location":"fitting/#Example-with-Beer","page":"Fitting","title":"Example with Beer","text":"","category":"section"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The example script (see src/examples/light.jl) that implements the Beer model provides an example of how to implement the fit method for a model:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"The function takes a Beer type as the first argument, the data as a Tables.jl compatible type, such as a DataFrame as the second argument, and the J_to_umol constant as a keyword argument, which is used to convert between Î¼ mol mâ»Â² sâ»Â¹ and J mâ»Â² sâ»Â¹.","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"df should contain the columns PPFD (Î¼ mol mâ»Â² sâ»Â¹), LAI (mÂ² mâ»Â²) and Ri_PAR_f (W mâ»Â²). The function then computes k based on these values, and returns it as a NamedTuple of the form (parameter_name=parameter_value,).","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Here's an example of how to use the fit method:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Importing the script first: ","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"using PlantSimEngine, PlantMeteo, DataFrames, Statistics\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Defining the meteo data:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Computing the PPFD values from the Ri_PAR_f values using the Beer model (with k=0.6):","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"m = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Now we can define the \"data\" to fit the model using the simulated PPFD values:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"df = DataFrame(PPFD=m[:PPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"And finally we can fit the model using the fit method:","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"fit(Beer, df)","category":"page"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"note: Note\nThis is a dummy example to show that the fitting method works. A real application would fit the parameter values on the data directly.","category":"page"},{"location":"FAQ/translate_a_model/#I-want-to-use-PlantSimEngine-for-my-model","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using PlantSimEngine\nusing CairoMakie\nusing CSV, DataFrames\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/ToyLAIModel.jl\"))\n\nfunction lai_toymodel(degree_days_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - degree_days_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - degree_days_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n# Note: meteo_day is defined below if you want to reproduce it, then use this to write it:\n# PlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If you already have a model, you can easily use PlantSimEngine to couple it with other models with minor adjustments.","category":"page"},{"location":"FAQ/translate_a_model/#Toy-LAI-Model","page":"I want to use PlantSimEngine for my model","title":"Toy LAI Model","text":"","category":"section"},{"location":"FAQ/translate_a_model/#Model-description","page":"I want to use PlantSimEngine for my model","title":"Model description","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Let's take an example with a simple LAI model that we define below:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"\"\"\"\nSimulate leaf area index (LAI, mÂ² mâ»Â²) for a crop based on the amount of degree-days since sowing with a simple double-logistic function.\n\n# Arguments\n\n- `degree_days_cu`: degree-days since sowing\n- `max_lai=8`: Maximum value for LAI\n- `dd_incslope=500`: degree-days at which we get the maximal increase in LAI\n- `inc_slope=5`: slope of the increasing part of the LAI curve\n- `dd_decslope=1000`: degree-days at which we get the maximal decrease in LAI\n- `dec_slope=2`: slope of the decreasing part of the LAI curve\n\"\"\"\nfunction lai_toymodel(degree_days_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - degree_days_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - degree_days_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This model takes the number of days since sowing as input and returns the simulated LAI. We can plot the simulated LAI for a year:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"using CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (mÂ² mâ»Â²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"FAQ/translate_a_model/#Changes-for-PlantSimEngine","page":"I want to use PlantSimEngine for my model","title":"Changes for PlantSimEngine","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"The model can be implemented using PlantSimEngine as follows:","category":"page"},{"location":"FAQ/translate_a_model/#Define-a-process","page":"I want to use PlantSimEngine for my model","title":"Define a process","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"If the process of LAI dynamic is not implement yet, we can define it like so:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"@process LAI_Dynamic","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model","page":"I want to use PlantSimEngine for my model","title":"Define the model","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We have to define a structure for our model that will contain the parameters of the model:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"struct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"We can also define default values for the parameters by defining a method with keyword arguments:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"ToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"This way users can create a model with default parameters just by calling ToyLAIModel(), or they can specify only the parameters they want to change, e.g. ToyLAIModel(inc_slope=80.0)","category":"page"},{"location":"FAQ/translate_a_model/#Define-inputs-/-outputs","page":"I want to use PlantSimEngine for my model","title":"Define inputs / outputs","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define the inputs and outputs of the model, and the default value at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"PlantSimEngine.inputs_(::ToyLAIModel) = (degree_days_cu=-999,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we use -999 as a default value for the degree days, and -Inf for the LAI. These two are recommended values for Int and Float64 respectively, as they are valid values for these types, and are easy to catch in the outputs if not properly set because they propagate nicely. You can also use NaN for Float64.","category":"page"},{"location":"FAQ/translate_a_model/#Define-the-model-function","page":"I want to use PlantSimEngine for my model","title":"Define the model function","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Finally, we can define the model function that will be called at each time step:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"function PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.degree_days_cu) / model.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.degree_days_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nNote that we don't return the value of the LAI in the definition of the function. This is because we rather update its value in the status directly. The status is a structure that efficiently stores the state of the model at each time step, and it contains all variables either declared as inputs or outputs of the model. This way, we can access the value of the LAI at any time step by calling status.LAI.","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"note: Note\nThe function is defined for one time step only, and is called at each time step automatically by PlantSimEngine. This means that we don't have to loop over the time steps in the function.","category":"page"},{"location":"FAQ/translate_a_model/#Running-a-simulation","page":"I want to use PlantSimEngine for my model","title":"Running a simulation","text":"","category":"section"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Now that we have everything set up, we can run a simulation. The first step here is to define the weather:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"# Import the packages we need:\nusing PlantMeteo, Dates, DataFrames\n\n# Define the period of the simulation:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# Get the weather data for CIRAD's site in Montpellier, France:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# Compute the degree-days with a base temperature of 10Â°C:\nmeteo.degree_days = max.(meteo.T .- 10.0, 0.0)\n\n# Aggregate the weather data to daily values:\nmeteo_day = to_daily(meteo, :degree_days => (x -> sum(x) / 24) => :degree_days)","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"Then we can define our list of models, passing the values for degree_days_cu in the status at initialization:","category":"page"},{"location":"FAQ/translate_a_model/","page":"I want to use PlantSimEngine for my model","title":"I want to use PlantSimEngine for my model","text":"m = ModelList(\n    ToyLAIModel(),\n    status = (degree_days_cu = cumsum(meteo_day.degree_days),),\n)\n\nrun!(m)\n\nlines(m[:degree_days_cu], m[:LAI], color=:green, axis=(ylabel=\"LAI (mÂ² mâ»Â²)\", xlabel=\"Days since sowing\"))","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Model-coupling-for-modelers","page":"Modelers","title":"Model coupling for modelers","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"This section uses notions from the previous section. If you are not familiar with the concepts of model coupling in PlantSimEngine, please read the previous section first: Model coupling for users.","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Hard-coupling","page":"Modelers","title":"Hard coupling","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A model that calls explicitly another process is called a hard-coupled model. It is implemented by calling the process function directly.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Let's go through the example processes and models from a script provided by the package here examples/dummy.jl","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"In this script, we declare seven processes and seven models, one for each process. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model...","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Process2Model calls Process1Model explicitly, which defines Process1Model as a hard-dependency of Process2Model. The is as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"function PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # computing var3 using process1:\n    run!(models.process1, models, status, meteo, constants)\n    # computing var4 and var5:\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"We see that coupling a model (Process2Model) to another process (process1) is done by calling the run! function again. The run! function is called with the same arguments as the run! function of the model that calls it, except that we pass the process we want to simulate as the first argument.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"note: Note\nWe don't enforce any type of model to simulate process1. This is the reason why we can switch so easily between model implementations for any process, by just changing the model in the ModelList.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A hard-dependency must always be declared to PlantSimEngine. This is done by adding a method to the dep function. For example, the hard-dependency to process1 into Process2Model is declared as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"PlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"This way PlantSimEngine knows that Process2Model needs a model for the simulation of the process1 process. Note that we don't add any constraint to the type of model we have to use (we use AbstractProcess1Model), because we want any model implementation to work with the coupling, as we only are interested in the value of a variable, not the way it is computed.","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"Even if it is discouraged, you may have a valid reason to force the coupling with a particular model, or a kind of models though. For example, if we want to use only Process1Model for the simulation of process1, we would declare the dependency as follows:","category":"page"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"PlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Soft-coupling","page":"Modelers","title":"Soft coupling","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"A model that takes outputs of another model as inputs is called a soft-coupled model. There is nothing to do on the modeler side to declare a soft-dependency. The detection is done automatically by PlantSimEngine using the inputs and outputs of the models.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/#API-documentation","page":"API","title":"API documentation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"API/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tâ‚—=[25.0, 26.0],\n    PPFD=[1000.0, 1200.0],\n    Câ‚›=[400.0, 400.0],\n    Dâ‚—=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tâ‚—=25.0, PPFD=1000.0, Câ‚›=400.0, Dâ‚—=1.0),\n        Status(Tâ‚—=26.0, PPFD=1200.0, Câ‚›=400.0, Dâ‚—=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.AbstractModel","page":"API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.ModelList","page":"API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    init_fun::Function=init_fun_default,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\ninit_fun: a function that initializes the status based on a vector of NamedTuples (see details).\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nThe argument init_fun is set by default to init_fun_default which initializes the status with a TimeStepTable of Status structures.\n\nIf you change init_fun by another function, make sure the type you are using (i.e. in place of TimeStepTable)  implements the Tables.jl interface (e.g. DataFrame does). And if you still use TimeStepTable but only change Status, make sure the type you give is indexable using the dot synthax (e.g. x.var).\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding an example script that implements dummy processes and models:\n\njulia> include(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{NamedTuple{(:process1, :process2, :process3), Tuple{Process1Model, Process2Model, Process3Model}}, TimeStepTable{Status{(:var4, :var5, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> run!(models,meteo)\n\njulia> models[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\nWe can also use DataFrame as the status type:\n\njulia> using DataFrames;\n\njulia> df = DataFrame(:var1 => [13.747, 13.8], :var2 => [1.0, 1.0]);\n\njulia> m = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=df, init_fun=x -> DataFrame(x));\n\nNote that we use init_fun to force the status into a DataFrame, otherwise it would be automatically converted into a TimeStepTable{Status}.\n\njulia> status(m)\n2Ã—6 DataFrame\n Row â”‚ var4     var5     var6     var1     var3     var2    \n     â”‚ Float64  Float64  Float64  Float64  Float64  Float64 \nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1 â”‚    -Inf     -Inf     -Inf   13.747     -Inf      1.0\n   2 â”‚    -Inf     -Inf     -Inf   13.8       -Inf      1.0\n\nNote that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Status","page":"API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> st = PlantSimEngine.Status(Râ‚›=13.747, sky_fraction=1.0, d=0.03, PPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Râ‚›]\n13.747\n\njulia> st.Râ‚›\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Râ‚›] = 20.0\n20.0\n\njulia> st.Râ‚› = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.EF-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dep","page":"API","title":"PlantSimEngine.dep","text":"dep(m::ModelList, nsteps=1; verbose::Bool=true)\n\nGet the model dependency graph given a ModelList. If one graph is returned, then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;vars...)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.dr-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmottâ€™s refined index of agreement dáµ£. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.fit","page":"API","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/light.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of PPFD, LAI  and Ri_PAR_f. \n\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/light.jl\"))\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(PPFD=m[:PPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated PPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, <:ModelList}, Any}","page":"API","title":"PlantSimEngine.init_mtg_models!","text":"init_mtg_models!(\n    mtg::MultiScaleTreeGraph.Node,\n    models::Dict{String,<:ModelList},\n    i=nothing;\n    verbose=true,\n    attr_name=:models\n)\n\ninitialize the components of an MTG (i.e. nodes) with the corresponding models.\n\nThe function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.\n\nArguments\n\nmtg::MultiScaleTreeGraph.Node: the MTG tree.\nmodels::Dict{String,ModelList}: a dictionary of models named by components names\ni=nothing: the time-step to initialize. If nothing, initialize all the time-steps.\nverbose = true: return information during the processes\nattr_name = :models: the node attribute name used to store the models, default to \n\nSymbol(MultiScaleTreeGraph.cache_name(\"PlantSimEngine models\"))\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Make an MTG:\nmtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\nleaf = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"<\", \"Leaf\", 1, 2))\nleaf[:var1] = [15.0, 16.0]\nleaf[:var2] = 0.3\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Checking which variables are needed for our models:\n[component => to_initialize(model) for (component, model) in models]\n# OK we need to initialize :var1 and :var2\n\n# We could compute them directly inside the MTG from available variables instead of \n# giving them as initialisations:\ntransform!(\n    mtg,\n    :var1 => (x -> x .+ 2.0) => :var2,\n    ignore_nothing = true\n)\n\n# Initialising all components with their corresponding models and initialisations at time-step 1:\ninit_mtg_models!(mtg, models, 1)\n\nNote that this is possible only because the initialisation values are found in the MTG. If the initialisations are constant values between components, we can directly initialize them in the models definition (as we do in the begining).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.run!","page":"API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or an MTG.\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters.\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time).\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nWe use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the package:\n\njulia> include(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> run!(models, meteo);\n\nGet the results:\n\njulia> (models[:var4],models[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.status-Tuple{Any}","page":"API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(v::T, vars...) where T <: Union{Missing,AbstractModel}\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(m::AbstractDependencyNode)\n\nReturn the variables that must be initialized providing a set of models and processes. The function just returns the inputs and outputs of each model, with their default values. To take into account model coupling, use the function at an upper-level instead, i.e.  to_initialize(m::ModelList) or to_initialize(m::DependencyGraph).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{Module}","page":"API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}","page":"API","title":"PlantSimEngine.variables","text":"variables(m::AbstractDependencyNode)\n\nReturns a tuple with the name of the inputs and outputs variables needed by a model in  a dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n5-element Vector{Symbol}:\n :var1\n :var2\n :var3\n :var4\n :var5\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"API/#Un-exported","page":"API","title":"Un-exported","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat). ","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:AbstractDict}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:TimeStepTable}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,<:TimeStepTable})\n\nImplementation of DataFrame for a ModelList model with several time steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for Node, SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.DependencyGraph","page":"API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:ModelList","page":"API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tâ‚— variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tâ‚— at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion; init_fun=init_fun_default)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status should have the same number of time-steps (2) than weather data (3).\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}","page":"API","title":"PlantSimEngine.convert_vars","text":"convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)\nconvert_vars(type_promotion::Nothing, ref_vars)\n\nConvert the status variables to the type specified in the type promotion dictionary.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_panel-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of inputs.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_Ref_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Nothing","page":"API","title":"PlantSimEngine.get_Ref_i","text":"get_Ref_i(node, attr, i<:Nothing)\nget_Ref_i(node, attr, i)\n\nGet reference to node attribute at ith value or value if i<:Nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tâ‚—=[25.0, 26.0], PPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.soft_dependencies","page":"API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function, visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\nfunction f(node)\n    node.value\nend\n\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\n\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}","page":"API","title":"PlantSimEngine.update_mtg_models!","text":"update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)\n\nUpdate the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so init_mtg_models! must be called before update_mtg_models!.\n\nThe values are updated only for node attributes in to_init. Those attributes must have several time-steps, i.e. indexable by 1:n time-steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"API/#Tables.schema-Union{Tuple{TimeStepTable{T}}, Tuple{T}} where T<:Status","page":"API","title":"Tables.schema","text":"Tables.schema(m::TimeStepTable{Status})\n\nCreate a schema for a TimeStepTable{Status}.\n\n\n\n\n\n","category":"method"},{"location":"reducing_dof/#Reducing-the-DoF","page":"Reducing DoF","title":"Reducing the DoF","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"reducing_dof/#Introduction","page":"Reducing DoF","title":"Introduction","text":"","category":"section"},{"location":"reducing_dof/#Why-reducing-the-degrees-of-freedom","page":"Reducing DoF","title":"Why reducing the degrees of freedom","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Reducing the degrees of freedom in a model, by forcing certain variables to measurements, can be useful for several reasons:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It can prevent overfitting by constraining the model and making it less complex.\nIt can help to better calibrate the other components of the model by reducing the co-variability of the variables (see Parameter degeneracy).\nIt can lead to more interpretable models by identifying the most important variables and relationships.\nIt can improve the computational efficiency of the model by reducing the number of variables that need to be estimated.\nIt can also help to ensure that the model is consistent with known physical or observational constraints and improve the credibility of the model and its predictions.\nIt is important to note that over-constraining a model can also lead to poor fits and false conclusions, so it is essential to carefully consider which variables to constrain and to what measurements.","category":"page"},{"location":"reducing_dof/#Parameter-degeneracy","page":"Reducing DoF","title":"Parameter degeneracy","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"The concept of \"degeneracy\" or \"parameter degeneracy\" in a model occurs when two or more variables in a model are highly correlated, and small changes in one variable can be compensated by small changes in another variable, so that the overall predictions of the model remain unchanged. Degeneracy can make it difficult to estimate the true values of the variables and to determine the unique solutions of the model. It also makes the model sensitive to the initial conditions (e.g. the parameters) and the optimization algorithm used.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Degeneracy is related to the concept of \"co-variability\" or \"collinearity\", which refers to the degree of linear relationship between two or more variables. In a degenerate model, two or more variables are highly co-variate, meaning that they are highly correlated and can produce similar predictions. By fixing one variable to a measured value, the model will have less flexibility to adjust the other variables, which can help to reduce the co-variability and improve the robustness of the model.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"This is an important topic in plant/crop modelling, as the models are very often degenerate. It is most often referred to as \"multicollinearity\" in the field. In the context of model calibration, it is also known as \"parameter degeneracy\" or \"parameter collinearity\". In the context of model reduction, it is also known as \"redundancy\" or \"redundant variables\".","category":"page"},{"location":"reducing_dof/#Reducing-the-DoF-in-PlantSimEngine","page":"Reducing DoF","title":"Reducing the DoF in PlantSimEngine","text":"","category":"section"},{"location":"reducing_dof/#Soft-coupled-models","page":"Reducing DoF","title":"Soft-coupled models","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"PlantSimEngine provides a simple way to reduce the degrees of freedom in a model by constraining the values of some variables to measurements.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's define a model list as usual with the seven processes from examples/dummy.jl:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Let's say that m is our complete model, and that we want to reduce the degrees of freedom by constraining the value of var9 to a measurement, which was previously computed by Process7Model, a soft-dependency model. It is very easy to do this in PlantSimEngine: just remove the model from the model list and give the value of the measurement in the status:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nrun!(m2, meteo)\n\nstatus(m2)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"And that's it ! The models that depend on var9 will now use the measured value of var9 instead of the one computed by Process7Model.","category":"page"},{"location":"reducing_dof/#Hard-coupled-models","page":"Reducing DoF","title":"Hard-coupled models","text":"","category":"section"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"It is a bit more complicated to reduce the degrees of freedom in a model that is hard-coupled to another model, because it calls the run! method of the other model.","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"In this case, we need to replace the old model with a new model that forces the value of the variable to the measurement. This is done by giving the measurements as inputs of the new model, and returning nothing so the value is unchanged. ","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Starting from the model list with the seven processes from above, but this time let's say that we want to reduce the degrees of freedom by constraining the value of var3 to a measurement, which was previously computed by Process1Model, a hard-dependency model. It is very easy to do this in PlantSimEngine: just replace the model by a new model that forces the value of var3 to the measurement:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"struct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"Now we can create a new model list with the new model for process7:","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"m3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nrun!(m3, meteo)\n\nstatus(m3)","category":"page"},{"location":"reducing_dof/","page":"Reducing DoF","title":"Reducing DoF","text":"note: Note\nWe could also eventually provide the measured variable using the meteo data, but it is not recommended. The meteo data is meant to be used for the meteo variables only, and not for the model variables. It is better to use the status for that.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: DOI)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine is a package for the simulation and modelling of plants, soil and atmosphere. It is designed to help researchers and practitioners prototype, implement, test plant/crop models at any scale, without the hassle of computer science technicality behind model coupling, running on several time-steps or objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package defines a framework for declaring processes and implementing associated models for their simulation. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It focuses on key aspects of simulation and modeling such as: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"easy definition of new processes, such as light interception, photosynthesis, growth, soil water transfer...\nfast, interactive prototyping of models, with constraints to help users avoid errors, but sensible defaults to avoid over-complicating the model writing process\nno hassle, the package manages automatically input and output variables, time-steps, objects, soft and hard coupling of models with a dependency graph\nswitch between models without changing any code, with a simple syntax to define the model to use for a given process\nReduce the degrees of freedom by fixing variables, passing measurements, or using a simpler model for a given process\nðŸš€(very) fast computation ðŸš€, think of 100th of nanoseconds for the full energy balance of a leaf using PlantBiophysics.jl that uses PlantSimEngine\nOut of the box Sequential, Parallel (Multi-threaded) or Distributed (Multi-Process) computations over objects, time-steps and independent processes (thanks to Floops.jl)\neasily scalable, with methods for computing over objects, time-steps and even Multi-Scale Tree Graphs\ncomposable, allowing the use of any types as inputs such as Unitful to propagate units, or MonteCarloMeasurements.jl to propagate measurement error","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want thanks to its MIT license. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! ðŸ˜ƒ","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Users","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantSimEngine, PlantMeteo\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls again run! inside its implementation at some point. Note that it does not force any kind of conductance model over another, just that there is one to simulate the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We provide an example script that implements seven dummy processes in examples/dummy. The processes are simply called \"process1\", \"process2\"..., and the model implementations are called Process1Model, Process2Model... ","category":"page"},{"location":"model_coupling/model_coupling_user/#Hard-coupled-models","page":"Users","title":"Hard coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"The Process3Model calls Process2Model, and Process2Model calls Process1Model. This explicit call is called a hard-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"The other models for the other processes are called Process4Model, Process5Model... and they do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"tip: Tip\nHard-coupling of models is usually done when there are some kind of iterative computation in one of the models that depend on one another. This is not the case in our example here as it is obviously just a simple one. In this case the coupling is not really necessary as models could just be called sequentially one after the other. For a more representative example, you can look at the energy balance computation of Monteith in PlantBiophysics.jl, which is hard-coupled to a photosynthesis model.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Back to our example, using Process3Model requires a \"process2\" model, and in our case the only model available is Process2Model. The latter also requires a \"process1\" model, and again we only have one model implementation for this process, which is Process1Model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's include this script so we can play around:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"include(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"tip: Tip\nUse subtype(x) to know which models are available for a process, e.g. for \"process1\" you can do subtypes(AbstractProcess1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Here is how we can make the models coupling:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We can see that only the first model has a parameter. You can usually know that by looking at the help of the structure (e.g. ?Process1Model), else, you can still look at the field names of the structure like so fieldnames(Process1Model).","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Note that the user only declares the models, not the way the models are coupled, because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Now the example above returns some warnings saying we need to initialize some variables: var1 and var2. PlantSimEngine.jl automatically computes which variables should be initialized based on the inputs and outputs of all models, considering their hard or soft-coupling.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"For example Process1Model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Process1Model(2.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"And Process2Model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We see that var1 is needed as inputs of both models, but we also see that var3 is an output of Process2Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"outputs(Process2Model())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"So considering those two models, we only need var1 and var2 to be initialized, as var3 is computed. This is why we recommend to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # Just so we don't have the warning printed out\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"page"},{"location":"model_coupling/model_coupling_user/#Soft-coupled-models","page":"Users","title":"Soft coupled models","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"All following models (Process4Model to Process7Model) do not call explicitly other models when running, but some outputs of the models are used as inputs of other models. This is called a soft-dependency in PlantSimEngine.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's make a new model list including the soft-coupled models:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"With this list of models, we only need to initialize var0, that is an input of Process4Model and Process7Model:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"to_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We can initialize it like so:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"page"},{"location":"model_coupling/model_coupling_user/#Simulation-order","page":"Users","title":"Simulation order","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"When calling run!, the models are run in the right order using a dependency graph that is computed automatically based on the hard and soft dependencies of the models following a simple set of rules:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Independent models are run first. A model is independent if it can be run alone, or only using initializations. It is not dependent on any other model.\nFrom their children dependencies:\nHard dependencies are always run before soft dependencies. Inner hard dependency graphs are considered as a whole, i.e. as a single soft dependency.\nSoft dependencies are then run sequentially. If a soft dependency has several parent nodes (i.e. its inputs are computed by several models), it is run only if all its parent nodes have been run already. In practice, when we visit a node that has one of its parent that did not run already, we stop the visit of this branch. The node will eventually be visited from the branch of the last parent that was run.","category":"page"}]
}
